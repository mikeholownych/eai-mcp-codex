"""
API Security Scanning and Vulnerability Detection

Comprehensive vulnerability scanning system that includes:
- API endpoint security scanning
- Dependency vulnerability checking
- Configuration security analysis
- OWASP Top 10 vulnerability detection
- Dynamic security testing
- Static code analysis integration
- Compliance checks (GDPR, HIPAA, SOC2)
"""

import json
import logging
import time
import re
import hashlib
import subprocess
import secrets
from typing import Dict, Any, List, Optional
from datetime import datetime
from enum import Enum
from dataclasses import dataclass, field
from pathlib import Path
import yaml

import aiohttp
import aiofiles
from fastapi import FastAPI, HTTPException
from urllib.parse import urljoin

from ..common.redis_client import RedisClient
from .audit_logging import AuditLogger, AuditEventType

logger = logging.getLogger(__name__)


class VulnerabilitySeverity(str, Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class VulnerabilityType(str, Enum):
    """Types of vulnerabilities"""
    INJECTION = "injection"
    BROKEN_AUTH = "broken_authentication"
    SENSITIVE_DATA = "sensitive_data_exposure"
    XXE = "xml_external_entities"
    BROKEN_ACCESS = "broken_access_control"
    SECURITY_MISCONFIG = "security_misconfiguration"
    XSS = "cross_site_scripting"
    INSECURE_DESERIALIZATION = "insecure_deserialization"
    KNOWN_VULNERABILITIES = "known_vulnerabilities"
    INSUFFICIENT_LOGGING = "insufficient_logging"
    CSRF = "cross_site_request_forgery"
    CLICKJACKING = "clickjacking"
    DIRECTORY_TRAVERSAL = "directory_traversal"
    INSECURE_COMMUNICATION = "insecure_communication"
    WEAK_CRYPTO = "weak_cryptography"


class ScanType(str, Enum):
    """Types of security scans"""
    API_ENDPOINTS = "api_endpoints"
    DEPENDENCIES = "dependencies"
    CONFIGURATION = "configuration"
    STATIC_CODE = "static_code"
    DYNAMIC_TEST = "dynamic_test"
    COMPLIANCE = "compliance"


@dataclass
class Vulnerability:
    """Represents a security vulnerability"""
    vuln_id: str
    title: str
    description: str
    severity: VulnerabilitySeverity
    vulnerability_type: VulnerabilityType
    scan_type: ScanType
    affected_component: str
    file_path: Optional[str] = None
    line_number: Optional[int] = None
    endpoint: Optional[str] = None
    cve_id: Optional[str] = None
    cvss_score: Optional[float] = None
    remediation: Optional[str] = None
    references: List[str] = field(default_factory=list)
    discovered_at: datetime = field(default_factory=datetime.utcnow)
    is_fixed: bool = False
    fixed_at: Optional[datetime] = None
    false_positive: bool = False
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            "vuln_id": self.vuln_id,
            "title": self.title,
            "description": self.description,
            "severity": self.severity.value,
            "vulnerability_type": self.vulnerability_type.value,
            "scan_type": self.scan_type.value,
            "affected_component": self.affected_component,
            "file_path": self.file_path,
            "line_number": self.line_number,
            "endpoint": self.endpoint,
            "cve_id": self.cve_id,
            "cvss_score": self.cvss_score,
            "remediation": self.remediation,
            "references": self.references,
            "discovered_at": self.discovered_at.isoformat(),
            "is_fixed": self.is_fixed,
            "fixed_at": self.fixed_at.isoformat() if self.fixed_at else None,
            "false_positive": self.false_positive
        }


@dataclass
class ScanResult:
    """Results of a security scan"""
    scan_id: str
    scan_type: ScanType
    started_at: datetime
    completed_at: Optional[datetime] = None
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    is_completed: bool = False
    error_message: Optional[str] = None
    
    def get_vulnerabilities_by_severity(self) -> Dict[VulnerabilitySeverity, List[Vulnerability]]:
        """Group vulnerabilities by severity"""
        result = {severity: [] for severity in VulnerabilitySeverity}
        for vuln in self.vulnerabilities:
            result[vuln.severity].append(vuln)
        return result


class APIEndpointScanner:
    """Scans API endpoints for security vulnerabilities"""
    
    def __init__(self, base_url: str):
        self.base_url = base_url
        self.endpoints: List[Dict[str, Any]] = []
        
        # Common payloads for testing
        self.sql_injection_payloads = [
            "' OR '1'='1",
            "'; DROP TABLE users; --",
            "' UNION SELECT * FROM users --",
            "1' AND '1'='1",
            "admin'--"
        ]
        
        self.xss_payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "'\"><script>alert('XSS')</script>",
            "<svg onload=alert('XSS')>"
        ]
        
        self.path_traversal_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "....//....//....//etc/passwd"
        ]
    
    async def discover_endpoints(self, app: FastAPI) -> List[Dict[str, Any]]:
        """Discover API endpoints from FastAPI app"""
        endpoints = []
        
        for route in app.routes:
            if hasattr(route, 'methods') and hasattr(route, 'path'):
                for method in route.methods:
                    if method != 'HEAD':  # Skip HEAD requests
                        endpoints.append({
                            "method": method,
                            "path": route.path,
                            "name": getattr(route, 'name', 'unknown'),
                            "url": urljoin(self.base_url, route.path.lstrip('/'))
                        })
        
        self.endpoints = endpoints
        return endpoints
    
    async def scan_endpoints(self) -> List[Vulnerability]:
        """Scan all discovered endpoints for vulnerabilities"""
        vulnerabilities = []
        
        for endpoint in self.endpoints:
            endpoint_vulns = await self._scan_single_endpoint(endpoint)
            vulnerabilities.extend(endpoint_vulns)
        
        return vulnerabilities
    
    async def _scan_single_endpoint(self, endpoint: Dict[str, Any]) -> List[Vulnerability]:
        """Scan a single endpoint for vulnerabilities"""
        vulnerabilities = []
        method = endpoint["method"]
        url = endpoint["url"]
        path = endpoint["path"]
        
        try:
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=30)) as session:
                # Test for basic endpoint accessibility
                vulns = await self._test_endpoint_access(session, endpoint)
                vulnerabilities.extend(vulns)
                
                # Test for injection vulnerabilities
                if method in ["GET", "POST", "PUT", "PATCH"]:
                    vulns = await self._test_injection_vulnerabilities(session, endpoint)
                    vulnerabilities.extend(vulns)
                
                # Test for XSS vulnerabilities
                if method in ["GET", "POST"]:
                    vulns = await self._test_xss_vulnerabilities(session, endpoint)
                    vulnerabilities.extend(vulns)
                
                # Test for path traversal
                vulns = await self._test_path_traversal(session, endpoint)
                vulnerabilities.extend(vulns)
                
                # Test for security headers
                vulns = await self._test_security_headers(session, endpoint)
                vulnerabilities.extend(vulns)
                
                # Test for authentication bypass
                vulns = await self._test_auth_bypass(session, endpoint)
                vulnerabilities.extend(vulns)
        
        except Exception as e:
            logger.error(f"Error scanning endpoint {url}: {e}")
        
        return vulnerabilities
    
    async def _test_endpoint_access(self, session: aiohttp.ClientSession, endpoint: Dict[str, Any]) -> List[Vulnerability]:
        """Test basic endpoint access and response"""
        vulnerabilities = []
        
        try:
            async with session.request(endpoint["method"], endpoint["url"]) as response:
                # Check for verbose error messages
                if response.status >= 500:
                    response_text = await response.text()
                    if any(term in response_text.lower() for term in ["traceback", "stack trace", "exception", "error details"]):
                        vulnerabilities.append(Vulnerability(
                            vuln_id=f"verbose_error_{hashlib.md5(endpoint['url'].encode()).hexdigest()[:8]}",
                            title="Verbose Error Messages",
                            description="The endpoint returns detailed error information that could help attackers",
                            severity=VulnerabilitySeverity.LOW,
                            vulnerability_type=VulnerabilityType.SENSITIVE_DATA,
                            scan_type=ScanType.API_ENDPOINTS,
                            affected_component=endpoint["path"],
                            endpoint=endpoint["url"],
                            remediation="Configure proper error handling to avoid exposing sensitive information"
                        ))
                
                # Check for directory listing
                if response.status == 200 and "index of" in (await response.text()).lower():
                    vulnerabilities.append(Vulnerability(
                        vuln_id=f"directory_listing_{hashlib.md5(endpoint['url'].encode()).hexdigest()[:8]}",
                        title="Directory Listing Enabled",
                        description="Directory listing is enabled, exposing file structure",
                        severity=VulnerabilitySeverity.MEDIUM,
                        vulnerability_type=VulnerabilityType.SENSITIVE_DATA,
                        scan_type=ScanType.API_ENDPOINTS,
                        affected_component=endpoint["path"],
                        endpoint=endpoint["url"],
                        remediation="Disable directory listing in web server configuration"
                    ))
        
        except Exception as e:
            logger.debug(f"Access test failed for {endpoint['url']}: {e}")
        
        return vulnerabilities
    
    async def _test_injection_vulnerabilities(self, session: aiohttp.ClientSession, endpoint: Dict[str, Any]) -> List[Vulnerability]:
        """Test for SQL and NoSQL injection vulnerabilities"""
        vulnerabilities = []
        
        for payload in self.sql_injection_payloads:
            try:
                # Test in URL parameters
                test_url = f"{endpoint['url']}?test={payload}"
                async with session.request(endpoint["method"], test_url) as response:
                    response_text = await response.text()
                    
                    # Look for SQL error patterns
                    sql_error_patterns = [
                        "sql syntax", "mysql", "postgresql", "sqlite", "oracle",
                        "syntax error", "column", "table", "database"
                    ]
                    
                    if any(pattern in response_text.lower() for pattern in sql_error_patterns):
                        vulnerabilities.append(Vulnerability(
                            vuln_id=f"sql_injection_{hashlib.md5((endpoint['url'] + payload).encode()).hexdigest()[:8]}",
                            title="SQL Injection Vulnerability",
                            description=f"Endpoint appears vulnerable to SQL injection with payload: {payload}",
                            severity=VulnerabilitySeverity.CRITICAL,
                            vulnerability_type=VulnerabilityType.INJECTION,
                            scan_type=ScanType.API_ENDPOINTS,
                            affected_component=endpoint["path"],
                            endpoint=endpoint["url"],
                            remediation="Use parameterized queries and input validation"
                        ))
                        break  # Don't test more payloads if one works
                
                # Test in POST body for POST endpoints
                if endpoint["method"] == "POST":
                    test_data = {"test": payload}
                    async with session.post(endpoint["url"], json=test_data) as response:
                        response_text = await response.text()
                        
                        if any(pattern in response_text.lower() for pattern in sql_error_patterns):
                            vulnerabilities.append(Vulnerability(
                                vuln_id=f"sql_injection_post_{hashlib.md5((endpoint['url'] + payload).encode()).hexdigest()[:8]}",
                                title="SQL Injection in POST Body",
                                description="POST endpoint vulnerable to SQL injection",
                                severity=VulnerabilitySeverity.CRITICAL,
                                vulnerability_type=VulnerabilityType.INJECTION,
                                scan_type=ScanType.API_ENDPOINTS,
                                affected_component=endpoint["path"],
                                endpoint=endpoint["url"],
                                remediation="Use parameterized queries and validate POST data"
                            ))
                            break
            
            except Exception as e:
                logger.debug(f"Injection test failed for {endpoint['url']}: {e}")
        
        return vulnerabilities
    
    async def _test_xss_vulnerabilities(self, session: aiohttp.ClientSession, endpoint: Dict[str, Any]) -> List[Vulnerability]:
        """Test for Cross-Site Scripting vulnerabilities"""
        vulnerabilities = []
        
        for payload in self.xss_payloads:
            try:
                # Test reflected XSS in URL parameters
                test_url = f"{endpoint['url']}?test={payload}"
                async with session.get(test_url) as response:
                    response_text = await response.text()
                    
                    # Check if payload is reflected without encoding
                    if payload in response_text or payload.replace("'", "&#x27;") not in response_text:
                        vulnerabilities.append(Vulnerability(
                            vuln_id=f"xss_reflected_{hashlib.md5((endpoint['url'] + payload).encode()).hexdigest()[:8]}",
                            title="Reflected XSS Vulnerability",
                            description="Endpoint reflects user input without proper encoding",
                            severity=VulnerabilitySeverity.HIGH,
                            vulnerability_type=VulnerabilityType.XSS,
                            scan_type=ScanType.API_ENDPOINTS,
                            affected_component=endpoint["path"],
                            endpoint=endpoint["url"],
                            remediation="Implement proper output encoding and Content Security Policy"
                        ))
                        break
            
            except Exception as e:
                logger.debug(f"XSS test failed for {endpoint['url']}: {e}")
        
        return vulnerabilities
    
    async def _test_path_traversal(self, session: aiohttp.ClientSession, endpoint: Dict[str, Any]) -> List[Vulnerability]:
        """Test for path traversal vulnerabilities"""
        vulnerabilities = []
        
        for payload in self.path_traversal_payloads:
            try:
                test_url = f"{endpoint['url']}?file={payload}"
                async with session.get(test_url) as response:
                    response_text = await response.text()
                    
                    # Look for signs of successful path traversal
                    path_traversal_indicators = [
                        "root:x:", "bin/bash", "[system process]",
                        "windows\\system32", "127.0.0.1"
                    ]
                    
                    if any(indicator in response_text.lower() for indicator in path_traversal_indicators):
                        vulnerabilities.append(Vulnerability(
                            vuln_id=f"path_traversal_{hashlib.md5((endpoint['url'] + payload).encode()).hexdigest()[:8]}",
                            title="Path Traversal Vulnerability",
                            description="Endpoint allows access to system files",
                            severity=VulnerabilitySeverity.HIGH,
                            vulnerability_type=VulnerabilityType.DIRECTORY_TRAVERSAL,
                            scan_type=ScanType.API_ENDPOINTS,
                            affected_component=endpoint["path"],
                            endpoint=endpoint["url"],
                            remediation="Validate and sanitize file path inputs"
                        ))
                        break
            
            except Exception as e:
                logger.debug(f"Path traversal test failed for {endpoint['url']}: {e}")
        
        return vulnerabilities
    
    async def _test_security_headers(self, session: aiohttp.ClientSession, endpoint: Dict[str, Any]) -> List[Vulnerability]:
        """Test for missing security headers"""
        vulnerabilities = []
        
        try:
            async with session.get(endpoint["url"]) as response:
                headers = response.headers
                
                # Check for missing security headers
                security_headers = {
                    "X-Frame-Options": "Clickjacking protection",
                    "X-Content-Type-Options": "MIME type sniffing protection",
                    "X-XSS-Protection": "XSS filter",
                    "Strict-Transport-Security": "HTTPS enforcement",
                    "Content-Security-Policy": "Content Security Policy"
                }
                
                for header, description in security_headers.items():
                    if header not in headers:
                        vulnerabilities.append(Vulnerability(
                            vuln_id=f"missing_header_{header.lower().replace('-', '_')}_{hashlib.md5(endpoint['url'].encode()).hexdigest()[:8]}",
                            title=f"Missing {header} Header",
                            description=f"The {header} header is missing, which provides {description.lower()}",
                            severity=VulnerabilitySeverity.MEDIUM,
                            vulnerability_type=VulnerabilityType.SECURITY_MISCONFIG,
                            scan_type=ScanType.API_ENDPOINTS,
                            affected_component=endpoint["path"],
                            endpoint=endpoint["url"],
                            remediation=f"Add the {header} header to improve security"
                        ))
        
        except Exception as e:
            logger.debug(f"Security headers test failed for {endpoint['url']}: {e}")
        
        return vulnerabilities
    
    async def _test_auth_bypass(self, session: aiohttp.ClientSession, endpoint: Dict[str, Any]) -> List[Vulnerability]:
        """Test for authentication bypass vulnerabilities"""
        vulnerabilities = []
        
        # Test for endpoints that should require authentication
        protected_path_patterns = [
            r"/admin", r"/api/admin", r"/dashboard", r"/config",
            r"/users", r"/profile", r"/settings"
        ]
        
        if any(re.search(pattern, endpoint["path"], re.IGNORECASE) for pattern in protected_path_patterns):
            try:
                async with session.request(endpoint["method"], endpoint["url"]) as response:
                    # If we get a 200 OK without authentication, it might be a problem
                    if response.status == 200:
                        vulnerabilities.append(Vulnerability(
                            vuln_id=f"auth_bypass_{hashlib.md5(endpoint['url'].encode()).hexdigest()[:8]}",
                            title="Potential Authentication Bypass",
                            description="Protected endpoint accessible without authentication",
                            severity=VulnerabilitySeverity.HIGH,
                            vulnerability_type=VulnerabilityType.BROKEN_ACCESS,
                            scan_type=ScanType.API_ENDPOINTS,
                            affected_component=endpoint["path"],
                            endpoint=endpoint["url"],
                            remediation="Implement proper authentication checks for protected endpoints"
                        ))
            
            except Exception as e:
                logger.debug(f"Auth bypass test failed for {endpoint['url']}: {e}")
        
        return vulnerabilities


class DependencyScanner:
    """Scans project dependencies for known vulnerabilities"""
    
    def __init__(self, project_path: str):
        self.project_path = Path(project_path)
        self.vulnerability_databases = {
            "python": "https://pyup.io/safety/",
            "nodejs": "https://registry.npmjs.org/-/npm/v1/security/audits",
            "java": "https://ossindex.sonatype.org/api/v3/",
        }
    
    async def scan_dependencies(self) -> List[Vulnerability]:
        """Scan all project dependencies"""
        vulnerabilities = []
        
        # Scan Python dependencies
        if (self.project_path / "requirements.txt").exists():
            python_vulns = await self._scan_python_dependencies()
            vulnerabilities.extend(python_vulns)
        
        # Scan Node.js dependencies
        if (self.project_path / "package.json").exists():
            nodejs_vulns = await self._scan_nodejs_dependencies()
            vulnerabilities.extend(nodejs_vulns)
        
        # Scan Docker images
        docker_files = list(self.project_path.glob("**/Dockerfile*"))
        for dockerfile in docker_files:
            docker_vulns = await self._scan_dockerfile(dockerfile)
            vulnerabilities.extend(docker_vulns)
        
        return vulnerabilities
    
    async def _scan_python_dependencies(self) -> List[Vulnerability]:
        """Scan Python dependencies using Safety"""
        vulnerabilities = []
        requirements_file = self.project_path / "requirements.txt"
        
        try:
            # Run safety check
            result = subprocess.run([
                "python", "-m", "safety", "check",
                "-r", str(requirements_file),
                "--json"
            ], capture_output=True, text=True, timeout=60)
            
            if result.returncode == 0 and result.stdout:
                safety_results = json.loads(result.stdout)
                
                for vuln_data in safety_results:
                    vulnerabilities.append(Vulnerability(
                        vuln_id=f"py_dep_{vuln_data.get('id', 'unknown')}",
                        title=f"Vulnerable Python Package: {vuln_data.get('package', 'Unknown')}",
                        description=vuln_data.get('advisory', 'No description available'),
                        severity=self._map_safety_severity(vuln_data.get('severity', 'medium')),
                        vulnerability_type=VulnerabilityType.KNOWN_VULNERABILITIES,
                        scan_type=ScanType.DEPENDENCIES,
                        affected_component=vuln_data.get('package', 'Unknown'),
                        cve_id=vuln_data.get('cve'),
                        remediation=f"Update {vuln_data.get('package')} to version {vuln_data.get('safe_versions', ['latest'])[0]}"
                    ))
        
        except subprocess.TimeoutExpired:
            logger.error("Safety check timed out")
        except Exception as e:
            logger.error(f"Error running safety check: {e}")
        
        return vulnerabilities
    
    async def _scan_nodejs_dependencies(self) -> List[Vulnerability]:
        """Scan Node.js dependencies using npm audit"""
        vulnerabilities = []
        package_json = self.project_path / "package.json"
        
        try:
            # Change to project directory and run npm audit
            result = subprocess.run([
                "npm", "audit", "--json"
            ], cwd=str(self.project_path), capture_output=True, text=True, timeout=60)
            
            if result.stdout:
                audit_results = json.loads(result.stdout)
                
                for vuln_id, vuln_data in audit_results.get("vulnerabilities", {}).items():
                    vulnerabilities.append(Vulnerability(
                        vuln_id=f"npm_dep_{vuln_id}",
                        title=f"Vulnerable Node.js Package: {vuln_data.get('name', 'Unknown')}",
                        description=vuln_data.get('via', [{}])[0].get('title', 'No description available'),
                        severity=self._map_npm_severity(vuln_data.get('severity', 'moderate')),
                        vulnerability_type=VulnerabilityType.KNOWN_VULNERABILITIES,
                        scan_type=ScanType.DEPENDENCIES,
                        affected_component=vuln_data.get('name', 'Unknown'),
                        cve_id=vuln_data.get('via', [{}])[0].get('cve'),
                        remediation="Update to fix available versions"
                    ))
        
        except subprocess.TimeoutExpired:
            logger.error("npm audit timed out")
        except Exception as e:
            logger.error(f"Error running npm audit: {e}")
        
        return vulnerabilities
    
    async def _scan_dockerfile(self, dockerfile_path: Path) -> List[Vulnerability]:
        """Scan Dockerfile for security issues"""
        vulnerabilities = []
        
        try:
            async with aiofiles.open(dockerfile_path, 'r') as f:
                content = await f.read()
            
            lines = content.split('\n')
            
            for line_num, line in enumerate(lines, 1):
                line = line.strip()
                
                # Check for running as root
                if line.startswith('USER root') or (line.startswith('RUN') and 'sudo' in line):
                    vulnerabilities.append(Vulnerability(
                        vuln_id=f"docker_root_{hashlib.md5(str(dockerfile_path).encode()).hexdigest()[:8]}_{line_num}",
                        title="Container Running as Root",
                        description="Container is configured to run as root user",
                        severity=VulnerabilitySeverity.MEDIUM,
                        vulnerability_type=VulnerabilityType.SECURITY_MISCONFIG,
                        scan_type=ScanType.DEPENDENCIES,
                        affected_component=str(dockerfile_path),
                        file_path=str(dockerfile_path),
                        line_number=line_num,
                        remediation="Use a non-root user for container execution"
                    ))
                
                # Check for hardcoded secrets
                secret_patterns = [
                    r'password\s*=\s*["\'][^"\']+["\']',
                    r'api[_-]?key\s*=\s*["\'][^"\']+["\']',
                    r'secret\s*=\s*["\'][^"\']+["\']'
                ]
                
                for pattern in secret_patterns:
                    if re.search(pattern, line, re.IGNORECASE):
                        vulnerabilities.append(Vulnerability(
                            vuln_id=f"docker_secret_{hashlib.md5((str(dockerfile_path) + line).encode()).hexdigest()[:8]}",
                            title="Hardcoded Secret in Dockerfile",
                            description="Dockerfile contains hardcoded credentials",
                            severity=VulnerabilitySeverity.HIGH,
                            vulnerability_type=VulnerabilityType.SENSITIVE_DATA,
                            scan_type=ScanType.DEPENDENCIES,
                            affected_component=str(dockerfile_path),
                            file_path=str(dockerfile_path),
                            line_number=line_num,
                            remediation="Use environment variables or secret management for credentials"
                        ))
        
        except Exception as e:
            logger.error(f"Error scanning Dockerfile {dockerfile_path}: {e}")
        
        return vulnerabilities
    
    def _map_safety_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map safety severity to our enum"""
        mapping = {
            "critical": VulnerabilitySeverity.CRITICAL,
            "high": VulnerabilitySeverity.HIGH,
            "medium": VulnerabilitySeverity.MEDIUM,
            "low": VulnerabilitySeverity.LOW
        }
        return mapping.get(severity.lower(), VulnerabilitySeverity.MEDIUM)
    
    def _map_npm_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map npm severity to our enum"""
        mapping = {
            "critical": VulnerabilitySeverity.CRITICAL,
            "high": VulnerabilitySeverity.HIGH,
            "moderate": VulnerabilitySeverity.MEDIUM,
            "low": VulnerabilitySeverity.LOW,
            "info": VulnerabilitySeverity.INFO
        }
        return mapping.get(severity.lower(), VulnerabilitySeverity.MEDIUM)


class ConfigurationScanner:
    """Scans system and application configuration for security issues"""
    
    def __init__(self, project_path: str):
        self.project_path = Path(project_path)
    
    async def scan_configuration(self) -> List[Vulnerability]:
        """Scan all configuration files"""
        vulnerabilities = []
        
        # Scan environment files
        env_files = list(self.project_path.glob("**/.env*"))
        for env_file in env_files:
            env_vulns = await self._scan_env_file(env_file)
            vulnerabilities.extend(env_vulns)
        
        # Scan YAML configuration files
        yaml_files = list(self.project_path.glob("**/*.yml")) + list(self.project_path.glob("**/*.yaml"))
        for yaml_file in yaml_files:
            yaml_vulns = await self._scan_yaml_file(yaml_file)
            vulnerabilities.extend(yaml_vulns)
        
        # Scan Docker Compose files
        compose_files = list(self.project_path.glob("**/docker-compose*.yml"))
        for compose_file in compose_files:
            compose_vulns = await self._scan_docker_compose(compose_file)
            vulnerabilities.extend(compose_vulns)
        
        return vulnerabilities
    
    async def _scan_env_file(self, env_file: Path) -> List[Vulnerability]:
        """Scan environment file for security issues"""
        vulnerabilities = []
        
        try:
            async with aiofiles.open(env_file, 'r') as f:
                content = await f.readlines()
            
            for line_num, line in enumerate(content, 1):
                line = line.strip()
                
                # Skip comments and empty lines
                if not line or line.startswith('#'):
                    continue
                
                # Check for weak passwords
                if 'password' in line.lower() and '=' in line:
                    _, value = line.split('=', 1)
                    value = value.strip().strip('"\'')
                    
                    if len(value) < 8 or value.lower() in ['password', '123456', 'admin', 'root']:
                        vulnerabilities.append(Vulnerability(
                            vuln_id=f"weak_password_{hashlib.md5((str(env_file) + line).encode()).hexdigest()[:8]}",
                            title="Weak Password in Environment File",
                            description="Environment file contains a weak password",
                            severity=VulnerabilitySeverity.HIGH,
                            vulnerability_type=VulnerabilityType.WEAK_CRYPTO,
                            scan_type=ScanType.CONFIGURATION,
                            affected_component=str(env_file),
                            file_path=str(env_file),
                            line_number=line_num,
                            remediation="Use strong, randomly generated passwords"
                        ))
                
                # Check for default values
                default_patterns = [
                    (r'SECRET_KEY\s*=\s*["\']?default["\']?', "Default secret key"),
                    (r'DEBUG\s*=\s*["\']?true["\']?', "Debug mode enabled"),
                    (r'ALLOWED_HOSTS\s*=\s*["\']?\*["\']?', "Overly permissive allowed hosts")
                ]
                
                for pattern, description in default_patterns:
                    if re.search(pattern, line, re.IGNORECASE):
                        vulnerabilities.append(Vulnerability(
                            vuln_id=f"default_config_{hashlib.md5((str(env_file) + line).encode()).hexdigest()[:8]}",
                            title="Insecure Default Configuration",
                            description=description,
                            severity=VulnerabilitySeverity.MEDIUM,
                            vulnerability_type=VulnerabilityType.SECURITY_MISCONFIG,
                            scan_type=ScanType.CONFIGURATION,
                            affected_component=str(env_file),
                            file_path=str(env_file),
                            line_number=line_num,
                            remediation="Change default configuration values"
                        ))
        
        except Exception as e:
            logger.error(f"Error scanning env file {env_file}: {e}")
        
        return vulnerabilities
    
    async def _scan_yaml_file(self, yaml_file: Path) -> List[Vulnerability]:
        """Scan YAML configuration file"""
        vulnerabilities = []
        
        try:
            async with aiofiles.open(yaml_file, 'r') as f:
                content = await f.read()
            
            # Parse YAML
            config = yaml.safe_load(content)
            
            # Check for insecure configurations
            insecure_configs = [
                ("ssl_verify", False, "SSL verification disabled"),
                ("debug", True, "Debug mode enabled"),
                ("allow_all_hosts", True, "All hosts allowed"),
                ("cors_allow_all", True, "CORS allows all origins")
            ]
            
            for key, insecure_value, description in insecure_configs:
                if self._find_in_yaml(config, key, insecure_value):
                    vulnerabilities.append(Vulnerability(
                        vuln_id=f"yaml_config_{key}_{hashlib.md5(str(yaml_file).encode()).hexdigest()[:8]}",
                        title=f"Insecure YAML Configuration: {key}",
                        description=description,
                        severity=VulnerabilitySeverity.MEDIUM,
                        vulnerability_type=VulnerabilityType.SECURITY_MISCONFIG,
                        scan_type=ScanType.CONFIGURATION,
                        affected_component=str(yaml_file),
                        file_path=str(yaml_file),
                        remediation=f"Review and secure the {key} configuration"
                    ))
        
        except Exception as e:
            logger.error(f"Error scanning YAML file {yaml_file}: {e}")
        
        return vulnerabilities
    
    async def _scan_docker_compose(self, compose_file: Path) -> List[Vulnerability]:
        """Scan Docker Compose file for security issues"""
        vulnerabilities = []
        
        try:
            async with aiofiles.open(compose_file, 'r') as f:
                content = await f.read()
            
            config = yaml.safe_load(content)
            
            for service_name, service_config in config.get('services', {}).items():
                # Check for privileged containers
                if service_config.get('privileged'):
                    vulnerabilities.append(Vulnerability(
                        vuln_id=f"privileged_container_{service_name}_{hashlib.md5(str(compose_file).encode()).hexdigest()[:8]}",
                        title="Privileged Container",
                        description=f"Service {service_name} runs in privileged mode",
                        severity=VulnerabilitySeverity.HIGH,
                        vulnerability_type=VulnerabilityType.SECURITY_MISCONFIG,
                        scan_type=ScanType.CONFIGURATION,
                        affected_component=service_name,
                        file_path=str(compose_file),
                        remediation="Avoid running containers in privileged mode"
                    ))
                
                # Check for host network mode
                if service_config.get('network_mode') == 'host':
                    vulnerabilities.append(Vulnerability(
                        vuln_id=f"host_network_{service_name}_{hashlib.md5(str(compose_file).encode()).hexdigest()[:8]}",
                        title="Host Network Mode",
                        description=f"Service {service_name} uses host network mode",
                        severity=VulnerabilitySeverity.MEDIUM,
                        vulnerability_type=VulnerabilityType.SECURITY_MISCONFIG,
                        scan_type=ScanType.CONFIGURATION,
                        affected_component=service_name,
                        file_path=str(compose_file),
                        remediation="Use bridge networking instead of host mode"
                    ))
                
                # Check for volume mounts
                volumes = service_config.get('volumes', [])
                for volume in volumes:
                    if isinstance(volume, str) and ':/etc' in volume or ':/var' in volume:
                        vulnerabilities.append(Vulnerability(
                            vuln_id=f"sensitive_mount_{service_name}_{hashlib.md5((str(compose_file) + volume).encode()).hexdigest()[:8]}",
                            title="Sensitive Directory Mount",
                            description=f"Service {service_name} mounts sensitive system directory",
                            severity=VulnerabilitySeverity.MEDIUM,
                            vulnerability_type=VulnerabilityType.SECURITY_MISCONFIG,
                            scan_type=ScanType.CONFIGURATION,
                            affected_component=service_name,
                            file_path=str(compose_file),
                            remediation="Avoid mounting sensitive system directories"
                        ))
        
        except Exception as e:
            logger.error(f"Error scanning Docker Compose file {compose_file}: {e}")
        
        return vulnerabilities
    
    def _find_in_yaml(self, data: Any, key: str, target_value: Any) -> bool:
        """Recursively search for key-value pair in YAML data"""
        if isinstance(data, dict):
            if key in data and data[key] == target_value:
                return True
            for value in data.values():
                if self._find_in_yaml(value, key, target_value):
                    return True
        elif isinstance(data, list):
            for item in data:
                if self._find_in_yaml(item, key, target_value):
                    return True
        return False


class VulnerabilityManager:
    """Manages vulnerability scanning and results"""
    
    def __init__(self, redis_client: RedisClient, audit_logger: AuditLogger):
        self.redis_client = redis_client
        self.audit_logger = audit_logger
        self.scan_results: Dict[str, ScanResult] = {}
    
    async def run_comprehensive_scan(self, 
                                   app: Optional[FastAPI] = None,
                                   base_url: str = "http://localhost:8000",
                                   project_path: str = ".") -> ScanResult:
        """Run comprehensive security scan"""
        scan_id = f"scan_{int(time.time())}_{secrets.token_hex(4)}"
        
        scan_result = ScanResult(
            scan_id=scan_id,
            scan_type=ScanType.API_ENDPOINTS,  # Will include multiple types
            started_at=datetime.utcnow()
        )
        
        self.scan_results[scan_id] = scan_result
        
        try:
            # API endpoint scanning
            if app:
                api_scanner = APIEndpointScanner(base_url)
                await api_scanner.discover_endpoints(app)
                api_vulns = await api_scanner.scan_endpoints()
                scan_result.vulnerabilities.extend(api_vulns)
            
            # Dependency scanning
            dep_scanner = DependencyScanner(project_path)
            dep_vulns = await dep_scanner.scan_dependencies()
            scan_result.vulnerabilities.extend(dep_vulns)
            
            # Configuration scanning
            config_scanner = ConfigurationScanner(project_path)
            config_vulns = await config_scanner.scan_configuration()
            scan_result.vulnerabilities.extend(config_vulns)
            
            scan_result.is_completed = True
            scan_result.completed_at = datetime.utcnow()
            
            # Store results
            await self._store_scan_result(scan_result)
            
            # Log scan completion
            self.audit_logger.log_event(
                AuditEventType.ADMIN_ACTION,
                f"Security scan completed: {scan_id}",
                details={
                    "scan_id": scan_id,
                    "vulnerabilities_found": len(scan_result.vulnerabilities),
                    "duration_seconds": (scan_result.completed_at - scan_result.started_at).total_seconds()
                }
            )
            
            logger.info(f"Security scan {scan_id} completed with {len(scan_result.vulnerabilities)} vulnerabilities")
        
        except Exception as e:
            scan_result.error_message = str(e)
            logger.error(f"Security scan {scan_id} failed: {e}")
        
        return scan_result
    
    async def get_scan_result(self, scan_id: str) -> Optional[ScanResult]:
        """Get scan result by ID"""
        if scan_id in self.scan_results:
            return self.scan_results[scan_id]
        
        # Try to load from Redis
        return await self._load_scan_result(scan_id)
    
    async def get_vulnerability_summary(self) -> Dict[str, Any]:
        """Get summary of all vulnerabilities"""
        all_vulnerabilities = []
        
        for scan_result in self.scan_results.values():
            all_vulnerabilities.extend(scan_result.vulnerabilities)
        
        # Group by severity
        severity_counts = {severity: 0 for severity in VulnerabilitySeverity}
        type_counts = {vuln_type: 0 for vuln_type in VulnerabilityType}
        
        for vuln in all_vulnerabilities:
            severity_counts[vuln.severity] += 1
            type_counts[vuln.vulnerability_type] += 1
        
        return {
            "total_vulnerabilities": len(all_vulnerabilities),
            "by_severity": severity_counts,
            "by_type": type_counts,
            "fixed_count": len([v for v in all_vulnerabilities if v.is_fixed]),
            "false_positive_count": len([v for v in all_vulnerabilities if v.false_positive])
        }
    
    async def mark_vulnerability_fixed(self, vuln_id: str) -> bool:
        """Mark vulnerability as fixed"""
        for scan_result in self.scan_results.values():
            for vuln in scan_result.vulnerabilities:
                if vuln.vuln_id == vuln_id:
                    vuln.is_fixed = True
                    vuln.fixed_at = datetime.utcnow()
                    await self._store_scan_result(scan_result)
                    return True
        return False
    
    async def mark_vulnerability_false_positive(self, vuln_id: str) -> bool:
        """Mark vulnerability as false positive"""
        for scan_result in self.scan_results.values():
            for vuln in scan_result.vulnerabilities:
                if vuln.vuln_id == vuln_id:
                    vuln.false_positive = True
                    await self._store_scan_result(scan_result)
                    return True
        return False
    
    async def _store_scan_result(self, scan_result: ScanResult):
        """Store scan result in Redis"""
        try:
            scan_data = {
                "scan_id": scan_result.scan_id,
                "scan_type": scan_result.scan_type.value,
                "started_at": scan_result.started_at.isoformat(),
                "completed_at": scan_result.completed_at.isoformat() if scan_result.completed_at else None,
                "vulnerabilities": [v.to_dict() for v in scan_result.vulnerabilities],
                "metadata": scan_result.metadata,
                "is_completed": scan_result.is_completed,
                "error_message": scan_result.error_message
            }
            
            await self.redis_client.client.set(
                f"scan_result:{scan_result.scan_id}",
                json.dumps(scan_data, default=str),
                ex=86400 * 30  # Keep for 30 days
            )
        
        except Exception as e:
            logger.error(f"Error storing scan result: {e}")
    
    async def _load_scan_result(self, scan_id: str) -> Optional[ScanResult]:
        """Load scan result from Redis"""
        try:
            data = await self.redis_client.client.get(f"scan_result:{scan_id}")
            if not data:
                return None
            
            scan_data = json.loads(data)
            
            # Reconstruct vulnerabilities
            vulnerabilities = []
            for vuln_data in scan_data["vulnerabilities"]:
                vuln = Vulnerability(
                    vuln_id=vuln_data["vuln_id"],
                    title=vuln_data["title"],
                    description=vuln_data["description"],
                    severity=VulnerabilitySeverity(vuln_data["severity"]),
                    vulnerability_type=VulnerabilityType(vuln_data["vulnerability_type"]),
                    scan_type=ScanType(vuln_data["scan_type"]),
                    affected_component=vuln_data["affected_component"],
                    file_path=vuln_data.get("file_path"),
                    line_number=vuln_data.get("line_number"),
                    endpoint=vuln_data.get("endpoint"),
                    cve_id=vuln_data.get("cve_id"),
                    cvss_score=vuln_data.get("cvss_score"),
                    remediation=vuln_data.get("remediation"),
                    references=vuln_data.get("references", []),
                    discovered_at=datetime.fromisoformat(vuln_data["discovered_at"]),
                    is_fixed=vuln_data.get("is_fixed", False),
                    fixed_at=datetime.fromisoformat(vuln_data["fixed_at"]) if vuln_data.get("fixed_at") else None,
                    false_positive=vuln_data.get("false_positive", False)
                )
                vulnerabilities.append(vuln)
            
            scan_result = ScanResult(
                scan_id=scan_data["scan_id"],
                scan_type=ScanType(scan_data["scan_type"]),
                started_at=datetime.fromisoformat(scan_data["started_at"]),
                completed_at=datetime.fromisoformat(scan_data["completed_at"]) if scan_data.get("completed_at") else None,
                vulnerabilities=vulnerabilities,
                metadata=scan_data.get("metadata", {}),
                is_completed=scan_data.get("is_completed", False),
                error_message=scan_data.get("error_message")
            )
            
            self.scan_results[scan_id] = scan_result
            return scan_result
        
        except Exception as e:
            logger.error(f"Error loading scan result: {e}")
            return None


# Factory function
async def setup_vulnerability_scanner(redis_client: RedisClient, audit_logger: AuditLogger) -> VulnerabilityManager:
    """Setup vulnerability scanning system"""
    manager = VulnerabilityManager(redis_client, audit_logger)
    
    logger.info("Vulnerability scanner initialized")
    return manager


# FastAPI routes for vulnerability scanning
def create_vulnerability_routes(app: FastAPI, vulnerability_manager: VulnerabilityManager):
    """Add vulnerability scanning routes to FastAPI app"""
    
    @app.post("/security/scan")
    async def start_security_scan(project_path: str = "."):
        """Start comprehensive security scan"""
        scan_result = await vulnerability_manager.run_comprehensive_scan(
            app=app,
            project_path=project_path
        )
        return {
            "scan_id": scan_result.scan_id,
            "status": "completed" if scan_result.is_completed else "failed",
            "vulnerabilities_found": len(scan_result.vulnerabilities)
        }
    
    @app.get("/security/scan/{scan_id}")
    async def get_scan_result(scan_id: str):
        """Get scan result by ID"""
        scan_result = await vulnerability_manager.get_scan_result(scan_id)
        if not scan_result:
            raise HTTPException(status_code=404, detail="Scan not found")
        
        return {
            "scan_id": scan_result.scan_id,
            "scan_type": scan_result.scan_type.value,
            "started_at": scan_result.started_at.isoformat(),
            "completed_at": scan_result.completed_at.isoformat() if scan_result.completed_at else None,
            "is_completed": scan_result.is_completed,
            "error_message": scan_result.error_message,
            "vulnerabilities_count": len(scan_result.vulnerabilities),
            "vulnerabilities_by_severity": {
                severity.value: len(vulns) 
                for severity, vulns in scan_result.get_vulnerabilities_by_severity().items()
            }
        }
    
    @app.get("/security/vulnerabilities/summary")
    async def get_vulnerability_summary():
        """Get vulnerability summary"""
        return await vulnerability_manager.get_vulnerability_summary()
    
    @app.patch("/security/vulnerabilities/{vuln_id}/fixed")
    async def mark_vulnerability_fixed(vuln_id: str):
        """Mark vulnerability as fixed"""
        success = await vulnerability_manager.mark_vulnerability_fixed(vuln_id)
        if not success:
            raise HTTPException(status_code=404, detail="Vulnerability not found")
        return {"status": "marked_as_fixed"}
    
    @app.patch("/security/vulnerabilities/{vuln_id}/false-positive")
    async def mark_false_positive(vuln_id: str):
        """Mark vulnerability as false positive"""
        success = await vulnerability_manager.mark_vulnerability_false_positive(vuln_id)
        if not success:
            raise HTTPException(status_code=404, detail="Vulnerability not found")
        return {"status": "marked_as_false_positive"}