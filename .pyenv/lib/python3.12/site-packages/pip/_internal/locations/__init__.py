import functools
import logging
import os
import pathlib
import sys
import sysconfig
from typing import Any, Dict, Generator, Optional, Tuple

from pip._internal.models.scheme import SCHEME_KEYS, Scheme
from pip._internal.utils.compat import WINDOWS
from pip._internal.utils.deprecation import deprecated
from pip._internal.utils.virtualenv import running_under_virtualenv

from . import _sysconfig
from .base import (
    USER_CACHE_DIR,
    get_major_minor_version,
    get_src_prefix,
    is_osx_framework,
    site_packages,
    user_site,
)

__all__ = [
    "USER_CACHE_DIR",
    "get_bin_prefix",
    "get_bin_user",
    "get_major_minor_version",
    "get_platlib",
    "get_purelib",
    "get_scheme",
    "get_src_prefix",
    "site_packages",
    "user_site",
]


logger = logging.getLogger(__name__)


_PLATLIBDIR: str = getattr(sys, "platlibdir", "lib")

_USE_SYSCONFIG_DEFAULT = sys.version_info >= (3, 10)


def _should_use_sysconfig() -> bool:
    """
    Decide whether this runtime should use sysconfig for installation paths.
    
    Checks for an explicit override at `sysconfig._PIP_USE_SYSCONFIG` and falls back
    to the module-level default `_USE_SYSCONFIG_DEFAULT` (True on Python 3.10+).
    The result is intended to be stable for the duration of a single process;
    this function exists to make the decision testable.
    """
    return bool(getattr(sysconfig, "_PIP_USE_SYSCONFIG", _USE_SYSCONFIG_DEFAULT))


_USE_SYSCONFIG = _should_use_sysconfig()

if not _USE_SYSCONFIG:
    # Import distutils lazily to avoid deprecation warnings,
    # but import it soon enough that it is in memory and available during
    # a pip reinstall.
    from . import _distutils

# Be noisy about incompatibilities if this platforms "should" be using
# sysconfig, but is explicitly opting out and using distutils instead.
if _USE_SYSCONFIG_DEFAULT and not _USE_SYSCONFIG:
    _MISMATCH_LEVEL = logging.WARNING
else:
    _MISMATCH_LEVEL = logging.DEBUG


def _looks_like_bpo_44860() -> bool:
    """
    Detect whether the distutils `INSTALL_SCHEMES` indicates the bpo-44860 incorrect
    `unix_user` `platlib` value.
    
    Returns:
        bool: True if `INSTALL_SCHEMES["unix_user"]["platlib"]` equals `"$usersite"`,
        False if the key is missing or the value differs.
    
    See also:
        https://bugs.python.org/issue44860
    """
    from distutils.command.install import INSTALL_SCHEMES

    try:
        unix_user_platlib = INSTALL_SCHEMES["unix_user"]["platlib"]
    except KeyError:
        return False
    return unix_user_platlib == "$usersite"


def _looks_like_red_hat_patched_platlib_purelib(scheme: Dict[str, str]) -> bool:
    """
    Return True if the given install `scheme` looks like a Red Hat-style patch where platlib uses `/lib64/` while purelib uses `/lib/`.
    
    This examines the scheme's "platlib" and "purelib" entries. It normalizes a `$platlibdir` marker to the module's platform lib directory name, checks for a `/lib64/` path in platlib, and compares a transformed platlib (with `/lib64/` -> `/lib/` and `$platbase/` -> `$base/`) against purelib.
    
    Parameters:
        scheme (Dict[str, str]): Installation scheme mapping that must include the keys "platlib" and "purelib".
    
    Returns:
        bool: True if the scheme appears to have Red Hat's platlib/purelib patching; otherwise False.
    """
    platlib = scheme["platlib"]
    if "/$platlibdir/" in platlib:
        platlib = platlib.replace("/$platlibdir/", f"/{_PLATLIBDIR}/")
    if "/lib64/" not in platlib:
        return False
    unpatched = platlib.replace("/lib64/", "/lib/")
    return unpatched.replace("$platbase/", "$base/") == scheme["purelib"]


@functools.lru_cache(maxsize=None)
def _looks_like_red_hat_lib() -> bool:
    """
    Detect whether the interpreter appears to be a Red Hat–patched Python where platlib has been moved/adjusted relative to purelib.
    
    Checks that both the "unix_prefix" and "unix_home" install schemes exhibit the Red Hat-style platlib/purelib patching.
    
    Returns:
        bool: True if both relevant install schemes look like the Red Hat patch; False otherwise.
    """
    from distutils.command.install import INSTALL_SCHEMES

    return all(
        k in INSTALL_SCHEMES
        and _looks_like_red_hat_patched_platlib_purelib(INSTALL_SCHEMES[k])
        for k in ("unix_prefix", "unix_home")
    )


@functools.lru_cache(maxsize=None)
def _looks_like_debian_scheme() -> bool:
    """
    Return True if the distutils INSTALL_SCHEMES indicate a Debian-style layout.
    
    Checks for the presence of the Debian-specific scheme names "deb_system" and
    "unix_local" in distutils.command.install.INSTALL_SCHEMES.
    
    Returns:
        bool: True if both "deb_system" and "unix_local" are present, indicating a
        Debian or Debian-derived packaging scheme; otherwise False.
    """
    from distutils.command.install import INSTALL_SCHEMES

    return "deb_system" in INSTALL_SCHEMES and "unix_local" in INSTALL_SCHEMES


@functools.lru_cache(maxsize=None)
def _looks_like_red_hat_scheme() -> bool:
    """
    Return True if the system's distutils install command appears patched by Red Hat to append "/local" to prefix and exec_prefix.
    
    The detection instantiates a default distutils `install` command and finalizes its options; if both `prefix` and `exec_prefix` equal the normalized sys.prefix and sys.exec_prefix with "/local" appended, the function reports the Red Hat patch pattern.
    """
    from distutils.command.install import install
    from distutils.dist import Distribution

    cmd: Any = install(Distribution())
    cmd.finalize_options()
    return (
        cmd.exec_prefix == f"{os.path.normpath(sys.exec_prefix)}/local"
        and cmd.prefix == f"{os.path.normpath(sys.prefix)}/local"
    )


@functools.lru_cache(maxsize=None)
def _looks_like_slackware_scheme() -> bool:
    """
    Return True if the environment looks like Slackware’s patched installation scheme.
    
    Slackware modifies sysconfig's "posix_user" scheme to use a "lib64" directory for
    purelib but does not apply the same change to the site module. This function
    detects that discrepancy by comparing sysconfig's `posix_user` purelib path
    (with expansions disabled) against the configured `user_site`.
    
    Returns:
        bool: True when sysconfig's posix_user purelib contains "/lib64/" but the
        configured user_site does not; otherwise False.
    """
    if user_site is None:  # User-site not available.
        return False
    try:
        paths = sysconfig.get_paths(scheme="posix_user", expand=False)
    except KeyError:  # User-site not available.
        return False
    return "/lib64/" in paths["purelib"] and "/lib64/" not in user_site


@functools.lru_cache(maxsize=None)
def _looks_like_msys2_mingw_scheme() -> bool:
    """MSYS2 patches distutils and sysconfig to use a UNIX-like scheme.

    However, MSYS2 incorrectly patches sysconfig ``nt`` scheme. The fix is
    likely going to be included in their 3.10 release, so we ignore the warning.
    See msys2/MINGW-packages#9319.

    MSYS2 MINGW's patch uses lowercase ``"lib"`` instead of the usual uppercase,
    and is missing the final ``"site-packages"``.
    """
    paths = sysconfig.get_paths("nt", expand=False)
    return all(
        "Lib" not in p and "lib" in p and not p.endswith("site-packages")
        for p in (paths[key] for key in ("platlib", "purelib"))
    )


def _fix_abiflags(parts: Tuple[str]) -> Generator[str, None, None]:
    """
    Normalize path components when LDVERSION includes Python abiflags.
    
    If sysconfig.get_config_var("LDVERSION") ends with sys.abiflags, this generator yields each
    input component from `parts`, but with the trailing `sys.abiflags` removed from any component
    that ends with the full LDVERSION. If LDVERSION is not set, sys.abiflags is not present, or
    LDVERSION does not end with abiflags, yields the original components unchanged.
    
    Parameters:
        parts (Tuple[str]): Sequence of path components to normalize.
    
    Yields:
        str: Each normalized (or original) path component.
    """
    ldversion = sysconfig.get_config_var("LDVERSION")
    abiflags = getattr(sys, "abiflags", None)

    # LDVERSION does not end with sys.abiflags. Just return the path unchanged.
    if not ldversion or not abiflags or not ldversion.endswith(abiflags):
        yield from parts
        return

    # Strip sys.abiflags from LDVERSION-based path components.
    for part in parts:
        if part.endswith(ldversion):
            part = part[: (0 - len(abiflags))]
        yield part


@functools.lru_cache(maxsize=None)
def _warn_mismatched(old: pathlib.Path, new: pathlib.Path, *, key: str) -> None:
    """
    Log a formatted mismatch between two installation-path values.
    
    This emits a single log entry at the module's configured mismatch level containing:
    - a short context `key` identifying the mismatched field,
    - an issue URL for reporting,
    - the `old` (distutils) path and the `new` (sysconfig) path.
    
    Parameters:
        old (pathlib.Path): The value coming from distutils.
        new (pathlib.Path): The value coming from sysconfig.
        key (str): The scheme/key name that is mismatched (used in the log message).
    """
    issue_url = "https://github.com/pypa/pip/issues/10151"
    message = (
        "Value for %s does not match. Please report this to <%s>"
        "\ndistutils: %s"
        "\nsysconfig: %s"
    )
    logger.log(_MISMATCH_LEVEL, message, key, issue_url, old, new)


def _warn_if_mismatch(old: pathlib.Path, new: pathlib.Path, *, key: str) -> bool:
    """
    Return whether two path values differ, emitting a mismatch warning when they do.
    
    Compares `old` and `new` Path objects; if they are not equal calls `_warn_mismatched(old, new, key=key)` and returns True, otherwise returns False.
    
    Parameters:
        old (pathlib.Path): The original/expected path.
        new (pathlib.Path): The path to compare against `old`.
        key (str): Context key used when reporting the mismatch.
    
    Returns:
        bool: True if a mismatch was found (and a warning emitted), False if the paths are equal.
    """
    if old == new:
        return False
    _warn_mismatched(old, new, key=key)
    return True


@functools.lru_cache(maxsize=None)
def _log_context(
    *,
    user: bool = False,
    home: Optional[str] = None,
    root: Optional[str] = None,
    prefix: Optional[str] = None,
) -> None:
    """
    Log additional context values used when comparing installation schemes.
    
    This emits a single multi-line message at the configured mismatch log level containing the boolean `user`
    and the optional `home`, `root`, and `prefix` values. Intended to provide contextual information when
    warnings about path/scheme mismatches are reported.
    
    Parameters:
        user: Whether a per-user scheme was requested.
        home: The explicit `home` path passed to scheme resolution, or None.
        root: The explicit `root` path passed to scheme resolution, or None.
        prefix: The explicit `prefix` path passed to scheme resolution, or None.
    """
    parts = [
        "Additional context:",
        "user = %r",
        "home = %r",
        "root = %r",
        "prefix = %r",
    ]

    logger.log(_MISMATCH_LEVEL, "\n".join(parts), user, home, root, prefix)


def get_scheme(
    dist_name: str,
    user: bool = False,
    home: Optional[str] = None,
    root: Optional[str] = None,
    isolated: bool = False,
    prefix: Optional[str] = None,
) -> Scheme:
    """
    Return the installation scheme for a distribution name.
    
    If sysconfig integration is enabled for this process, the function returns the scheme computed by sysconfig. When sysconfig integration is disabled, it obtains the legacy distutils scheme, compares it to sysconfig's scheme to detect meaningful differences, and returns the distutils scheme while emitting warnings or a deprecation notice when appropriate.
    
    Parameters:
        dist_name: The distribution name used to compute scheme-specific paths (affects name-based locations).
        user: If True, return the per-user installation scheme (equivalent to passing user=True to sysconfig/distutils).
        home: Optional home directory to compute an alternate scheme (passed through to sysconfig/distutils).
        root: Optional root path used to compute a scheme that is rooted elsewhere (passed through).
        isolated: If True, compute an isolated scheme (ignore user/site configuration) when supported.
        prefix: Optional prefix to compute a prefixed installation scheme (passed through).
    
    Returns:
        A Scheme object describing installation directories (e.g., purelib, platlib, headers, scripts). The returned scheme will be the sysconfig scheme when sysconfig usage is enabled for this process; otherwise the legacy distutils scheme is returned (with warnings/deprecation messaging emitted when differences are detected).
    """
    new = _sysconfig.get_scheme(
        dist_name,
        user=user,
        home=home,
        root=root,
        isolated=isolated,
        prefix=prefix,
    )
    if _USE_SYSCONFIG:
        return new

    old = _distutils.get_scheme(
        dist_name,
        user=user,
        home=home,
        root=root,
        isolated=isolated,
        prefix=prefix,
    )

    warning_contexts = []
    for k in SCHEME_KEYS:
        old_v = pathlib.Path(getattr(old, k))
        new_v = pathlib.Path(getattr(new, k))

        if old_v == new_v:
            continue

        # distutils incorrectly put PyPy packages under ``site-packages/python``
        # in the ``posix_home`` scheme, but PyPy devs said they expect the
        # directory name to be ``pypy`` instead. So we treat this as a bug fix
        # and not warn about it. See bpo-43307 and python/cpython#24628.
        skip_pypy_special_case = (
            sys.implementation.name == "pypy"
            and home is not None
            and k in ("platlib", "purelib")
            and old_v.parent == new_v.parent
            and old_v.name.startswith("python")
            and new_v.name.startswith("pypy")
        )
        if skip_pypy_special_case:
            continue

        # sysconfig's ``osx_framework_user`` does not include ``pythonX.Y`` in
        # the ``include`` value, but distutils's ``headers`` does. We'll let
        # CPython decide whether this is a bug or feature. See bpo-43948.
        skip_osx_framework_user_special_case = (
            user
            and is_osx_framework()
            and k == "headers"
            and old_v.parent.parent == new_v.parent
            and old_v.parent.name.startswith("python")
        )
        if skip_osx_framework_user_special_case:
            continue

        # On Red Hat and derived Linux distributions, distutils is patched to
        # use "lib64" instead of "lib" for platlib.
        if k == "platlib" and _looks_like_red_hat_lib():
            continue

        # On Python 3.9+, sysconfig's posix_user scheme sets platlib against
        # sys.platlibdir, but distutils's unix_user incorrectly coninutes
        # using the same $usersite for both platlib and purelib. This creates a
        # mismatch when sys.platlibdir is not "lib".
        skip_bpo_44860 = (
            user
            and k == "platlib"
            and not WINDOWS
            and sys.version_info >= (3, 9)
            and _PLATLIBDIR != "lib"
            and _looks_like_bpo_44860()
        )
        if skip_bpo_44860:
            continue

        # Slackware incorrectly patches posix_user to use lib64 instead of lib,
        # but not usersite to match the location.
        skip_slackware_user_scheme = (
            user
            and k in ("platlib", "purelib")
            and not WINDOWS
            and _looks_like_slackware_scheme()
        )
        if skip_slackware_user_scheme:
            continue

        # Both Debian and Red Hat patch Python to place the system site under
        # /usr/local instead of /usr. Debian also places lib in dist-packages
        # instead of site-packages, but the /usr/local check should cover it.
        skip_linux_system_special_case = (
            not (user or home or prefix or running_under_virtualenv())
            and old_v.parts[1:3] == ("usr", "local")
            and len(new_v.parts) > 1
            and new_v.parts[1] == "usr"
            and (len(new_v.parts) < 3 or new_v.parts[2] != "local")
            and (_looks_like_red_hat_scheme() or _looks_like_debian_scheme())
        )
        if skip_linux_system_special_case:
            continue

        # On Python 3.7 and earlier, sysconfig does not include sys.abiflags in
        # the "pythonX.Y" part of the path, but distutils does.
        skip_sysconfig_abiflag_bug = (
            sys.version_info < (3, 8)
            and not WINDOWS
            and k in ("headers", "platlib", "purelib")
            and tuple(_fix_abiflags(old_v.parts)) == new_v.parts
        )
        if skip_sysconfig_abiflag_bug:
            continue

        # MSYS2 MINGW's sysconfig patch does not include the "site-packages"
        # part of the path. This is incorrect and will be fixed in MSYS.
        skip_msys2_mingw_bug = (
            WINDOWS and k in ("platlib", "purelib") and _looks_like_msys2_mingw_scheme()
        )
        if skip_msys2_mingw_bug:
            continue

        # CPython's POSIX install script invokes pip (via ensurepip) against the
        # interpreter located in the source tree, not the install site. This
        # triggers special logic in sysconfig that's not present in distutils.
        # https://github.com/python/cpython/blob/8c21941ddaf/Lib/sysconfig.py#L178-L194
        skip_cpython_build = (
            sysconfig.is_python_build(check_home=True)
            and not WINDOWS
            and k in ("headers", "include", "platinclude")
        )
        if skip_cpython_build:
            continue

        warning_contexts.append((old_v, new_v, f"scheme.{k}"))

    if not warning_contexts:
        return old

    # Check if this path mismatch is caused by distutils config files. Those
    # files will no longer work once we switch to sysconfig, so this raises a
    # deprecation message for them.
    default_old = _distutils.distutils_scheme(
        dist_name,
        user,
        home,
        root,
        isolated,
        prefix,
        ignore_config_files=True,
    )
    if any(default_old[k] != getattr(old, k) for k in SCHEME_KEYS):
        deprecated(
            reason=(
                "Configuring installation scheme with distutils config files "
                "is deprecated and will no longer work in the near future. If you "
                "are using a Homebrew or Linuxbrew Python, please see discussion "
                "at https://github.com/Homebrew/homebrew-core/issues/76621"
            ),
            replacement=None,
            gone_in=None,
        )
        return old

    # Post warnings about this mismatch so user can report them back.
    for old_v, new_v, key in warning_contexts:
        _warn_mismatched(old_v, new_v, key=key)
    _log_context(user=user, home=home, root=root, prefix=prefix)

    return old


def get_bin_prefix() -> str:
    """
    Return the system scripts (bin) prefix path.
    
    When sysconfig is enabled, returns the value from sysconfig. Otherwise falls back to distutils' bin prefix, emitting a warning and additional context if the two prefixes differ.
    
    Returns:
        str: The bin prefix path to use.
    """
    new = _sysconfig.get_bin_prefix()
    if _USE_SYSCONFIG:
        return new

    old = _distutils.get_bin_prefix()
    if _warn_if_mismatch(pathlib.Path(old), pathlib.Path(new), key="bin_prefix"):
        _log_context()
    return old


def get_bin_user() -> str:
    """
    Return the user-level scripts directory (the "scripts" path from the user installation scheme).
    
    Returns:
        str: Path to the per-user scripts directory (e.g., "~/.local/bin" on Unix).
    """
    return _sysconfig.get_scheme("", user=True).scripts


def _looks_like_deb_system_dist_packages(value: str) -> bool:
    """
    Return True if the given path matches Debian's APT-controlled dist-packages location.
    
    Checks that the runtime looks like a Debian-style installation (via
    _install schemes detection_) and that `value` is exactly "/usr/lib/python3/dist-packages".
    This is used to avoid spurious warnings when distutils reports the Debian
    APT-managed default package directory which sysconfig does not mirror.
    
    Parameters:
        value (str): Filesystem path to test.
    
    Returns:
        bool: True when `value` is the Debian dist-packages path in a Debian-like scheme.
    """
    if not _looks_like_debian_scheme():
        return False
    if value == "/usr/lib/python3/dist-packages":
        return True
    return False


def get_purelib() -> str:
    """Return the default pure-Python lib location."""
    new = _sysconfig.get_purelib()
    if _USE_SYSCONFIG:
        return new

    old = _distutils.get_purelib()
    if _looks_like_deb_system_dist_packages(old):
        return old
    if _warn_if_mismatch(pathlib.Path(old), pathlib.Path(new), key="purelib"):
        _log_context()
    return old


def get_platlib() -> str:
    """
    Return the platform-specific site-packages directory path.
    
    Uses sysconfig.get_platlib() when sysconfig is enabled; otherwise falls back to distutils.get_platlib().
    If the distutils value appears to be Debian's system "dist-packages", that value is returned without comparison.
    When falling back to distutils and a mismatch with sysconfig is detected, a warning may be emitted and the distutils value is returned.
    
    Returns:
        str: Filesystem path to the platform-specific library directory.
    """
    new = _sysconfig.get_platlib()
    if _USE_SYSCONFIG:
        return new

    from . import _distutils

    old = _distutils.get_platlib()
    if _looks_like_deb_system_dist_packages(old):
        return old
    if _warn_if_mismatch(pathlib.Path(old), pathlib.Path(new), key="platlib"):
        _log_context()
    return old
