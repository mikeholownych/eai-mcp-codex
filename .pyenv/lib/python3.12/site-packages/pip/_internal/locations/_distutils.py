"""Locations where we look for configs, install stuff, etc"""

# The following comment should be removed at some point in the future.
# mypy: strict-optional=False

# If pip's going to use distutils, it should not be using the copy that setuptools
# might have injected into the environment. This is done by removing the injected
# shim, if it's injected.
#
# See https://github.com/pypa/pip/issues/8761 for the original discussion and
# rationale for why this is done within pip.
try:
    __import__("_distutils_hack").remove_shim()
except (ImportError, AttributeError):
    pass

import logging
import os
import sys
from distutils.cmd import Command as DistutilsCommand
from distutils.command.install import SCHEME_KEYS
from distutils.command.install import install as distutils_install_command
from distutils.sysconfig import get_python_lib
from typing import Dict, List, Optional, Union, cast

from pip._internal.models.scheme import Scheme
from pip._internal.utils.compat import WINDOWS
from pip._internal.utils.virtualenv import running_under_virtualenv

from .base import get_major_minor_version

logger = logging.getLogger(__name__)


def distutils_scheme(
    dist_name: str,
    user: bool = False,
    home: Optional[str] = None,
    root: Optional[str] = None,
    isolated: bool = False,
    prefix: Optional[str] = None,
    *,
    ignore_config_files: bool = False,
) -> Dict[str, str]:
    """
    Return a distutils installation scheme for a distribution name.
    
    Builds a mapping of distutils installation locations (keys from SCHEME_KEYS,
    e.g., "purelib", "platlib", "headers", "scripts", "data") for installing
    the package named by `dist_name`, honoring the provided installation
    options (user, home, prefix, root, isolated). The returned dict contains
    absolute paths as computed by distutils after finalizing install options.
    
    Notes and important behaviors:
    - If `ignore_config_files` is False, distutils config files are parsed; a
      UnicodeDecodeError during parsing is caught and a warning is emitted
      listing the offending config filenames.
    - finalize_options() is called on the distutils install command; setting
      `user` or `home` can have the side effect of creating the user base or
      home directories (this is performed by distutils).
    - If `install_lib` is explicitly set in distutils config, it overrides
      both `purelib` and `platlib` so all library files go into that path.
    - When running inside a virtual environment, the function computes a
      headers path under the environment's include/site/pythonX.Y/<dist_name>
      and, if `root` is provided, rewrites that headers path to be rooted
      under `root`.
    - The function asserts that conflicting option combinations are not used:
      `user` and `prefix` cannot both be set; `home` and `prefix` cannot both
      be set.
    
    Parameters:
    - dist_name: package distribution name used to build distribution/install
      paths.
    - user, home, root, isolated, prefix, ignore_config_files: control how the
      install command finalizes options; their names map directly to standard
      distutils install semantics.
    
    Returns:
    A dict mapping scheme keys to computed file-system paths (str).
    """
    from distutils.dist import Distribution

    dist_args: Dict[str, Union[str, List[str]]] = {"name": dist_name}
    if isolated:
        dist_args["script_args"] = ["--no-user-cfg"]

    d = Distribution(dist_args)
    if not ignore_config_files:
        try:
            d.parse_config_files()
        except UnicodeDecodeError:
            paths = d.find_config_files()
            logger.warning(
                "Ignore distutils configs in %s due to encoding errors.",
                ", ".join(os.path.basename(p) for p in paths),
            )
    obj: Optional[DistutilsCommand] = None
    obj = d.get_command_obj("install", create=True)
    assert obj is not None
    i = cast(distutils_install_command, obj)
    # NOTE: setting user or home has the side-effect of creating the home dir
    # or user base for installations during finalize_options()
    # ideally, we'd prefer a scheme class that has no side-effects.
    assert not (user and prefix), f"user={user} prefix={prefix}"
    assert not (home and prefix), f"home={home} prefix={prefix}"
    i.user = user or i.user
    if user or home:
        i.prefix = ""
    i.prefix = prefix or i.prefix
    i.home = home or i.home
    i.root = root or i.root
    i.finalize_options()

    scheme = {}
    for key in SCHEME_KEYS:
        scheme[key] = getattr(i, "install_" + key)

    # install_lib specified in setup.cfg should install *everything*
    # into there (i.e. it takes precedence over both purelib and
    # platlib).  Note, i.install_lib is *always* set after
    # finalize_options(); we only want to override here if the user
    # has explicitly requested it hence going back to the config
    if "install_lib" in d.get_option_dict("install"):
        scheme.update({"purelib": i.install_lib, "platlib": i.install_lib})

    if running_under_virtualenv():
        if home:
            prefix = home
        elif user:
            prefix = i.install_userbase
        else:
            prefix = i.prefix
        scheme["headers"] = os.path.join(
            prefix,
            "include",
            "site",
            f"python{get_major_minor_version()}",
            dist_name,
        )

        if root is not None:
            path_no_drive = os.path.splitdrive(os.path.abspath(scheme["headers"]))[1]
            scheme["headers"] = os.path.join(root, path_no_drive[1:])

    return scheme


def get_scheme(
    dist_name: str,
    user: bool = False,
    home: Optional[str] = None,
    root: Optional[str] = None,
    isolated: bool = False,
    prefix: Optional[str] = None,
) -> Scheme:
    """
    Return a Scheme representing installation paths for the given distribution name and options.
    
    Builds the scheme by delegating to distutils_scheme(...) and mapping its keys into a Scheme
    dataclass (platlib, purelib, headers, scripts, data).
    
    Parameters:
        dist_name: package name; used when constructing the headers path.
        user: use the per-user installation scheme.
        home: base directory for a "home" installation.
        root: path under which computed directories are re-rooted.
        isolated: if True, ignore user-level distutils configuration files.
        prefix: base directory for a "prefix" installation.
    """
    scheme = distutils_scheme(dist_name, user, home, root, isolated, prefix)
    return Scheme(
        platlib=scheme["platlib"],
        purelib=scheme["purelib"],
        headers=scheme["headers"],
        scripts=scheme["scripts"],
        data=scheme["data"],
    )


def get_bin_prefix() -> str:
    # XXX: In old virtualenv versions, sys.prefix can contain '..' components,
    # so we need to call normpath to eliminate them.
    """
    Return the filesystem prefix where executables (scripts) should be installed for the current Python environment.
    
    The result is based on a normalized sys.prefix with platform-specific rules:
    - On Windows, prefer "<prefix>/Scripts" and fall back to "<prefix>/bin" if "Scripts" does not exist.
    - On macOS when running a framework/system Python with a prefix beginning "/System/Library/", return "/usr/local/bin".
    - Otherwise return "<normalized-prefix>/bin".
    
    Returns:
        str: Path to the appropriate "bin" (or "Scripts") directory for installing executables.
    """
    prefix = os.path.normpath(sys.prefix)
    if WINDOWS:
        bin_py = os.path.join(prefix, "Scripts")
        # buildout uses 'bin' on Windows too?
        if not os.path.exists(bin_py):
            bin_py = os.path.join(prefix, "bin")
        return bin_py
    # Forcing to use /usr/local/bin for standard macOS framework installs
    # Also log to ~/Library/Logs/ for use with the Console.app log viewer
    if sys.platform[:6] == "darwin" and prefix[:16] == "/System/Library/":
        return "/usr/local/bin"
    return os.path.join(prefix, "bin")


def get_purelib() -> str:
    """
    Return the site-packages directory for pure (non-platform-specific) Python packages.
    
    Returns:
        str: Filesystem path to the installation's purelib (site-packages) directory.
    """
    return get_python_lib(plat_specific=False)


def get_platlib() -> str:
    """
    Return the platform-specific site-packages directory for the current Python environment.
    
    This is the location where platform-specific (compiled/extension) modules are installed.
    Returns:
        str: Absolute path to the platlib (site-packages) directory.
    """
    return get_python_lib(plat_specific=True)
