import logging
import os
import sys
import sysconfig
import typing

from pip._internal.exceptions import InvalidSchemeCombination, UserInstallationInvalid
from pip._internal.models.scheme import SCHEME_KEYS, Scheme
from pip._internal.utils.virtualenv import running_under_virtualenv

from .base import change_root, get_major_minor_version, is_osx_framework

logger = logging.getLogger(__name__)


# Notes on _infer_* functions.
# Unfortunately ``get_default_scheme()`` didn't exist before 3.10, so there's no
# way to ask things like "what is the '_prefix' scheme on this platform". These
# functions try to answer that with some heuristics while accounting for ad-hoc
# platforms not covered by CPython's default sysconfig implementation. If the
# ad-hoc implementation does not fully implement sysconfig, we'll fall back to
# a POSIX scheme.

_AVAILABLE_SCHEMES = set(sysconfig.get_scheme_names())

_PREFERRED_SCHEME_API = getattr(sysconfig, "get_preferred_scheme", None)


def _should_use_osx_framework_prefix() -> bool:
    """
    Return True if the "osx_framework_library" sysconfig scheme should be used.
    
    True when the "osx_framework_library" scheme is available, the interpreter is an Apple
    framework build, and the process is not running inside a virtual environment.
    
    Returns:
        bool: whether the osx framework prefix scheme applies.
    """
    return (
        "osx_framework_library" in _AVAILABLE_SCHEMES
        and not running_under_virtualenv()
        and is_osx_framework()
    )


def _infer_prefix() -> str:
    """Try to find a prefix scheme for the current platform.

    This tries:

    * A special ``osx_framework_library`` for Python distributed by Apple's
      Command Line Tools, when not running in a virtual environment.
    * Implementation + OS, used by PyPy on Windows (``pypy_nt``).
    * Implementation without OS, used by PyPy on POSIX (``pypy``).
    * OS + "prefix", used by CPython on POSIX (``posix_prefix``).
    * Just the OS name, used by CPython on Windows (``nt``).

    If none of the above works, fall back to ``posix_prefix``.
    """
    if _PREFERRED_SCHEME_API:
        return _PREFERRED_SCHEME_API("prefix")
    if _should_use_osx_framework_prefix():
        return "osx_framework_library"
    implementation_suffixed = f"{sys.implementation.name}_{os.name}"
    if implementation_suffixed in _AVAILABLE_SCHEMES:
        return implementation_suffixed
    if sys.implementation.name in _AVAILABLE_SCHEMES:
        return sys.implementation.name
    suffixed = f"{os.name}_prefix"
    if suffixed in _AVAILABLE_SCHEMES:
        return suffixed
    if os.name in _AVAILABLE_SCHEMES:  # On Windows, prefx is just called "nt".
        return os.name
    return "posix_prefix"


def _infer_user() -> str:
    """
    Return the name of the user installation scheme appropriate for the current platform.
    
    If sysconfig provides a preferred-scheme API, its "user" result is returned. On macOS framework builds outside a virtualenv, prefers "osx_framework_user"; otherwise prefers a scheme named "<os.name>_user" when available. If neither is available but "posix_user" exists, returns "posix_user". Raises UserInstallationInvalid if no user scheme can be determined.
    """
    if _PREFERRED_SCHEME_API:
        return _PREFERRED_SCHEME_API("user")
    if is_osx_framework() and not running_under_virtualenv():
        suffixed = "osx_framework_user"
    else:
        suffixed = f"{os.name}_user"
    if suffixed in _AVAILABLE_SCHEMES:
        return suffixed
    if "posix_user" not in _AVAILABLE_SCHEMES:  # User scheme unavailable.
        raise UserInstallationInvalid()
    return "posix_user"


def _infer_home() -> str:
    """
    Return the name of the "home" installation scheme for the current platform.
    
    Uses sysconfig.get_preferred_scheme("home") if available; otherwise prefers
    the scheme named "<os.name>_home" when present in available schemes, falling
    back to "posix_home".
    """
    if _PREFERRED_SCHEME_API:
        return _PREFERRED_SCHEME_API("home")
    suffixed = f"{os.name}_home"
    if suffixed in _AVAILABLE_SCHEMES:
        return suffixed
    return "posix_home"


# Update these keys if the user sets a custom home.
_HOME_KEYS = [
    "installed_base",
    "base",
    "installed_platbase",
    "platbase",
    "prefix",
    "exec_prefix",
]
if sysconfig.get_config_var("userbase") is not None:
    _HOME_KEYS.append("userbase")


def get_scheme(
    dist_name: str,
    user: bool = False,
    home: typing.Optional[str] = None,
    root: typing.Optional[str] = None,
    isolated: bool = False,
    prefix: typing.Optional[str] = None,
) -> Scheme:
    """
    Return a Scheme describing installation paths for a distribution given the requested
    installation context.
    
    Determines the appropriate sysconfig scheme (prefix/user/home) and builds a Scheme
    with platlib, purelib, headers, scripts, and data paths. Applies these special
    behaviors:
    - Raises InvalidSchemeCombination if both --user and --prefix, or --home and --prefix,
      are requested.
    - If installing into a custom prefix and the chosen scheme is "osx_framework_library",
      the scheme is changed to "posix_prefix".
    - In virtual environments, the headers path is set to "<base>/include/site/pythonXY".
    - If not in a virtual environment and dist_name is falsey, headers use "UNKNOWN" as
      the distribution directory name.
    - If `root` is provided, all scheme paths are rebased with change_root(root, path).
    
    Parameters:
        dist_name (str): Distribution name used to form the headers directory.
        user (bool): If True, use the per-user scheme.
        home (Optional[str]): If set, use the home-based scheme and treat the given
            value as the home directory for keys in _HOME_KEYS.
        root (Optional[str]): If set, rebase all returned paths under this root.
        isolated (bool): Ignored; present for compatibility with distutils APIs.
        prefix (Optional[str]): If set, use the prefix-based scheme and treat the given
            value as the base for keys in _HOME_KEYS.
    
    Returns:
        Scheme: A Scheme object with platlib, purelib, headers, scripts, and data paths.
    """
    if user and prefix:
        raise InvalidSchemeCombination("--user", "--prefix")
    if home and prefix:
        raise InvalidSchemeCombination("--home", "--prefix")

    if home is not None:
        scheme_name = _infer_home()
    elif user:
        scheme_name = _infer_user()
    else:
        scheme_name = _infer_prefix()

    # Special case: When installing into a custom prefix, use posix_prefix
    # instead of osx_framework_library. See _should_use_osx_framework_prefix()
    # docstring for details.
    if prefix is not None and scheme_name == "osx_framework_library":
        scheme_name = "posix_prefix"

    if home is not None:
        variables = {k: home for k in _HOME_KEYS}
    elif prefix is not None:
        variables = {k: prefix for k in _HOME_KEYS}
    else:
        variables = {}

    paths = sysconfig.get_paths(scheme=scheme_name, vars=variables)

    # Logic here is very arbitrary, we're doing it for compatibility, don't ask.
    # 1. Pip historically uses a special header path in virtual environments.
    # 2. If the distribution name is not known, distutils uses 'UNKNOWN'. We
    #    only do the same when not running in a virtual environment because
    #    pip's historical header path logic (see point 1) did not do this.
    if running_under_virtualenv():
        if user:
            base = variables.get("userbase", sys.prefix)
        else:
            base = variables.get("base", sys.prefix)
        python_xy = f"python{get_major_minor_version()}"
        paths["include"] = os.path.join(base, "include", "site", python_xy)
    elif not dist_name:
        dist_name = "UNKNOWN"

    scheme = Scheme(
        platlib=paths["platlib"],
        purelib=paths["purelib"],
        headers=os.path.join(paths["include"], dist_name),
        scripts=paths["scripts"],
        data=paths["data"],
    )
    if root is not None:
        for key in SCHEME_KEYS:
            value = change_root(root, getattr(scheme, key))
            setattr(scheme, key, value)
    return scheme


def get_bin_prefix() -> str:
    # Forcing to use /usr/local/bin for standard macOS framework installs.
    """
    Return the system scripts directory path used for installing executable scripts.
    
    On standard macOS framework Python installs (when running on Darwin and sys.prefix
    is under /System/Library/), this returns "/usr/local/bin". Otherwise it returns
    the "scripts" path from CPython's sysconfig.
        
    Returns:
        str: filesystem path to the scripts (bin) directory.
    """
    if sys.platform[:6] == "darwin" and sys.prefix[:16] == "/System/Library/":
        return "/usr/local/bin"
    return sysconfig.get_paths()["scripts"]


def get_purelib() -> str:
    """
    Return the interpreter's "purelib" installation directory as reported by
    sysconfig.get_paths().
    
    This is the location for pure-Python library packages for the current
    Python installation/environment.
    """
    return sysconfig.get_paths()["purelib"]


def get_platlib() -> str:
    """
    Return the platform-specific library directory for the current Python installation.
    
    This returns the `platlib` path from `sysconfig.get_paths()` â€” the directory for
    platform-dependent (compiled) Python packages for the active interpreter.
    """
    return sysconfig.get_paths()["platlib"]
