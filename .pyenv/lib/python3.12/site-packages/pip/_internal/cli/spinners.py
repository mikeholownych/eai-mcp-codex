import contextlib
import itertools
import logging
import sys
import time
from typing import IO, Generator, Optional

from pip._internal.utils.compat import WINDOWS
from pip._internal.utils.logging import get_indentation

logger = logging.getLogger(__name__)


class SpinnerInterface:
    def spin(self) -> None:
        """
        Advance or emit a progress update for the spinner.
        
        Called repeatedly by the caller to animate or report ongoing work. Implementations should make a single, short-lived update (or no-op) when the spinner has been finished and should not block.
        """
        raise NotImplementedError()

    def finish(self, final_status: str) -> None:
        """
        Finalize the spinner with a terminal status.
        
        Implementations should render or record the provided `final_status` (for example, printing it to the output or logging it), ensure any ongoing animation or periodic updates stop, and mark the spinner as finished so further `spin()` calls have no effect.
        
        Parameters:
            final_status (str): Short final status text (e.g., "done", "error", "canceled").
        """
        raise NotImplementedError()


class InteractiveSpinner(SpinnerInterface):
    def __init__(
        self,
        message: str,
        file: Optional[IO[str]] = None,
        spin_chars: str = "-\\|/",
        # Empirically, 8 updates/second looks nice
        min_update_interval_seconds: float = 0.125,
    ):
        """
        Create an InteractiveSpinner that animates a rotating status next to `message`.
        
        Parameters:
            message (str): Text to display before the animated spinner.
            file (IO[str], optional): Output stream to write the spinner to. Defaults to sys.stdout.
            spin_chars (str): Sequence of characters used for the spinner cycle (defaults to "-\|/").
            min_update_interval_seconds (float): Minimum seconds between visible updates; throttles animation frequency.
        
        Side effects:
            Writes the initial message and trailing " ... " to the chosen output file and prepares internal state for updates.
        """
        self._message = message
        if file is None:
            file = sys.stdout
        self._file = file
        self._rate_limiter = RateLimiter(min_update_interval_seconds)
        self._finished = False

        self._spin_cycle = itertools.cycle(spin_chars)

        self._file.write(" " * get_indentation() + self._message + " ... ")
        self._width = 0

    def _write(self, status: str) -> None:
        """
        Overwrite the previous inline status with `status` on the spinner's output.
        
        Writes backspaces and spaces to erase the previously written status, writes
        `status` in its place, flushes the output file, updates the stored width, and
        resets the rate limiter so the next update interval is measured from now.
        
        Parameters:
            status: The status text to display (e.g., a spinner character or final status).
        
        Notes:
            Asserts that the spinner has not been finished; an AssertionError will occur
            if called after finish().
        """
        assert not self._finished
        # Erase what we wrote before by backspacing to the beginning, writing
        # spaces to overwrite the old text, and then backspacing again
        backup = "\b" * self._width
        self._file.write(backup + " " * self._width + backup)
        # Now we have a blank slate to add our status
        self._file.write(status)
        self._width = len(status)
        self._file.flush()
        self._rate_limiter.reset()

    def spin(self) -> None:
        """
        Advance the spinner by one frame if allowed.
        
        If the spinner is still active and the rate limiter permits an update, write the next spinner character to the output. Otherwise do nothing.
        """
        if self._finished:
            return
        if not self._rate_limiter.ready():
            return
        self._write(next(self._spin_cycle))

    def finish(self, final_status: str) -> None:
        """
        Finish the spinner by writing a final status, newline, and marking it finished.
        
        If the spinner is already finished this is a no-op. Otherwise the function overwrites the current in-line status with `final_status`, writes a newline, flushes the output file, and marks the spinner finished.
        
        Parameters:
            final_status (str): Final status text to display in place of the spinner.
        """
        if self._finished:
            return
        self._write(final_status)
        self._file.write("\n")
        self._file.flush()
        self._finished = True


# Used for dumb terminals, non-interactive installs (no tty), etc.
# We still print updates occasionally (once every 60 seconds by default) to
# act as a keep-alive for systems like Travis-CI that take lack-of-output as
# an indication that a task has frozen.
class NonInteractiveSpinner(SpinnerInterface):
    def __init__(self, message: str, min_update_interval_seconds: float = 60.0) -> None:
        """
        Initialize a NonInteractiveSpinner that logs periodic status updates instead of writing to a TTY.
        
        Parameters:
            message (str): The base message to include with each logged status.
            min_update_interval_seconds (float): Minimum seconds between logged updates (default 60.0).
        
        Notes:
            - Marks the spinner as not finished and creates an internal RateLimiter.
            - Immediately logs an initial "started" status.
        """
        self._message = message
        self._finished = False
        self._rate_limiter = RateLimiter(min_update_interval_seconds)
        self._update("started")

    def _update(self, status: str) -> None:
        """
        Log an intermediate status message for a non-interactive spinner.
        
        This internal helper asserts the spinner is not finished, resets the rate limiter, and logs
        the spinner's message together with the provided status at INFO level.
        
        Parameters:
            status (str): Short status text describing the spinner's current state.
        """
        assert not self._finished
        self._rate_limiter.reset()
        logger.info("%s: %s", self._message, status)

    def spin(self) -> None:
        """
        Emit a periodic "still running..." status via the logger when updates are allowed.
        
        Does nothing if the spinner has already been finished or if the rate limiter indicates
        that it's not time for another update. When allowed, logs a "still running..." message
        by delegating to the internal _update method.
        """
        if self._finished:
            return
        if not self._rate_limiter.ready():
            return
        self._update("still running...")

    def finish(self, final_status: str) -> None:
        """
        Mark the spinner finished and log the final status.
        
        If the spinner is not already finished, logs "finished with status '<final_status>'" at INFO level
        (via the spinner's logging mechanism) and prevents further updates. This method is idempotent;
        calling it multiple times has no effect after the first call.
        
        Parameters:
            final_status (str): Short label describing the final outcome (e.g., "done", "error", "canceled").
        """
        if self._finished:
            return
        self._update(f"finished with status '{final_status}'")
        self._finished = True


class RateLimiter:
    def __init__(self, min_update_interval_seconds: float) -> None:
        """
        Initialize the rate limiter.
        
        Parameters:
            min_update_interval_seconds (float): Minimum number of seconds required between successive allowed updates. A non-negative value; the internal clock starts with `_last_update` set to 0 so the first `ready()` call will be allowed unless the system clock is near-zero.
        """
        self._min_update_interval_seconds = min_update_interval_seconds
        self._last_update: float = 0

    def ready(self) -> bool:
        """
        Return whether the minimum interval has elapsed since the last update.
        
        Returns:
            bool: True if the elapsed time since the last reset is at least the configured
            minimum update interval; otherwise False.
        """
        now = time.time()
        delta = now - self._last_update
        return delta >= self._min_update_interval_seconds

    def reset(self) -> None:
        """
        Mark the limiter as having just performed an update.
        
        Sets the internal timestamp to the current time so subsequent calls to `ready()`
        will only return True after the configured minimum interval has elapsed.
        """
        self._last_update = time.time()


@contextlib.contextmanager
def open_spinner(message: str) -> Generator[SpinnerInterface, None, None]:
    # Interactive spinner goes directly to sys.stdout rather than being routed
    # through the logging system, but it acts like it has level INFO,
    # i.e. it's only displayed if we're at level INFO or better.
    # Non-interactive spinner goes through the logging system, so it is always
    # in sync with logging configuration.
    """
    Context manager that yields a SpinnerInterface for reporting progress and ensures it is finished.
    
    The function selects an InteractiveSpinner when stdout is a TTY and the global logger level is INFO or lower; otherwise it selects a NonInteractiveSpinner. The spinner is used inside a hidden-cursor context when appropriate.
    
    On normal exit the spinner is finished with the status "done". If a KeyboardInterrupt is raised, the spinner is finished with "canceled" before re-raising. If any other exception is raised, the spinner is finished with "error" before re-raising.
    
    Parameters:
        message (str): The message passed to the spinner (displayed or logged depending on spinner type).
    
    Yields:
        SpinnerInterface: The selected spinner instance.
    """
    if sys.stdout.isatty() and logger.getEffectiveLevel() <= logging.INFO:
        spinner: SpinnerInterface = InteractiveSpinner(message)
    else:
        spinner = NonInteractiveSpinner(message)
    try:
        with hidden_cursor(sys.stdout):
            yield spinner
    except KeyboardInterrupt:
        spinner.finish("canceled")
        raise
    except Exception:
        spinner.finish("error")
        raise
    else:
        spinner.finish("done")


HIDE_CURSOR = "\x1b[?25l"
SHOW_CURSOR = "\x1b[?25h"


@contextlib.contextmanager
def hidden_cursor(file: IO[str]) -> Generator[None, None, None]:
    # The Windows terminal does not support the hide/show cursor ANSI codes,
    # even via colorama. So don't even try.
    """
    Context manager that hides the terminal cursor while inside the context when supported.
    
    If running on Windows, or if `file` is not a TTY, or the logger level is above INFO (quiet mode),
    this is a no-op and yields without emitting control sequences. Otherwise it writes the `HIDE_CURSOR`
    ANSI sequence to `file` on entry and ensures the `SHOW_CURSOR` sequence is written on exit.
    """
    if WINDOWS:
        yield
    # We don't want to clutter the output with control characters if we're
    # writing to a file, or if the user is running with --quiet.
    # See https://github.com/pypa/pip/issues/3418
    elif not file.isatty() or logger.getEffectiveLevel() > logging.INFO:
        yield
    else:
        file.write(HIDE_CURSOR)
        try:
            yield
        finally:
            file.write(SHOW_CURSOR)
