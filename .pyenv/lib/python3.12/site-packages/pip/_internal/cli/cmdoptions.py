"""
shared options and groups

The principle here is to define options once, but *not* instantiate them
globally. One reason being that options with action='append' can carry state
between parses. pip parses general options twice internally, and shouldn't
pass on state. To be consistent, all options will follow this design.
"""

# The following comment should be removed at some point in the future.
# mypy: strict-optional=False

import importlib.util
import logging
import os
import textwrap
from functools import partial
from optparse import SUPPRESS_HELP, Option, OptionGroup, OptionParser, Values
from textwrap import dedent
from typing import Any, Callable, Dict, Optional, Tuple

from pip._vendor.packaging.utils import canonicalize_name

from pip._internal.cli.parser import ConfigOptionParser
from pip._internal.exceptions import CommandError
from pip._internal.locations import USER_CACHE_DIR, get_src_prefix
from pip._internal.models.format_control import FormatControl
from pip._internal.models.index import PyPI
from pip._internal.models.target_python import TargetPython
from pip._internal.utils.hashes import STRONG_HASHES
from pip._internal.utils.misc import strtobool

logger = logging.getLogger(__name__)


def raise_option_error(parser: OptionParser, option: Option, msg: str) -> None:
    """
    Format and raise an option parsing error via the parser.
    
    The message is normalized and prefixed with "<option> error: " (using the option's string
    representation), then passed to parser.error(), which reports the error and terminates
    option parsing.
    """
    msg = f"{option} error: {msg}"
    msg = textwrap.fill(" ".join(msg.split()))
    parser.error(msg)


def make_option_group(group: Dict[str, Any], parser: ConfigOptionParser) -> OptionGroup:
    """
    Create an optparse OptionGroup from a group descriptor.
    
    The `group` argument must be a dict with:
    - "name" (str): the display name for the option group.
    - "options" (Iterable[Callable[[], Option]]): callables that return Option instances; each callable
      will be invoked and the resulting Option added to the created OptionGroup.
    
    The `parser` is the ConfigOptionParser that will own the returned OptionGroup.
    
    Returns:
        OptionGroup: the newly created OptionGroup with each option added.
    """
    option_group = OptionGroup(parser, group["name"])
    for option in group["options"]:
        option_group.add_option(option())
    return option_group


def check_dist_restriction(options: Values, check_target: bool = False) -> None:
    """
    Validate whether platform/ABI/interpreter restriction options are allowed with the current install settings.
    
    Checks if any of the target-restriction options (--python-version, --platform, --abi, --implementation)
    are set and enforces rules that disallow mixing source-distribution dependency resolution with
    platform-specific wheels. If such restrictions are active, one of the following must be true:
    - dependencies are disabled (--no-deps), or
    - only binaries are requested for all packages (--only-binary=:all:) and --no-binary is not excluding binaries.
    
    If check_target is True, also requires that either --target is in use (options.target_dir is set)
    or the run is a dry run (options.dry_run); otherwise a CommandError is raised.
    
    Parameters:
        options (optparse.Values): Parsed CLI option values containing attributes used for the checks
            (python_version, platforms, abis, implementation, format_control, ignore_dependencies,
            dry_run, target_dir).
        check_target (bool): When True, enforce the additional rule requiring --target or --dry-run
            when any distribution restriction is set.
    
    Raises:
        CommandError: If distribution restrictions conflict with dependency/binary settings, or
            if check_target is True and restrictions are used without --target or --dry-run.
    """
    dist_restriction_set = any(
        [
            options.python_version,
            options.platforms,
            options.abis,
            options.implementation,
        ]
    )

    binary_only = FormatControl(set(), {":all:"})
    sdist_dependencies_allowed = (
        options.format_control != binary_only and not options.ignore_dependencies
    )

    # Installations or downloads using dist restrictions must not combine
    # source distributions and dist-specific wheels, as they are not
    # guaranteed to be locally compatible.
    if dist_restriction_set and sdist_dependencies_allowed:
        raise CommandError(
            "When restricting platform and interpreter constraints using "
            "--python-version, --platform, --abi, or --implementation, "
            "either --no-deps must be set, or --only-binary=:all: must be "
            "set and --no-binary must not be set (or must be set to "
            ":none:)."
        )

    if check_target:
        if not options.dry_run and dist_restriction_set and not options.target_dir:
            raise CommandError(
                "Can not use any platform or abi specific options unless "
                "installing via '--target' or using '--dry-run'"
            )


def _path_option_check(option: Option, opt: str, value: str) -> str:
    """
    Expand a user path value (e.g., `~` or `~user`) and return the resulting filesystem path.
    
    Parameters:
        option: The option object (unused).
        opt: The option string as provided on the command line (unused).
        value: The path string to expand.
    
    Returns:
        The path with user home components expanded (a str).
    """
    return os.path.expanduser(value)


def _package_name_option_check(option: Option, opt: str, value: str) -> str:
    """
    Return the PEP 503â€“normalized (canonicalized) package name for an option value.
    
    This is an optparse type checker callback used for options that accept package
    names (e.g., --exclude). It normalizes the provided name (case and punctuation)
    so different spellings map to the same canonical name.
    
    Parameters:
        option: The optparse Option instance (unused).
        opt: The option string that was used (unused).
        value: The package name supplied on the command line.
    
    Returns:
        The canonicalized package name as a string.
    """
    return canonicalize_name(value)


class PipOption(Option):
    TYPES = Option.TYPES + ("path", "package_name")
    TYPE_CHECKER = Option.TYPE_CHECKER.copy()
    TYPE_CHECKER["package_name"] = _package_name_option_check
    TYPE_CHECKER["path"] = _path_option_check


###########
# options #
###########

help_: Callable[..., Option] = partial(
    Option,
    "-h",
    "--help",
    dest="help",
    action="help",
    help="Show help.",
)

debug_mode: Callable[..., Option] = partial(
    Option,
    "--debug",
    dest="debug_mode",
    action="store_true",
    default=False,
    help=(
        "Let unhandled exceptions propagate outside the main subroutine, "
        "instead of logging them to stderr."
    ),
)

isolated_mode: Callable[..., Option] = partial(
    Option,
    "--isolated",
    dest="isolated_mode",
    action="store_true",
    default=False,
    help=(
        "Run pip in an isolated mode, ignoring environment variables and user "
        "configuration."
    ),
)

require_virtualenv: Callable[..., Option] = partial(
    Option,
    "--require-virtualenv",
    "--require-venv",
    dest="require_venv",
    action="store_true",
    default=False,
    help=(
        "Allow pip to only run in a virtual environment; "
        "exit with an error otherwise."
    ),
)

override_externally_managed: Callable[..., Option] = partial(
    Option,
    "--break-system-packages",
    dest="override_externally_managed",
    action="store_true",
    help="Allow pip to modify an EXTERNALLY-MANAGED Python installation",
)

python: Callable[..., Option] = partial(
    Option,
    "--python",
    dest="python",
    help="Run pip with the specified Python interpreter.",
)

verbose: Callable[..., Option] = partial(
    Option,
    "-v",
    "--verbose",
    dest="verbose",
    action="count",
    default=0,
    help="Give more output. Option is additive, and can be used up to 3 times.",
)

no_color: Callable[..., Option] = partial(
    Option,
    "--no-color",
    dest="no_color",
    action="store_true",
    default=False,
    help="Suppress colored output.",
)

version: Callable[..., Option] = partial(
    Option,
    "-V",
    "--version",
    dest="version",
    action="store_true",
    help="Show version and exit.",
)

quiet: Callable[..., Option] = partial(
    Option,
    "-q",
    "--quiet",
    dest="quiet",
    action="count",
    default=0,
    help=(
        "Give less output. Option is additive, and can be used up to 3"
        " times (corresponding to WARNING, ERROR, and CRITICAL logging"
        " levels)."
    ),
)

progress_bar: Callable[..., Option] = partial(
    Option,
    "--progress-bar",
    dest="progress_bar",
    type="choice",
    choices=["on", "off"],
    default="on",
    help="Specify whether the progress bar should be used [on, off] (default: on)",
)

log: Callable[..., Option] = partial(
    PipOption,
    "--log",
    "--log-file",
    "--local-log",
    dest="log",
    metavar="path",
    type="path",
    help="Path to a verbose appending log.",
)

no_input: Callable[..., Option] = partial(
    Option,
    # Don't ask for input
    "--no-input",
    dest="no_input",
    action="store_true",
    default=False,
    help="Disable prompting for input.",
)

keyring_provider: Callable[..., Option] = partial(
    Option,
    "--keyring-provider",
    dest="keyring_provider",
    choices=["auto", "disabled", "import", "subprocess"],
    default="auto",
    help=(
        "Enable the credential lookup via the keyring library if user input is allowed."
        " Specify which mechanism to use [disabled, import, subprocess]."
        " (default: disabled)"
    ),
)

proxy: Callable[..., Option] = partial(
    Option,
    "--proxy",
    dest="proxy",
    type="str",
    default="",
    help="Specify a proxy in the form scheme://[user:passwd@]proxy.server:port.",
)

retries: Callable[..., Option] = partial(
    Option,
    "--retries",
    dest="retries",
    type="int",
    default=5,
    help="Maximum number of retries each connection should attempt "
    "(default %default times).",
)

timeout: Callable[..., Option] = partial(
    Option,
    "--timeout",
    "--default-timeout",
    metavar="sec",
    dest="timeout",
    type="float",
    default=15,
    help="Set the socket timeout (default %default seconds).",
)


def exists_action() -> Option:
    """
    Create the --exists-action Option that specifies the default action when a filesystem path already exists.
    
    The option accepts one of the single-letter choices:
    - "s": switch (replace existing path by switching)
    - "i": ignore (leave existing path untouched)
    - "w": wipe (remove existing path before proceeding)
    - "b": backup (move existing path aside as a backup)
    - "a": abort (stop the operation)
    
    This Option supports repeated use; each occurrence is appended to a list (default is an empty list), allowing multiple actions to be specified in order.
    Returns:
        optparse.Option: Configured Option for the --exists-action flag.
    """
    return Option(
        # Option when path already exist
        "--exists-action",
        dest="exists_action",
        type="choice",
        choices=["s", "i", "w", "b", "a"],
        default=[],
        action="append",
        metavar="action",
        help="Default action when a path already exists: "
        "(s)witch, (i)gnore, (w)ipe, (b)ackup, (a)bort.",
    )


cert: Callable[..., Option] = partial(
    PipOption,
    "--cert",
    dest="cert",
    type="path",
    metavar="path",
    help=(
        "Path to PEM-encoded CA certificate bundle. "
        "If provided, overrides the default. "
        "See 'SSL Certificate Verification' in pip documentation "
        "for more information."
    ),
)

client_cert: Callable[..., Option] = partial(
    PipOption,
    "--client-cert",
    dest="client_cert",
    type="path",
    default=None,
    metavar="path",
    help="Path to SSL client certificate, a single file containing the "
    "private key and the certificate in PEM format.",
)

index_url: Callable[..., Option] = partial(
    Option,
    "-i",
    "--index-url",
    "--pypi-url",
    dest="index_url",
    metavar="URL",
    default=PyPI.simple_url,
    help="Base URL of the Python Package Index (default %default). "
    "This should point to a repository compliant with PEP 503 "
    "(the simple repository API) or a local directory laid out "
    "in the same format.",
)


def extra_index_url() -> Option:
    """
    Create an optparse.Option for the --extra-index-url CLI flag.
    
    This option allows specifying one or more additional package index URLs to be used in addition to the primary --index-url. Each occurrence appends the provided URL to the `extra_index_urls` list in the parsed options. Values must follow the same rules and format as --index-url.
    
    Returns:
        Option: An optparse.Option configured for `--extra-index-url` (action="append",
        dest="extra_index_urls", metavar="URL").
    """
    return Option(
        "--extra-index-url",
        dest="extra_index_urls",
        metavar="URL",
        action="append",
        default=[],
        help="Extra URLs of package indexes to use in addition to "
        "--index-url. Should follow the same rules as "
        "--index-url.",
    )


no_index: Callable[..., Option] = partial(
    Option,
    "--no-index",
    dest="no_index",
    action="store_true",
    default=False,
    help="Ignore package index (only looking at --find-links URLs instead).",
)


def find_links() -> Option:
    """
    Create and return an optparse Option for specifying additional locations to search for package archives.
    
    The option (-f, --find-links) may be repeated; each occurrence appends a URL or path to the resulting list. Behavior:
    - If the value is an HTML page or URL to an HTML file, the page is parsed for links to archive files (e.g., .tar.gz, .whl).
    - If the value is a local directory path or a file:// URL pointing to a directory, the directory listing is searched for archives.
    - VCS project URLs are not supported.
    
    Returns:
        Option: An optparse Option configured with action="append", dest="find_links", and metavar="url".
    """
    return Option(
        "-f",
        "--find-links",
        dest="find_links",
        action="append",
        default=[],
        metavar="url",
        help="If a URL or path to an html file, then parse for links to "
        "archives such as sdist (.tar.gz) or wheel (.whl) files. "
        "If a local path or file:// URL that's a directory, "
        "then look for archives in the directory listing. "
        "Links to VCS project URLs are not supported.",
    )


def trusted_host() -> Option:
    """
    Create the `--trusted-host` CLI option.
    
    This option can be repeated; each occurrence appends a host or host:port string
    to the resulting `trusted_hosts` list (parser destination). Hosts added via
    this option are treated as trusted even if they do not present valid HTTPS
    certificates or use HTTPS at all.
    
    Returns:
        Option: An optparse.Option configured for `--trusted-host`.
    """
    return Option(
        "--trusted-host",
        dest="trusted_hosts",
        action="append",
        metavar="HOSTNAME",
        default=[],
        help="Mark this host or host:port pair as trusted, even though it "
        "does not have valid or any HTTPS.",
    )


def constraints() -> Option:
    """
    Return an optparse Option for specifying one or more constraints files.
    
    Each use of the option adds a constraints file path to the `constraints` destination
    (list). Short flag `-c` and long flag `--constraint` are provided; value shown as `file`.
    """
    return Option(
        "-c",
        "--constraint",
        dest="constraints",
        action="append",
        default=[],
        metavar="file",
        help="Constrain versions using the given constraints file. "
        "This option can be used multiple times.",
    )


def requirements() -> Option:
    """
    Create and return an Option for specifying requirement files (-r/--requirement).
    
    The option accepts a file path (metavar "file"), can be repeated to add multiple
    requirement files, and collects them into the `requirements` destination as a list.
    """
    return Option(
        "-r",
        "--requirement",
        dest="requirements",
        action="append",
        default=[],
        metavar="file",
        help="Install from the given requirements file. "
        "This option can be used multiple times.",
    )


def editable() -> Option:
    """
    Create an optparse.Option for the -e/--editable flag.
    
    The option appends one or more local project paths or VCS URLs to the `editables`
    destination and is used to install projects in editable (setuptools "develop")
    mode.
    
    Returns:
        optparse.Option: An Option configured with flags `-e`/`--editable`, action
        `append`, destination `editables`, metavar `path/url`, and a help string.
    """
    return Option(
        "-e",
        "--editable",
        dest="editables",
        action="append",
        default=[],
        metavar="path/url",
        help=(
            "Install a project in editable mode (i.e. setuptools "
            '"develop mode") from a local project path or a VCS url.'
        ),
    )


def _handle_src(option: Option, opt_str: str, value: str, parser: OptionParser) -> None:
    """
    Convert a provided source path to an absolute path and store it on the parser values.
    
    This callback expands the given path to an absolute path (via os.path.abspath)
    and assigns it to parser.values at the destination name defined by the option.
    
    Parameters:
        option: The Option that triggered this callback; its `dest` attribute
            determines the attribute name written to parser.values.
        opt_str: The option string used (e.g., "--src") â€” not used by this callback.
        value: The path value provided by the user.
        parser: The OptionParser instance whose `values` will be updated.
    """
    value = os.path.abspath(value)
    setattr(parser.values, option.dest, value)


src: Callable[..., Option] = partial(
    PipOption,
    "--src",
    "--source",
    "--source-dir",
    "--source-directory",
    dest="src_dir",
    type="path",
    metavar="dir",
    default=get_src_prefix(),
    action="callback",
    callback=_handle_src,
    help="Directory to check out editable projects into. "
    'The default in a virtualenv is "<venv path>/src". '
    'The default for global installs is "<current dir>/src".',
)


def _get_format_control(values: Values, option: Option) -> Any:
    """Get a format_control object."""
    return getattr(values, option.dest)


def _handle_no_binary(
    option: Option, opt_str: str, value: str, parser: OptionParser
) -> None:
    """
    Callback for the `--no-binary` option.
    
    Applies the `value` to the current FormatControl by enforcing mutual-exclusion rules between
    the "no-binary" and "only-binary" settings. This updates the parser's FormatControl state
    so subsequent option processing and resolution use the new binary/source preferences.
    """
    existing = _get_format_control(parser.values, option)
    FormatControl.handle_mutual_excludes(
        value,
        existing.no_binary,
        existing.only_binary,
    )


def _handle_only_binary(
    option: Option, opt_str: str, value: str, parser: OptionParser
) -> None:
    """
    Callback used by the `--only-binary` option to apply the "only binary" setting to the parsed FormatControl.
    
    Parses the provided value and applies mutual-exclusion rules between the current
    `only_binary` and `no_binary` settings stored on the parser's FormatControl instance.
    This updates the FormatControl in-place (via FormatControl.handle_mutual_excludes) so
    subsequent option handling and resolution respect the `--only-binary` directive.
    """
    existing = _get_format_control(parser.values, option)
    FormatControl.handle_mutual_excludes(
        value,
        existing.only_binary,
        existing.no_binary,
    )


def no_binary() -> Option:
    """
    Return an optparse Option for the --no-binary flag which updates the parsed
    FormatControl to exclude binary distributions.
    
    This callback-style option appends to the destination `format_control` each
    time it is used. Accepted values:
    - ":all:" â€” disable all binary packages
    - ":none:" â€” clear the binary-exclusion set
    - one or more comma-separated package names (no colons) â€” add those packages
    
    The option's default is an empty FormatControl (no binary restrictions).
    """
    format_control = FormatControl(set(), set())
    return Option(
        "--no-binary",
        dest="format_control",
        action="callback",
        callback=_handle_no_binary,
        type="str",
        default=format_control,
        help="Do not use binary packages. Can be supplied multiple times, and "
        'each time adds to the existing value. Accepts either ":all:" to '
        'disable all binary packages, ":none:" to empty the set (notice '
        "the colons), or one or more package names with commas between "
        "them (no colons). Note that some packages are tricky to compile "
        "and may fail to install when this option is used on them.",
    )


def only_binary() -> Option:
    """
    Return an optparse Option for the `--only-binary` CLI flag.
    
    This option configures pip to use only binary distributions for the named packages. It accepts repeated uses and accumulates values into a FormatControl object. Valid values are:
    
    - ":all:" â€” require binaries for all packages (disallow source packages).
    - ":none:" â€” clear the restriction (allow source packages).
    - A comma-separated list of package names â€” restrict those packages to binaries.
    
    When `--only-binary` is in effect, installing a package that has no available binary distribution will fail. The returned Option is set up to store and update a FormatControl instance as its destination value.
    """
    format_control = FormatControl(set(), set())
    return Option(
        "--only-binary",
        dest="format_control",
        action="callback",
        callback=_handle_only_binary,
        type="str",
        default=format_control,
        help="Do not use source packages. Can be supplied multiple times, and "
        'each time adds to the existing value. Accepts either ":all:" to '
        'disable all source packages, ":none:" to empty the set, or one '
        "or more package names with commas between them. Packages "
        "without binary distributions will fail to install when this "
        "option is used on them.",
    )


platforms: Callable[..., Option] = partial(
    Option,
    "--platform",
    dest="platforms",
    metavar="platform",
    action="append",
    default=None,
    help=(
        "Only use wheels compatible with <platform>. Defaults to the "
        "platform of the running system. Use this option multiple times to "
        "specify multiple platforms supported by the target interpreter."
    ),
)


# This was made a separate function for unit-testing purposes.
def _convert_python_version(value: str) -> Tuple[Tuple[int, ...], Optional[str]]:
    """
    Parse a Python version string into a tuple of integers.
    
    Accepts version strings like "3", "37", "3.7", or "3.7.3" and returns a pair
    (version_info, error_msg). version_info is a tuple of integers on success
    (e.g. (3,), (3, 7), (3, 7, 3)). If the input is an empty string, returns
    (None, None) to indicate "no value provided". On parse failure, returns
    ((), error_msg) where error_msg describes the problem.
    
    Errors:
    - "at most three version parts are allowed" if more than three dot-separated parts are given.
    - "each version part must be an integer" if any part cannot be parsed as an int.
    """
    if not value:
        # The empty string is the same as not providing a value.
        return (None, None)

    parts = value.split(".")
    if len(parts) > 3:
        return ((), "at most three version parts are allowed")

    if len(parts) == 1:
        # Then we are in the case of "3" or "37".
        value = parts[0]
        if len(value) > 1:
            parts = [value[0], value[1:]]

    try:
        version_info = tuple(int(part) for part in parts)
    except ValueError:
        return ((), "each version part must be an integer")

    return (version_info, None)


def _handle_python_version(
    option: Option, opt_str: str, value: str, parser: OptionParser
) -> None:
    """
    Parse and store a --python-version option value.
    
    Parses the provided string (e.g. "3", "37", "3.7.3") using _convert_python_version and sets
    parser.values.python_version to the resulting version-info tuple on success. If the value is
    invalid, raises a parser option error via raise_option_error.
    """
    version_info, error_msg = _convert_python_version(value)
    if error_msg is not None:
        msg = f"invalid --python-version value: {value!r}: {error_msg}"
        raise_option_error(parser, option=option, msg=msg)

    parser.values.python_version = version_info


python_version: Callable[..., Option] = partial(
    Option,
    "--python-version",
    dest="python_version",
    metavar="python_version",
    action="callback",
    callback=_handle_python_version,
    type="str",
    default=None,
    help=dedent(
        """\
    The Python interpreter version to use for wheel and "Requires-Python"
    compatibility checks. Defaults to a version derived from the running
    interpreter. The version can be specified using up to three dot-separated
    integers (e.g. "3" for 3.0.0, "3.7" for 3.7.0, or "3.7.3"). A major-minor
    version can also be given as a string without dots (e.g. "37" for 3.7.0).
    """
    ),
)


implementation: Callable[..., Option] = partial(
    Option,
    "--implementation",
    dest="implementation",
    metavar="implementation",
    default=None,
    help=(
        "Only use wheels compatible with Python "
        "implementation <implementation>, e.g. 'pp', 'jy', 'cp', "
        " or 'ip'. If not specified, then the current "
        "interpreter implementation is used.  Use 'py' to force "
        "implementation-agnostic wheels."
    ),
)


abis: Callable[..., Option] = partial(
    Option,
    "--abi",
    dest="abis",
    metavar="abi",
    action="append",
    default=None,
    help=(
        "Only use wheels compatible with Python abi <abi>, e.g. 'pypy_41'. "
        "If not specified, then the current interpreter abi tag is used. "
        "Use this option multiple times to specify multiple abis supported "
        "by the target interpreter. Generally you will need to specify "
        "--implementation, --platform, and --python-version when using this "
        "option."
    ),
)


def add_target_python_options(cmd_opts: OptionGroup) -> None:
    """
    Add target-Python-related CLI options to the provided OptionGroup.
    
    This registers the platform, Python version, implementation, and ABI options
    onto the given OptionGroup so they appear together in help output and are
    parsed with the group (calls: platforms(), python_version(), implementation(),
    abis()).
    """
    cmd_opts.add_option(platforms())
    cmd_opts.add_option(python_version())
    cmd_opts.add_option(implementation())
    cmd_opts.add_option(abis())


def make_target_python(options: Values) -> TargetPython:
    """
    Create a TargetPython descriptor from parsed CLI option values.
    
    Parameters:
        options (optparse.Values): Parsed option values; expected attributes:
            - platforms: list or None of platform tags
            - python_version: tuple or None with parsed Python version info
            - abis: list or None of ABI tags
            - implementation: str or None for the Python implementation
    
    Returns:
        TargetPython: A TargetPython instance populated from the provided options.
    """
    target_python = TargetPython(
        platforms=options.platforms,
        py_version_info=options.python_version,
        abis=options.abis,
        implementation=options.implementation,
    )

    return target_python


def prefer_binary() -> Option:
    """
    Return an optparse Option for the --prefer-binary flag.
    
    When set, pip will prefer installing binary distributions (wheels) over
    source distributions, even if the source packages have newer versions.
    
    Returns:
        Option: An optparse Option configured for `--prefer-binary` that stores
        a boolean into `prefer_binary`.
    """
    return Option(
        "--prefer-binary",
        dest="prefer_binary",
        action="store_true",
        default=False,
        help=(
            "Prefer binary packages over source packages, even if the "
            "source packages are newer."
        ),
    )


cache_dir: Callable[..., Option] = partial(
    PipOption,
    "--cache-dir",
    dest="cache_dir",
    default=USER_CACHE_DIR,
    metavar="dir",
    type="path",
    help="Store the cache data in <dir>.",
)


def _handle_no_cache_dir(
    option: Option, opt: str, value: str, parser: OptionParser
) -> None:
    """
    Handle the --no-cache-dir option callback: validate an optional string value and disable caching.
    
    This optparse callback accepts either no argument (normal CLI usage) or a string (e.g., from an environment variable like PIP_NO_CACHE_DIR). If a string value is provided, it is validated using strtobool; on invalid input an option error is raised via raise_option_error. Regardless of the parsed boolean result, this callback always disables the cache by setting parser.values.cache_dir = False for compatibility.
    
    Parameters:
        option: The Option instance for --no-cache-dir.
        opt: The option string used (e.g., "--no-cache-dir").
        value: The raw value passed to the option (None when provided on the command line).
        parser: The OptionParser parsing the options; its values.cache_dir is mutated to False.
    
    Raises:
        OptionError (via raise_option_error) if a non-None string value cannot be parsed by strtobool.
    """
    # The value argument will be None if --no-cache-dir is passed via the
    # command-line, since the option doesn't accept arguments.  However,
    # the value can be non-None if the option is triggered e.g. by an
    # environment variable, like PIP_NO_CACHE_DIR=true.
    if value is not None:
        # Then parse the string value to get argument error-checking.
        try:
            strtobool(value)
        except ValueError as exc:
            raise_option_error(parser, option=option, msg=str(exc))

    # Originally, setting PIP_NO_CACHE_DIR to a value that strtobool()
    # converted to 0 (like "false" or "no") caused cache_dir to be disabled
    # rather than enabled (logic would say the latter).  Thus, we disable
    # the cache directory not just on values that parse to True, but (for
    # backwards compatibility reasons) also on values that parse to False.
    # In other words, always set it to False if the option is provided in
    # some (valid) form.
    parser.values.cache_dir = False


no_cache: Callable[..., Option] = partial(
    Option,
    "--no-cache-dir",
    dest="cache_dir",
    action="callback",
    callback=_handle_no_cache_dir,
    help="Disable the cache.",
)

no_deps: Callable[..., Option] = partial(
    Option,
    "--no-deps",
    "--no-dependencies",
    dest="ignore_dependencies",
    action="store_true",
    default=False,
    help="Don't install package dependencies.",
)

ignore_requires_python: Callable[..., Option] = partial(
    Option,
    "--ignore-requires-python",
    dest="ignore_requires_python",
    action="store_true",
    help="Ignore the Requires-Python information.",
)

no_build_isolation: Callable[..., Option] = partial(
    Option,
    "--no-build-isolation",
    dest="build_isolation",
    action="store_false",
    default=True,
    help="Disable isolation when building a modern source distribution. "
    "Build dependencies specified by PEP 518 must be already installed "
    "if this option is used.",
)

check_build_deps: Callable[..., Option] = partial(
    Option,
    "--check-build-dependencies",
    dest="check_build_deps",
    action="store_true",
    default=False,
    help="Check the build dependencies when PEP517 is used.",
)


def _handle_no_use_pep517(
    option: Option, opt: str, value: str, parser: OptionParser
) -> None:
    """
    Handle the --no-use-pep517 option (optparse callback).
    
    If a value is supplied (e.g. via PIP_NO_USE_PEP517 env var or config), this rejects it with guidance to use the positive setting instead.
    If invoked from the command line, verifies that both setuptools and wheel are importable; if either is missing, raises an option error explaining they are required.
    On success, disables PEP 517 by setting parser.values.use_pep517 = False.
    
    Raises:
        OptionError via raise_option_error when a value is provided or when required packages are missing.
    """
    # Since --no-use-pep517 doesn't accept arguments, the value argument
    # will be None if --no-use-pep517 is passed via the command-line.
    # However, the value can be non-None if the option is triggered e.g.
    # by an environment variable, for example "PIP_NO_USE_PEP517=true".
    if value is not None:
        msg = """A value was passed for --no-use-pep517,
        probably using either the PIP_NO_USE_PEP517 environment variable
        or the "no-use-pep517" config file option. Use an appropriate value
        of the PIP_USE_PEP517 environment variable or the "use-pep517"
        config file option instead.
        """
        raise_option_error(parser, option=option, msg=msg)

    # If user doesn't wish to use pep517, we check if setuptools and wheel are installed
    # and raise error if it is not.
    packages = ("setuptools", "wheel")
    if not all(importlib.util.find_spec(package) for package in packages):
        msg = (
            f"It is not possible to use --no-use-pep517 "
            f"without {' and '.join(packages)} installed."
        )
        raise_option_error(parser, option=option, msg=msg)

    # Otherwise, --no-use-pep517 was passed via the command-line.
    parser.values.use_pep517 = False


use_pep517: Any = partial(
    Option,
    "--use-pep517",
    dest="use_pep517",
    action="store_true",
    default=None,
    help="Use PEP 517 for building source distributions "
    "(use --no-use-pep517 to force legacy behaviour).",
)

no_use_pep517: Any = partial(
    Option,
    "--no-use-pep517",
    dest="use_pep517",
    action="callback",
    callback=_handle_no_use_pep517,
    default=None,
    help=SUPPRESS_HELP,
)


def _handle_config_settings(
    option: Option, opt_str: str, value: str, parser: OptionParser
) -> None:
    """
    Parse a KEY=VAL setting and merge it into the option destination dictionary on the parser.
    
    Parses `value` as `KEY=VAL` and stores it in `parser.values.<option.dest>` (creating a dict if needed).
    If the same key is provided multiple times, values are accumulated: the first duplicate becomes a
    two-element list, further duplicates are appended to that list.
    
    Parameters:
        option: The Option object whose `dest` names the target dict.
        opt_str: The option string used (e.g., "--config-settings") â€” used for error reporting.
        value: A string of the form `KEY=VAL`.
    """
    key, sep, val = value.partition("=")
    if sep != "=":
        parser.error(f"Arguments to {opt_str} must be of the form KEY=VAL")
    dest = getattr(parser.values, option.dest)
    if dest is None:
        dest = {}
        setattr(parser.values, option.dest, dest)
    if key in dest:
        if isinstance(dest[key], list):
            dest[key].append(val)
        else:
            dest[key] = [dest[key], val]
    else:
        dest[key] = val


config_settings: Callable[..., Option] = partial(
    Option,
    "-C",
    "--config-settings",
    dest="config_settings",
    type=str,
    action="callback",
    callback=_handle_config_settings,
    metavar="settings",
    help="Configuration settings to be passed to the PEP 517 build backend. "
    "Settings take the form KEY=VALUE. Use multiple --config-settings options "
    "to pass multiple keys to the backend.",
)

build_options: Callable[..., Option] = partial(
    Option,
    "--build-option",
    dest="build_options",
    metavar="options",
    action="append",
    help="Extra arguments to be supplied to 'setup.py bdist_wheel'.",
)

global_options: Callable[..., Option] = partial(
    Option,
    "--global-option",
    dest="global_options",
    action="append",
    metavar="options",
    help="Extra global options to be supplied to the setup.py "
    "call before the install or bdist_wheel command.",
)

no_clean: Callable[..., Option] = partial(
    Option,
    "--no-clean",
    action="store_true",
    default=False,
    help="Don't clean up build directories.",
)

pre: Callable[..., Option] = partial(
    Option,
    "--pre",
    action="store_true",
    default=False,
    help="Include pre-release and development versions. By default, "
    "pip only finds stable versions.",
)

disable_pip_version_check: Callable[..., Option] = partial(
    Option,
    "--disable-pip-version-check",
    dest="disable_pip_version_check",
    action="store_true",
    default=True,
    help="Don't periodically check PyPI to determine whether a new version "
    "of pip is available for download. Implied with --no-index.",
)

root_user_action: Callable[..., Option] = partial(
    Option,
    "--root-user-action",
    dest="root_user_action",
    default="warn",
    choices=["warn", "ignore"],
    help="Action if pip is run as a root user. By default, a warning message is shown.",
)


def _handle_merge_hash(
    option: Option, opt_str: str, value: str, parser: OptionParser
) -> None:
    """
    Parse a single `--hash` value of the form "algo:digest" and merge it into
    the parser's accumulated hashes.
    
    If the `parser.values.hashes` mapping does not exist, it is created.
    The digest is appended to a list keyed by the algorithm name (e.g. "sha256").
    On invalid format (missing colon) or an unknown algorithm (not in STRONG_HASHES),
    this calls `parser.error` with a descriptive message.
    """
    if not parser.values.hashes:
        parser.values.hashes = {}
    try:
        algo, digest = value.split(":", 1)
    except ValueError:
        parser.error(
            f"Arguments to {opt_str} must be a hash name "
            "followed by a value, like --hash=sha256:"
            "abcde..."
        )
    if algo not in STRONG_HASHES:
        parser.error(
            "Allowed hash algorithms for {} are {}.".format(
                opt_str, ", ".join(STRONG_HASHES)
            )
        )
    parser.values.hashes.setdefault(algo, []).append(digest)


hash: Callable[..., Option] = partial(
    Option,
    "--hash",
    # Hash values eventually end up in InstallRequirement.hashes due to
    # __dict__ copying in process_line().
    dest="hashes",
    action="callback",
    callback=_handle_merge_hash,
    type="string",
    help="Verify that the package's archive matches this "
    "hash before installing. Example: --hash=sha256:abcdef...",
)


require_hashes: Callable[..., Option] = partial(
    Option,
    "--require-hashes",
    dest="require_hashes",
    action="store_true",
    default=False,
    help="Require a hash to check each requirement against, for "
    "repeatable installs. This option is implied when any package in a "
    "requirements file has a --hash option.",
)


list_path: Callable[..., Option] = partial(
    PipOption,
    "--path",
    dest="path",
    type="path",
    action="append",
    help="Restrict to the specified installation path for listing "
    "packages (can be used multiple times).",
)


def check_list_path_option(options: Values) -> None:
    """
    Validate that mutually exclusive listing options are not combined.
    
    Checks parsed option values and raises a CommandError if --path is used together
    with either --user or --local, which are mutually exclusive.
    
    Parameters:
        options (optparse.Values): Parsed CLI option values containing `path`, `user`,
            and `local` attributes.
    
    Raises:
        CommandError: If `path` is set while `user` or `local` is also set.
    """
    if options.path and (options.user or options.local):
        raise CommandError("Cannot combine '--path' with '--user' or '--local'")


list_exclude: Callable[..., Option] = partial(
    PipOption,
    "--exclude",
    dest="excludes",
    action="append",
    metavar="package",
    type="package_name",
    help="Exclude specified package from the output",
)


no_python_version_warning: Callable[..., Option] = partial(
    Option,
    "--no-python-version-warning",
    dest="no_python_version_warning",
    action="store_true",
    default=False,
    help="Silence deprecation warnings for upcoming unsupported Pythons.",
)


# Features that are now always on. A warning is printed if they are used.
ALWAYS_ENABLED_FEATURES = [
    "no-binary-enable-wheel-cache",  # always on since 23.1
]

use_new_feature: Callable[..., Option] = partial(
    Option,
    "--use-feature",
    dest="features_enabled",
    metavar="feature",
    action="append",
    default=[],
    choices=[
        "fast-deps",
        "truststore",
    ]
    + ALWAYS_ENABLED_FEATURES,
    help="Enable new functionality, that may be backward incompatible.",
)

use_deprecated_feature: Callable[..., Option] = partial(
    Option,
    "--use-deprecated",
    dest="deprecated_features_enabled",
    metavar="feature",
    action="append",
    default=[],
    choices=[
        "legacy-resolver",
    ],
    help=("Enable deprecated functionality, that will be removed in the future."),
)


##########
# groups #
##########

general_group: Dict[str, Any] = {
    "name": "General Options",
    "options": [
        help_,
        debug_mode,
        isolated_mode,
        require_virtualenv,
        python,
        verbose,
        version,
        quiet,
        log,
        no_input,
        keyring_provider,
        proxy,
        retries,
        timeout,
        exists_action,
        trusted_host,
        cert,
        client_cert,
        cache_dir,
        no_cache,
        disable_pip_version_check,
        no_color,
        no_python_version_warning,
        use_new_feature,
        use_deprecated_feature,
    ],
}

index_group: Dict[str, Any] = {
    "name": "Package Index Options",
    "options": [
        index_url,
        extra_index_url,
        no_index,
        find_links,
    ],
}
