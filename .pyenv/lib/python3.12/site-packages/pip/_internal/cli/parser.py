"""Base option parser setup"""

import logging
import optparse
import shutil
import sys
import textwrap
from contextlib import suppress
from typing import Any, Dict, Generator, List, Tuple

from pip._internal.cli.status_codes import UNKNOWN_ERROR
from pip._internal.configuration import Configuration, ConfigurationError
from pip._internal.utils.misc import redact_auth_from_url, strtobool

logger = logging.getLogger(__name__)


class PrettyHelpFormatter(optparse.IndentedHelpFormatter):
    """A prettier/less verbose help formatter for optparse."""

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        # help position must be aligned with __init__.parseopts.description
        """
        Initialize the PrettyHelpFormatter with pip-specific formatting defaults.
        
        Sets max_help_position to 30, indent_increment to 1, and width to the current terminal width minus two columns, then delegates remaining initialization to the base formatter.
        """
        kwargs["max_help_position"] = 30
        kwargs["indent_increment"] = 1
        kwargs["width"] = shutil.get_terminal_size()[0] - 2
        super().__init__(*args, **kwargs)

    def format_option_strings(self, option: optparse.Option) -> str:
        """
        Return the formatted option strings for an Option instance as shown in help output.
        
        This delegates to the internal _format_option_strings implementation which builds a comma-separated
        representation of the option's short and long forms and appends a metavar if the option takes a value.
        
        Parameters:
            option (optparse.Option): The option to format.
        
        Returns:
            str: The formatted option string(s) suitable for inclusion in help text.
        """
        return self._format_option_strings(option)

    def _format_option_strings(
        self, option: optparse.Option, mvarfmt: str = " <{}>", optsep: str = ", "
    ) -> str:
        """
        Build a formatted option string from an optparse.Option (short/long names plus metavar).
        
        Uses the first short and first long form (if present), inserts `optsep` between them when both exist,
        and appends a formatted metavar when the option takes a value.
        
        Parameters:
            option (optparse.Option): The option to format.
            mvarfmt (str): Format string used to render the metavar (default: " <{}>").
            optsep (str): Separator inserted between short and long forms when both are present (default: ", ").
        
        Returns:
            str: The combined option string (e.g. "-f, --format <format>").
        """
        opts = []

        if option._short_opts:
            opts.append(option._short_opts[0])
        if option._long_opts:
            opts.append(option._long_opts[0])
        if len(opts) > 1:
            opts.insert(1, optsep)

        if option.takes_value():
            assert option.dest is not None
            metavar = option.metavar or option.dest.lower()
            opts.append(mvarfmt.format(metavar.lower()))

        return "".join(opts)

    def format_heading(self, heading: str) -> str:
        """
        Return a formatted section heading for help output.
        
        If heading equals "Options", returns an empty string (suppressing that heading).
        Otherwise returns the heading followed by a colon and a trailing newline (e.g. "Heading:\n").
        
        Parameters:
            heading (str): The raw heading text.
        
        Returns:
            str: The formatted heading string or an empty string when the heading is "Options".
        """
        if heading == "Options":
            return ""
        return heading + ":\n"

    def format_usage(self, usage: str) -> str:
        """
        Format and return the usage string prefixed with "Usage:".
        
        The provided `usage` text is dedented, reindented by two spaces, and wrapped with a leading
        "Usage:" line and a trailing newline so there is a single blank line between the usage
        block and the following help heading when no description is present.
        
        Parameters:
            usage (str): The raw usage text to format.
        
        Returns:
            str: The formatted usage block, including the "Usage:" prefix and surrounding newlines.
        """
        msg = "\nUsage: {}\n".format(self.indent_lines(textwrap.dedent(usage), "  "))
        return msg

    def format_description(self, description: str) -> str:
        # leave full control over description to us
        """
        Format and return the parser description block for help output.
        
        If a non-empty description is provided, this trims a leading newline and trailing
        whitespace, dedents the text, reindents every line with two spaces, and prefixes
        it with a label and colon ("Commands:" when the parser has a `main` attribute,
        otherwise "Description:"). The formatted block is terminated with a single
        trailing newline. Returns an empty string when `description` is falsy.
        """
        if description:
            if hasattr(self.parser, "main"):
                label = "Commands"
            else:
                label = "Description"
            # some doc strings have initial newlines, some don't
            description = description.lstrip("\n")
            # some doc strings have final newlines and spaces, some don't
            description = description.rstrip()
            # dedent, then reindent
            description = self.indent_lines(textwrap.dedent(description), "  ")
            description = f"{label}:\n{description}\n"
            return description
        else:
            return ""

    def format_epilog(self, epilog: str) -> str:
        # leave full control over epilog to us
        """
        Return the provided epilog unchanged, or an empty string if none was given.
        
        Parameters:
            epilog (str): The epilog text to include in the help output.
        
        Returns:
            str: The epilog text as-is when non-empty, otherwise an empty string.
        """
        if epilog:
            return epilog
        else:
            return ""

    def indent_lines(self, text: str, indent: str) -> str:
        """
        Prepend a given indent string to every line of the provided text.
        
        Parameters:
            text (str): The input string, possibly containing multiple lines.
            indent (str): String to prepend to each line (e.g., spaces or tabs).
        
        Returns:
            str: The input text with `indent` prefixed to every line, preserving the original line breaks.
        """
        new_lines = [indent + line for line in text.split("\n")]
        return "\n".join(new_lines)


class UpdatingDefaultsHelpFormatter(PrettyHelpFormatter):
    """Custom help formatter for use in ConfigOptionParser.

    This is updates the defaults before expanding them, allowing
    them to show up correctly in the help listing.

    Also redact auth from url type options
    """

    def expand_default(self, option: optparse.Option) -> str:
        """
        Return the help text for an option's default value, first ensuring parser defaults are updated and redacting credentials from URL defaults.
        
        If this formatter is attached to a ConfigOptionParser, the parser's configuration-driven defaults are refreshed before expanding the option's default. When the option's metavar is "URL", any default URL values (a single string or a list of strings) will have embedded credentials removed in the returned help text. If the parser is absent or the defaults are not a string or list, the standard expanded default text is returned unchanged.
        """
        default_values = None
        if self.parser is not None:
            assert isinstance(self.parser, ConfigOptionParser)
            self.parser._update_defaults(self.parser.defaults)
            assert option.dest is not None
            default_values = self.parser.defaults.get(option.dest)
        help_text = super().expand_default(option)

        if default_values and option.metavar == "URL":
            if isinstance(default_values, str):
                default_values = [default_values]

            # If its not a list, we should abort and just return the help text
            if not isinstance(default_values, list):
                default_values = []

            for val in default_values:
                help_text = help_text.replace(val, redact_auth_from_url(val))

        return help_text


class CustomOptionParser(optparse.OptionParser):
    def insert_option_group(
        self, idx: int, *args: Any, **kwargs: Any
    ) -> optparse.OptionGroup:
        """
        Insert a new OptionGroup at the given index in the parser's option_groups list.
        
        Creates an OptionGroup via add_option_group(...) and places it at the zero-based
        position specified by `idx`, then returns the created group.
        
        Parameters:
            idx (int): Zero-based insertion index.
        
        Returns:
            optparse.OptionGroup: The newly created option group.
        """
        group = self.add_option_group(*args, **kwargs)

        self.option_groups.pop()
        self.option_groups.insert(idx, group)

        return group

    @property
    def option_list_all(self) -> List[optparse.Option]:
        """Get a list of all options, including those in option groups."""
        res = self.option_list[:]
        for i in self.option_groups:
            res.extend(i.option_list)

        return res


class ConfigOptionParser(CustomOptionParser):
    """Custom option parser which updates its defaults by checking the
    configuration files and environmental variables"""

    def __init__(
        self,
        *args: Any,
        name: str,
        isolated: bool = False,
        **kwargs: Any,
    ) -> None:
        """
        Initialize a ConfigOptionParser tied to a named command and its configuration.
        
        Creates and stores a Configuration for this parser (respecting isolation), assigns the parser name to self.name, and then delegates remaining initialization to the superclass.
        
        Parameters:
            name (str): The command/section name used when loading configuration; must be non-empty.
            isolated (bool): If True, create an isolated Configuration (ignore global/user config).
        """
        self.name = name
        self.config = Configuration(isolated)

        assert self.name
        super().__init__(*args, **kwargs)

    def check_default(self, option: optparse.Option, key: str, val: Any) -> Any:
        """
        Validate a configuration default value for a given option.
        
        Calls the option's `check_value` to coerce/validate `val` for the option identified by `key`.
        If validation fails, prints an error message and exits the process with status 3.
        
        Parameters:
            option (optparse.Option): The option object whose `check_value` will be used.
            key (str): The configuration key name (used only for error context passed to `check_value`).
            val (Any): The value from configuration to validate/coerce.
        
        Returns:
            Any: The validated/coerced value as returned by `option.check_value`.
        """
        try:
            return option.check_value(key, val)
        except optparse.OptionValueError as exc:
            print(f"An error occurred during configuration: {exc}")
            sys.exit(3)

    def _get_ordered_configuration_items(
        self,
    ) -> Generator[Tuple[str, Any], None, None]:
        # Configuration gives keys in an unordered manner. Order them.
        """
        Yield configuration (key, value) pairs from the associated Configuration in a deterministic override order.
        
        This iterates over self.config.items(), groups entries by their section (the part before the first '.') and yields (key, value)
        pairs in the explicit override order: "global", the parser's command name (self.name), and ":env:". Empty values are skipped
        and a debug message is logged for each ignored entry. Keys are split on the first dot; the portion after the dot is yielded
        as the key.
        """
        override_order = ["global", self.name, ":env:"]

        # Pool the options into different groups
        section_items: Dict[str, List[Tuple[str, Any]]] = {
            name: [] for name in override_order
        }
        for section_key, val in self.config.items():
            # ignore empty values
            if not val:
                logger.debug(
                    "Ignoring configuration key '%s' as it's value is empty.",
                    section_key,
                )
                continue

            section, key = section_key.split(".", 1)
            if section in override_order:
                section_items[section].append((key, val))

        # Yield each group in their override order
        for section in override_order:
            for key, val in section_items[section]:
                yield key, val

    def _update_defaults(self, defaults: Dict[str, Any]) -> Dict[str, Any]:
        """
        Update a defaults mapping from configuration and environment values.
        
        This applies configuration items (from _get_ordered_configuration_items) to the provided
        defaults dict, converting values to the appropriate types for the matching Option
        and handling several option actions specially:
        - store_true / store_false: coerced to boolean.
        - count: accepts boolean or non-negative integer (booleans map to 0/1 semantics).
        - append: splits whitespace-separated values and validates each item.
        - callback: schedules late evaluation and invokes the option's callback with the
          converted value.
        
        Side effects:
        - Mutates the provided `defaults` mapping in place and also assigns to `self.values`
          temporarily while processing complex/defaulted state; `self.values` is cleared
          before returning.
        - May call `self.error(...)` for invalid configuration values (which handles termination
          according to the parser's error semantics).
        
        Parameters:
            defaults (Dict[str, Any]): Existing option defaults to update.
        
        Returns:
            Dict[str, Any]: The same `defaults` mapping updated with configuration-derived values.
        """

        # Accumulate complex default state.
        self.values = optparse.Values(self.defaults)
        late_eval = set()
        # Then set the options with those values
        for key, val in self._get_ordered_configuration_items():
            # '--' because configuration supports only long names
            option = self.get_option("--" + key)

            # Ignore options not present in this parser. E.g. non-globals put
            # in [global] by users that want them to apply to all applicable
            # commands.
            if option is None:
                continue

            assert option.dest is not None
            if option.action in ("store_true", "store_false"):
                try:
                    val = strtobool(val)
                except ValueError:
                    self.error(
                        f"Invalid value for {key} option, "
                        "please specify a boolean value like yes/no, "
                        "true/false or 1/0 instead."
                    )
            elif option.action == "count":
                with suppress(ValueError):
                    val = strtobool(val)
                with suppress(ValueError):
                    val = int(val)
                if not isinstance(val, int) or val < 0:
                    self.error(
                        f"Invalid value for {key} option, "
                        "please instead specify either a non-negative integer "
                        "or a boolean value like yes/no or false/true "
                        "which is equivalent to 1/0."
                    )
            elif option.action == "append":
                val = val.split()
                val = [self.check_default(option, key, v) for v in val]
            elif option.action == "callback":
                assert option.callback is not None
                late_eval.add(option.dest)
                opt_str = option.get_opt_string()
                val = option.convert_value(opt_str, val)
                # From take_action
                args = option.callback_args or ()
                kwargs = option.callback_kwargs or {}
                option.callback(option, opt_str, val, self, *args, **kwargs)
            else:
                val = self.check_default(option, key, val)

            defaults[option.dest] = val

        for key in late_eval:
            defaults[key] = getattr(self.values, key)
        self.values = None
        return defaults

    def get_default_values(self) -> optparse.Values:
        """
        Return an optparse.Values object containing the parser's default values, with configuration-based overrides applied.
        
        If process_default_values is False this returns Values built directly from the parser's stored defaults (pre-Optik behavior). Otherwise the method loads the Configuration, updates defaults from configuration (via _update_defaults), and coerces string defaults to their option types using option.check_value.
        
        Exits the process with UNKNOWN_ERROR if loading the configuration fails.
        """
        if not self.process_default_values:
            # Old, pre-Optik 1.5 behaviour.
            return optparse.Values(self.defaults)

        # Load the configuration, or error out in case of an error
        try:
            self.config.load()
        except ConfigurationError as err:
            self.exit(UNKNOWN_ERROR, str(err))

        defaults = self._update_defaults(self.defaults.copy())  # ours
        for option in self._get_all_options():
            assert option.dest is not None
            default = defaults.get(option.dest)
            if isinstance(default, str):
                opt_str = option.get_opt_string()
                defaults[option.dest] = option.check_value(opt_str, default)
        return optparse.Values(defaults)

    def error(self, msg: str) -> None:
        """
        Print the parser usage to stderr and terminate the process with an error message.
        
        This writes the parser's usage text to stderr and then exits the program with the
        UNKNOWN_ERROR status code after printing `msg` followed by a newline.
        
        Parameters:
            msg (str): Error message to display to the user.
        """
        self.print_usage(sys.stderr)
        self.exit(UNKNOWN_ERROR, f"{msg}\n")
