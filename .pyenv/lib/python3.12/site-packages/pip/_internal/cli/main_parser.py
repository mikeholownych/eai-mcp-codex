"""A single place for constructing and exposing the main parser
"""

import os
import subprocess
import sys
from typing import List, Optional, Tuple

from pip._internal.build_env import get_runnable_pip
from pip._internal.cli import cmdoptions
from pip._internal.cli.parser import ConfigOptionParser, UpdatingDefaultsHelpFormatter
from pip._internal.commands import commands_dict, get_similar_commands
from pip._internal.exceptions import CommandError
from pip._internal.utils.misc import get_pip_version, get_prog

__all__ = ["create_main_parser", "parse_command"]


def create_main_parser() -> ConfigOptionParser:
    """
    Create and configure and return the main ConfigOptionParser used by pip's CLI.
    
    The returned parser is configured as the global/main entry point:
    - usage set to "%prog <command> [options]".
    - help option not added by default and interspersed args disabled.
    - a version string is attached from get_pip_version().
    - the general option group (cmdoptions.general_group) is added.
    - parser.main is set True so help formatting treats this as the top-level parser.
    - parser.description is populated with a formatted list of available commands and their summaries.
    
    Returns:
        ConfigOptionParser: A fully configured main parser ready for argument parsing.
    """

    parser = ConfigOptionParser(
        usage="\n%prog <command> [options]",
        add_help_option=False,
        formatter=UpdatingDefaultsHelpFormatter(),
        name="global",
        prog=get_prog(),
    )
    parser.disable_interspersed_args()

    parser.version = get_pip_version()

    # add the general options
    gen_opts = cmdoptions.make_option_group(cmdoptions.general_group, parser)
    parser.add_option_group(gen_opts)

    # so the help formatter knows
    parser.main = True  # type: ignore

    # create command listing for description
    description = [""] + [
        f"{name:27} {command_info.summary}"
        for name, command_info in commands_dict.items()
    ]
    parser.description = "\n".join(description)

    return parser


def identify_python_interpreter(python: str) -> Optional[str]:
    # If the named file exists, use it.
    # If it's a directory, assume it's a virtual environment and
    # look for the environment's Python executable.
    """
    Resolve a path or virtual environment directory to a Python interpreter executable.
    
    If `python` names an existing file, that path is returned. If it names an existing
    directory, the function searches for a Python executable inside the directory in
    the locations `bin/python` (Unix) and `Scripts/python.exe` (Windows) and returns
    the first match. If no suitable interpreter is found, returns None.
    
    Parameters:
        python (str): Path to a Python executable or to a virtual environment directory.
    
    Returns:
        Optional[str]: The path to the resolved Python executable, or `None` if not found.
    """
    if os.path.exists(python):
        if os.path.isdir(python):
            # bin/python for Unix, Scripts/python.exe for Windows
            # Try both in case of odd cases like cygwin.
            for exe in ("bin/python", "Scripts/python.exe"):
                py = os.path.join(python, exe)
                if os.path.exists(py):
                    return py
        else:
            return python

    # Could not find the interpreter specified
    return None


def parse_command(args: List[str]) -> Tuple[str, List[str]]:
    """
    Parse top-level pip CLI arguments and determine the selected subcommand.
    
    Given a list of command-line arguments (typically sys.argv[1:]), this function:
    - Splits general/global options from the remaining arguments.
    - Handles special global options:
      - If `--python` is provided, re-invokes pip under the specified interpreter (exits on success or subprocess failure).
      - If `--version` is provided, prints the version and exits.
      - If no subcommand or a lone `help` is provided, prints help and exits.
    - Validates that the first remaining token is a known subcommand and returns the subcommand name and the argument list with the subcommand removed.
    
    Parameters:
        args (List[str]): Command-line arguments to parse (typically sys.argv[1:]; does not include the program name).
    
    Returns:
        Tuple[str, List[str]]: A pair (cmd_name, cmd_args) where `cmd_name` is the resolved subcommand and `cmd_args` is the original argument list with the subcommand removed.
    
    Raises:
        CommandError: If a requested Python interpreter cannot be located, if re-invoking pip under the interpreter fails, or if an unknown subcommand is supplied.
    """
    parser = create_main_parser()

    # Note: parser calls disable_interspersed_args(), so the result of this
    # call is to split the initial args into the general options before the
    # subcommand and everything else.
    # For example:
    #  args: ['--timeout=5', 'install', '--user', 'INITools']
    #  general_options: ['--timeout==5']
    #  args_else: ['install', '--user', 'INITools']
    general_options, args_else = parser.parse_args(args)

    # --python
    if general_options.python and "_PIP_RUNNING_IN_SUBPROCESS" not in os.environ:
        # Re-invoke pip using the specified Python interpreter
        interpreter = identify_python_interpreter(general_options.python)
        if interpreter is None:
            raise CommandError(
                f"Could not locate Python interpreter {general_options.python}"
            )

        pip_cmd = [
            interpreter,
            get_runnable_pip(),
        ]
        pip_cmd.extend(args)

        # Set a flag so the child doesn't re-invoke itself, causing
        # an infinite loop.
        os.environ["_PIP_RUNNING_IN_SUBPROCESS"] = "1"
        returncode = 0
        try:
            proc = subprocess.run(pip_cmd)
            returncode = proc.returncode
        except (subprocess.SubprocessError, OSError) as exc:
            raise CommandError(f"Failed to run pip under {interpreter}: {exc}")
        sys.exit(returncode)

    # --version
    if general_options.version:
        sys.stdout.write(parser.version)
        sys.stdout.write(os.linesep)
        sys.exit()

    # pip || pip help -> print_help()
    if not args_else or (args_else[0] == "help" and len(args_else) == 1):
        parser.print_help()
        sys.exit()

    # the subcommand name
    cmd_name = args_else[0]

    if cmd_name not in commands_dict:
        guess = get_similar_commands(cmd_name)

        msg = [f'unknown command "{cmd_name}"']
        if guess:
            msg.append(f'maybe you meant "{guess}"')

        raise CommandError(" - ".join(msg))

    # all the args without the subcommand
    cmd_args = args[:]
    cmd_args.remove(cmd_name)

    return cmd_name, cmd_args
