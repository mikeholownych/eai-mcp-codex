"""Download files with progress indicators.
"""
import email.message
import logging
import mimetypes
import os
from typing import Iterable, Optional, Tuple

from pip._vendor.requests.models import CONTENT_CHUNK_SIZE, Response

from pip._internal.cli.progress_bars import get_download_progress_renderer
from pip._internal.exceptions import NetworkConnectionError
from pip._internal.models.index import PyPI
from pip._internal.models.link import Link
from pip._internal.network.cache import is_from_cache
from pip._internal.network.session import PipSession
from pip._internal.network.utils import HEADERS, raise_for_status, response_chunks
from pip._internal.utils.misc import format_size, redact_auth_from_url, splitext

logger = logging.getLogger(__name__)


def _get_http_response_size(resp: Response) -> Optional[int]:
    """
    Return the response body size reported by the HTTP `Content-Length` header.
    
    Attempts to read and convert the `Content-Length` response header to an int.
    Returns the integer size if the header is present and a valid integer; otherwise
    returns None when the header is missing or cannot be parsed.
    """
    try:
        return int(resp.headers["content-length"])
    except (ValueError, KeyError, TypeError):
        return None


def _prepare_download(
    resp: Response,
    link: Link,
    progress_bar: str,
) -> Iterable[bytes]:
    """
    Prepare and return an iterable of byte chunks for writing a download, optionally wrapped with a progress renderer.
    
    The function determines the total size from the response, builds a redacted URL for logging (including a human-readable size if known), and logs whether the file is being downloaded or served from cache. It decides whether to show a progress indicator based on log level, cache status, and content length (progress shown when length is unknown or larger than ~40 KB). If progress is enabled, the returned chunk iterable is wrapped with a download progress renderer configured with the given progress_bar type; otherwise the raw response chunk iterator is returned.
    
    Parameters:
        resp: The HTTP response providing headers and a streaming body.
        link: The source Link used to choose a logged URL and a fallback filename.
        progress_bar: Progress bar style identifier passed to the progress renderer.
    
    Returns:
        An iterable yielding bytes (file chunks). The iterable may be the raw response chunk generator or a generator wrapped to render download progress.
    """
    total_length = _get_http_response_size(resp)

    if link.netloc == PyPI.file_storage_domain:
        url = link.show_url
    else:
        url = link.url_without_fragment

    logged_url = redact_auth_from_url(url)

    if total_length:
        logged_url = f"{logged_url} ({format_size(total_length)})"

    if is_from_cache(resp):
        logger.info("Using cached %s", logged_url)
    else:
        logger.info("Downloading %s", logged_url)

    if logger.getEffectiveLevel() > logging.INFO:
        show_progress = False
    elif is_from_cache(resp):
        show_progress = False
    elif not total_length:
        show_progress = True
    elif total_length > (40 * 1000):
        show_progress = True
    else:
        show_progress = False

    chunks = response_chunks(resp, CONTENT_CHUNK_SIZE)

    if not show_progress:
        return chunks

    renderer = get_download_progress_renderer(bar_type=progress_bar, size=total_length)
    return renderer(chunks)


def sanitize_content_filename(filename: str) -> str:
    """
    Return a safe filename derived from a Content-Disposition `filename` value.
    
    Strips any directory components (e.g., "../", absolute paths) and returns only
    the base name to prevent directory traversal when saving the file.
    
    Parameters:
        filename (str): The raw filename value extracted from a Content-Disposition header.
    
    Returns:
        str: The sanitized base filename suitable for use on the local filesystem.
    """
    return os.path.basename(filename)


def parse_content_disposition(content_disposition: str, default_filename: str) -> str:
    """
    Return a safe filename extracted from a Content-Disposition header.
    
    Parses the provided Content-Disposition header value for a `filename`
    parameter (using an email-style parser). If a filename is found it is
    sanitized to remove any path components (preventing directory traversal)
    and returned; otherwise the supplied `default_filename` is returned.
    """
    m = email.message.Message()
    m["content-type"] = content_disposition
    filename = m.get_param("filename")
    if filename:
        # We need to sanitize the filename to prevent directory traversal
        # in case the filename contains ".." path parts.
        filename = sanitize_content_filename(str(filename))
    return filename or default_filename


def _get_http_response_filename(resp: Response, link: Link) -> str:
    """
    Return the best filename for saving the HTTP response.
    
    Starts with link.filename as a fallback. If the response includes a
    Content-Disposition header, its filename parameter is used (via
    parse_content_disposition). If the chosen name lacks an extension, the
    function attempts to guess one from the response Content-Type header; if
    still missing and the response URL differs from the request URL (for
    example after redirects), the extension from the response URL is used.
    Returns the resulting filename (may be unchanged from link.filename).
    """
    filename = link.filename  # fallback
    # Have a look at the Content-Disposition header for a better guess
    content_disposition = resp.headers.get("content-disposition")
    if content_disposition:
        filename = parse_content_disposition(content_disposition, filename)
    ext: Optional[str] = splitext(filename)[1]
    if not ext:
        ext = mimetypes.guess_extension(resp.headers.get("content-type", ""))
        if ext:
            filename += ext
    if not ext and link.url != resp.url:
        ext = os.path.splitext(resp.url)[1]
        if ext:
            filename += ext
    return filename


def _http_get_download(session: PipSession, link: Link) -> Response:
    """
    Perform an HTTP GET for the given link (fragment removed) with streaming enabled.
    
    The URL fragment (portion after '#') is stripped before making the request. The request uses module-standard headers and returns a streaming Response suitable for iterating over content chunks. Non-success HTTP responses cause raise_for_status to raise an error.
    Returns:
        Response: The HTTP response object with stream=True.
    """
    target_url = link.url.split("#", 1)[0]
    resp = session.get(target_url, headers=HEADERS, stream=True)
    raise_for_status(resp)
    return resp


class Downloader:
    def __init__(
        self,
        session: PipSession,
        progress_bar: str,
    ) -> None:
        """
        Initialize the downloader.
        
        Stores the provided session for performing HTTP requests and records the
        progress_bar type to control how download progress is rendered (e.g. 'auto',
        'off', or 'on').
        """
        self._session = session
        self._progress_bar = progress_bar

    def __call__(self, link: Link, location: str) -> Tuple[str, str]:
        """
        Download the resource pointed to by `link` and save it into the given directory.
        
        The downloaded file's name is determined from the HTTP response (Content-Disposition,
        Content-Type, or the link) and the file is written to `os.path.join(location, filename)`.
        
        Parameters:
            link: The Link describing the remote resource to fetch.
            location: Filesystem directory where the downloaded file will be written.
        
        Returns:
            A tuple (filepath, content_type) where `filepath` is the full path to the saved file
            and `content_type` is the response's Content-Type header (or an empty string if absent).
        
        Raises:
            NetworkConnectionError: If the HTTP request fails (propagated from the underlying fetch).
        """
        try:
            resp = _http_get_download(self._session, link)
        except NetworkConnectionError as e:
            assert e.response is not None
            logger.critical(
                "HTTP error %s while getting %s", e.response.status_code, link
            )
            raise

        filename = _get_http_response_filename(resp, link)
        filepath = os.path.join(location, filename)

        chunks = _prepare_download(resp, link, self._progress_bar)
        with open(filepath, "wb") as content_file:
            for chunk in chunks:
                content_file.write(chunk)
        content_type = resp.headers.get("Content-Type", "")
        return filepath, content_type


class BatchDownloader:
    def __init__(
        self,
        session: PipSession,
        progress_bar: str,
    ) -> None:
        """
        Initialize the downloader.
        
        Stores the provided session for performing HTTP requests and records the
        progress_bar type to control how download progress is rendered (e.g. 'auto',
        'off', or 'on').
        """
        self._session = session
        self._progress_bar = progress_bar

    def __call__(
        self, links: Iterable[Link], location: str
    ) -> Iterable[Tuple[Link, Tuple[str, str]]]:
        """
        Download each Link in `links` into the given directory and yield results.
        
        Iterates over `links`, performs an HTTP GET for each, determines a filename from the response and link, writes the response body to a file under `location` (binary mode), and yields (link, (filepath, content_type)) for each successful download. `location` is treated as the target directory path.
        
        On HTTP connection errors, logs a critical message and re-raises the NetworkConnectionError.
        """
        for link in links:
            try:
                resp = _http_get_download(self._session, link)
            except NetworkConnectionError as e:
                assert e.response is not None
                logger.critical(
                    "HTTP error %s while getting %s",
                    e.response.status_code,
                    link,
                )
                raise

            filename = _get_http_response_filename(resp, link)
            filepath = os.path.join(location, filename)

            chunks = _prepare_download(resp, link, self._progress_bar)
            with open(filepath, "wb") as content_file:
                for chunk in chunks:
                    content_file.write(chunk)
            content_type = resp.headers.get("Content-Type", "")
            yield link, (filepath, content_type)
