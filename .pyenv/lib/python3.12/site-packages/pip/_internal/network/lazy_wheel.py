"""Lazy ZIP over HTTP"""

__all__ = ["HTTPRangeRequestUnsupported", "dist_from_wheel_url"]

from bisect import bisect_left, bisect_right
from contextlib import contextmanager
from tempfile import NamedTemporaryFile
from typing import Any, Dict, Generator, List, Optional, Tuple
from zipfile import BadZipFile, ZipFile

from pip._vendor.packaging.utils import canonicalize_name
from pip._vendor.requests.models import CONTENT_CHUNK_SIZE, Response

from pip._internal.metadata import BaseDistribution, MemoryWheel, get_wheel_distribution
from pip._internal.network.session import PipSession
from pip._internal.network.utils import HEADERS, raise_for_status, response_chunks


class HTTPRangeRequestUnsupported(Exception):
    pass


def dist_from_wheel_url(name: str, url: str, session: PipSession) -> BaseDistribution:
    """
    Create and return a BaseDistribution for a wheel available at the given URL by fetching only the metadata via HTTP range requests.
    
    The function opens the remote wheel with a LazyZipOverHTTP-backed file-like object and wraps it with MemoryWheel to extract distribution metadata without downloading the entire archive. The provided package name is canonicalized before producing the distribution.
    
    Parameters:
        name: The package name corresponding to the wheel; it will be canonicalized.
        url: The URL of the wheel file.
    
    Returns:
        A BaseDistribution constructed from the wheel's metadata.
    
    Raises:
        HTTPRangeRequestUnsupported: If the remote server does not support HTTP byte-range requests.
    """
    with LazyZipOverHTTP(url, session) as zf:
        # For read-only ZIP files, ZipFile only needs methods read,
        # seek, seekable and tell, not the whole IO protocol.
        wheel = MemoryWheel(zf.name, zf)  # type: ignore
        # After context manager exit, wheel.name
        # is an invalid file by intention.
        return get_wheel_distribution(wheel, canonicalize_name(name))


class LazyZipOverHTTP:
    """File-like object mapped to a ZIP file over HTTP.

    This uses HTTP range requests to lazily fetch the file's content,
    which is supposed to be fed to ZipFile.  If such requests are not
    supported by the server, raise HTTPRangeRequestUnsupported
    during initialization.
    """

    def __init__(
        self, url: str, session: PipSession, chunk_size: int = CONTENT_CHUNK_SIZE
    ) -> None:
        """
        Initialize a LazyZipOverHTTP that provides file-like, random access to a remote ZIP via HTTP range requests.
        
        Performs a HEAD request to determine the remote resource length and whether the server supports byte ranges, allocates a local temporary file sized to the remote Content-Length, initializes internal tracking for downloaded byte intervals, and validates that the remote resource is a ZIP by progressively fetching portions as needed.
        
        Parameters:
            url (str): The URL of the remote wheel/ZIP file.
            chunk_size (int): Maximum size, in bytes, of each range download request (defaults to CONTENT_CHUNK_SIZE).
        
        Raises:
            HTTPRangeRequestUnsupported: If the server does not advertise support for byte-range requests.
            requests.HTTPError: If the initial HEAD request returns a non-success status (propagated via raise_for_status).
        """
        head = session.head(url, headers=HEADERS)
        raise_for_status(head)
        assert head.status_code == 200
        self._session, self._url, self._chunk_size = session, url, chunk_size
        self._length = int(head.headers["Content-Length"])
        self._file = NamedTemporaryFile()
        self.truncate(self._length)
        self._left: List[int] = []
        self._right: List[int] = []
        if "bytes" not in head.headers.get("Accept-Ranges", "none"):
            raise HTTPRangeRequestUnsupported("range request is not supported")
        self._check_zip()

    @property
    def mode(self) -> str:
        """Opening mode, which is always rb."""
        return "rb"

    @property
    def name(self) -> str:
        """Path to the underlying file."""
        return self._file.name

    def seekable(self) -> bool:
        """Return whether random access is supported, which is True."""
        return True

    def close(self) -> None:
        """
        Close the underlying temporary file and release associated resources.
        
        After calling this, the LazyZipOverHTTP object is no longer usable for I/O.
        """
        self._file.close()

    @property
    def closed(self) -> bool:
        """Whether the file is closed."""
        return self._file.closed

    def read(self, size: int = -1) -> bytes:
        """
        Read up to `size` bytes and return them, downloading any missing ranges from the remote wheel as needed.
        
        If `size` is -1 (the default), read until EOF. To satisfy the request this method will ensure a chunk of data (at least `self._chunk_size`) covering the requested range is downloaded into the local temporary cache; the implementation may therefore download additional bytes preceding the requested position. The returned bytes may be smaller than `size` if EOF is reached.
        
        Note: calling this method can perform HTTP range requests and write to the underlying temporary file.
        """
        download_size = max(size, self._chunk_size)
        start, length = self.tell(), self._length
        stop = length if size < 0 else min(start + download_size, length)
        start = max(0, stop - download_size)
        self._download(start, stop - 1)
        return self._file.read(size)

    def readable(self) -> bool:
        """Return whether the file is readable, which is True."""
        return True

    def seek(self, offset: int, whence: int = 0) -> int:
        """
        Change the stream position and return the new absolute position.
        
        Moves the file pointer to a new location, computed from `offset` and `whence`:
        - whence=0: from start of stream (offset must be >= 0)
        - whence=1: from current position (offset may be negative)
        - whence=2: from end of stream (offset is typically negative)
        
        Returns:
            The new absolute byte position within the stream.
        """
        return self._file.seek(offset, whence)

    def tell(self) -> int:
        """Return the current position."""
        return self._file.tell()

    def truncate(self, size: Optional[int] = None) -> int:
        """
        Truncate the underlying temporary file to the given size.
        
        If size is None, the file is truncated to the current stream position. The current stream position is not modified.
        
        Parameters:
            size (Optional[int]): New size in bytes, or None to use the current position.
        
        Returns:
            int: The new size of the file in bytes.
        """
        return self._file.truncate(size)

    def writable(self) -> bool:
        """Return False."""
        return False

    def __enter__(self) -> "LazyZipOverHTTP":
        """
        Enter context manager, ensuring the underlying temporary cache file is opened and returning this LazyZipOverHTTP instance.
        
        Returns:
            LazyZipOverHTTP: self, now usable as a context-managed file-like object.
        """
        self._file.__enter__()
        return self

    def __exit__(self, *exc: Any) -> None:
        """
        Exit the context by delegating to the underlying temporary file's __exit__.
        
        Forwards the exception information (if any) to the underlying file object. This method does not suppress exceptions.
        """
        self._file.__exit__(*exc)

    @contextmanager
    def _stay(self) -> Generator[None, None, None]:
        """
        Context manager that preserves and restores the file position.
        
        Use in a `with` statement to ensure the stream's current position is restored when the block exits.
        Yields nothing.
        """
        pos = self.tell()
        try:
            yield
        finally:
            self.seek(pos)

    def _check_zip(self) -> None:
        """
        Progressively download trailing chunks of the remote file until it can be opened as a valid ZIP.
        
        This attempts to validate the remote file as a ZIP by repeatedly downloading ranges that extend from
        a moving start position to the file end (in chunk-sized steps) and trying to instantiate ZipFile(self).
        The method preserves the caller's file position while probing. It stops as soon as ZipFile can be
        created successfully. Any HTTP or response errors raised by the underlying downloads are propagated;
        BadZipFile exceptions while probing are handled internally to indicate more data is required.
        """
        end = self._length - 1
        for start in reversed(range(0, end, self._chunk_size)):
            self._download(start, end)
            with self._stay():
                try:
                    # For read-only ZIP files, ZipFile only needs
                    # methods read, seek, seekable and tell.
                    ZipFile(self)  # type: ignore
                except BadZipFile:
                    pass
                else:
                    break

    def _stream_response(
        self, start: int, end: int, base_headers: Dict[str, str] = HEADERS
    ) -> Response:
        """
        Issue a HTTP GET range request for the byte interval [start, end] (inclusive) and return the streaming Response.
        
        Parameters:
            start (int): Starting byte offset (inclusive).
            end (int): Ending byte offset (inclusive).
            base_headers (Dict[str, str]): Base headers to copy and augment for the request.
        
        Returns:
            requests.Response: A streaming response for the requested byte range.
        """
        headers = base_headers.copy()
        headers["Range"] = f"bytes={start}-{end}"
        # TODO: Get range requests to be correctly cached
        headers["Cache-Control"] = "no-cache"
        return self._session.get(self._url, headers=headers, stream=True)

    def _merge(
        self, start: int, end: int, left: int, right: int
    ) -> Generator[Tuple[int, int], None, None]:
        """
        Yield the sub-intervals within [start, end] (inclusive) that still need to be downloaded, and update the tracked downloaded interval lists.
        
        Given the requested byte interval [start, end] and indices left/right selecting the overlapping ranges in self._left and self._right, this function:
        - Yields (s, e) pairs for each missing sub-interval (inclusive bounds) that are not already covered by the existing downloaded ranges.
        - Merges the requested range with the selected existing ranges and replaces self._left[left:right], self._right[left:right] with a single merged interval covering the full combined span.
        
        Parameters:
            start (int): Requested interval start (byte index).
            end (int): Requested interval end (byte index), inclusive.
            left (int): Index of the first entry in self._left/_right that may overlap the requested range.
            right (int): Index after the last entry in self._left/_right that may overlap the requested range.
        
        Yields:
            Tuple[int, int]: Missing sub-intervals to fetch, as (start, end) inclusive.
        """
        lslice, rslice = self._left[left:right], self._right[left:right]
        i = start = min([start] + lslice[:1])
        end = max([end] + rslice[-1:])
        for j, k in zip(lslice, rslice):
            if j > i:
                yield i, j - 1
            i = k + 1
        if i <= end:
            yield i, end
        self._left[left:right], self._right[left:right] = [start], [end]

    def _download(self, start: int, end: int) -> None:
        """
        Download the byte range [start, end] (inclusive) from the remote URL and write it into the local cache.
        
        Preserves and restores the current file position while downloading. Missing sub-ranges within [start, end] are computed via the internal merge logic and fetched with HTTP range requests; downloaded data is written at the corresponding offsets in the temporary file. HTTP errors from the range requests are propagated (response.raise_for_status()).
        
        Parameters:
            start (int): Starting byte index (inclusive).
            end (int): Ending byte index (inclusive).
        """
        with self._stay():
            left = bisect_left(self._right, start)
            right = bisect_right(self._left, end)
            for start, end in self._merge(start, end, left, right):
                response = self._stream_response(start, end)
                response.raise_for_status()
                self.seek(start)
                for chunk in response_chunks(response, self._chunk_size):
                    self._file.write(chunk)
