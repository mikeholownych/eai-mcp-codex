"""HTTP cache implementation.
"""

import os
from contextlib import contextmanager
from datetime import datetime
from typing import BinaryIO, Generator, Optional, Union

from pip._vendor.cachecontrol.cache import SeparateBodyBaseCache
from pip._vendor.cachecontrol.caches import SeparateBodyFileCache
from pip._vendor.requests.models import Response

from pip._internal.utils.filesystem import adjacent_tmp_file, replace
from pip._internal.utils.misc import ensure_dir


def is_from_cache(response: Response) -> bool:
    """
    Return True if the given response was served from the cache.
    
    Checks the `from_cache` attribute on the response object and returns its truthiness.
    If the attribute is absent, returns False.
    
    Parameters:
        response (Response): Response object (or similar) that may have a `from_cache` attribute.
    
    Returns:
        bool: True if the response indicates it came from cache, otherwise False.
    """
    return getattr(response, "from_cache", False)


@contextmanager
def suppressed_cache_errors() -> Generator[None, None, None]:
    """
    Context manager that suppresses OSError raised during cache operations.
    
    Use around filesystem cache reads/writes to treat cache failures as non-fatal;
    any OSError raised inside the context is caught and ignored, allowing normal
    processing to continue as if caching were disabled.
    """
    try:
        yield
    except OSError:
        pass


class SafeFileCache(SeparateBodyBaseCache):
    """
    A file based cache which is safe to use even when the target directory may
    not be accessible or writable.

    There is a race condition when two processes try to write and/or read the
    same entry at the same time, since each entry consists of two separate
    files (https://github.com/psf/cachecontrol/issues/324).  We therefore have
    additional logic that makes sure that both files to be present before
    returning an entry; this fixes the read side of the race condition.

    For the write side, we assume that the server will only ever return the
    same data for the same URL, which ought to be the case for files pip is
    downloading.  PyPI does not have a mechanism to swap out a wheel for
    another wheel, for example.  If this assumption is not true, the
    CacheControl issue will need to be fixed.
    """

    def __init__(self, directory: str) -> None:
        """
        Initialize the SafeFileCache with a filesystem directory for storing cache entries.
        
        Parameters:
            directory (str): Filesystem path to the cache directory. Must not be None; stored for use by cache operations.
        """
        assert directory is not None, "Cache directory must not be None."
        super().__init__()
        self.directory = directory

    def _get_cache_path(self, name: str) -> str:
        # From cachecontrol.caches.file_cache.FileCache._fn, brought into our
        # class for backwards-compatibility and to avoid using a non-public
        # method.
        """
        Return the filesystem path for a cache entry key.
        
        The key `name` is encoded into a hash and stored under a nested directory structure:
        the first five characters of the hash become directory components and the full hash
        is the final filename, all rooted at the cache directory.
        
        Parameters:
            name (str): Cache entry key (typically a URL or cache key).
        
        Returns:
            str: Absolute path where the cache entry for `name` should be stored.
        """
        hashed = SeparateBodyFileCache.encode(name)
        parts = list(hashed[:5]) + [hashed]
        return os.path.join(self.directory, *parts)

    def get(self, key: str) -> Optional[bytes]:
        # The cache entry is only valid if both metadata and body exist.
        """
        Return the cached metadata bytes for `key` if a complete entry exists, otherwise None.
        
        A cache entry is considered valid only when both the metadata file and the corresponding
        `.body` file exist. If either file is missing, or an OSError occurs while reading the
        metadata file, None is returned (I/O errors are suppressed to allow operation to continue
        as if caching is unavailable).
        """
        metadata_path = self._get_cache_path(key)
        body_path = metadata_path + ".body"
        if not (os.path.exists(metadata_path) and os.path.exists(body_path)):
            return None
        with suppressed_cache_errors():
            with open(metadata_path, "rb") as f:
                return f.read()

    def _write(self, path: str, data: bytes) -> None:
        """
        Write bytes to `path` atomically, creating parent directories as needed.
        
        This writes `data` to a temporary adjacent file and then atomically replaces `path`
        with the temporary file. All filesystem operations are executed inside the
        cache-error suppression context so OSErrors (e.g., permission or IO errors)
        are swallowed rather than propagated.
        
        Parameters:
            path (str): Filesystem path to write to (target file).
            data (bytes): Binary content to write.
        
        Returns:
            None
        """
        with suppressed_cache_errors():
            ensure_dir(os.path.dirname(path))

            with adjacent_tmp_file(path) as f:
                f.write(data)

            replace(f.name, path)

    def set(
        self, key: str, value: bytes, expires: Union[int, datetime, None] = None
    ) -> None:
        """
        Store the metadata bytes for a cache entry identified by `key`.
        
        Writes `value` to the cache location computed for `key`. The optional `expires`
        argument is accepted for API compatibility but ignored by this implementation.
        """
        path = self._get_cache_path(key)
        self._write(path, value)

    def delete(self, key: str) -> None:
        """
        Remove cache entry files (metadata and body) for the given key.
        
        Attempts to remove both the metadata file and the corresponding `.body` file for the cache key.
        Any OSError that occurs during removal (for example, file not found or permission errors) is
        suppressed so callers can continue as if caching failed.
        
        Parameters:
            key (str): Cache key identifying the entry to delete.
        """
        path = self._get_cache_path(key)
        with suppressed_cache_errors():
            os.remove(path)
        with suppressed_cache_errors():
            os.remove(path + ".body")

    def get_body(self, key: str) -> Optional[BinaryIO]:
        # The cache entry is only valid if both metadata and body exist.
        """
        Return a binary file object for the cached response body if the cache entry exists.
        
        Checks that both the metadata and corresponding `.body` file exist for `key`. If they do, opens and returns the body file in binary-read mode; if either file is missing, returns None.
        
        Parameters:
            key (str): Cache key.
        
        Returns:
            Optional[BinaryIO]: Open file object for reading the cached body, or None if the entry is incomplete.
            
        Notes:
            The caller is responsible for closing the returned file object. I/O errors during open are suppressed and will result in None.
        """
        metadata_path = self._get_cache_path(key)
        body_path = metadata_path + ".body"
        if not (os.path.exists(metadata_path) and os.path.exists(body_path)):
            return None
        with suppressed_cache_errors():
            return open(body_path, "rb")

    def set_body(self, key: str, body: bytes) -> None:
        """
        Store the response body bytes for a cache entry.
        
        Writes `body` to the cache's corresponding ".body" file for `key`. The write is performed atomically (via a temporary adjacent file and replace) and OSErrors during the operation are suppressed so cache failures do not raise.
        """
        path = self._get_cache_path(key) + ".body"
        self._write(path, body)
