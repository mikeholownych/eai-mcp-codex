"""Network Authentication Helpers

Contains interface (MultiDomainBasicAuth) and associated glue code for
providing credentials in the context of network requests.
"""
import logging
import os
import shutil
import subprocess
import sysconfig
import typing
import urllib.parse
from abc import ABC, abstractmethod
from functools import lru_cache
from os.path import commonprefix
from pathlib import Path
from typing import Any, Dict, List, NamedTuple, Optional, Tuple

from pip._vendor.requests.auth import AuthBase, HTTPBasicAuth
from pip._vendor.requests.models import Request, Response
from pip._vendor.requests.utils import get_netrc_auth

from pip._internal.utils.logging import getLogger
from pip._internal.utils.misc import (
    ask,
    ask_input,
    ask_password,
    remove_auth_from_url,
    split_auth_netloc_from_url,
)
from pip._internal.vcs.versioncontrol import AuthInfo

logger = getLogger(__name__)

KEYRING_DISABLED = False


class Credentials(NamedTuple):
    url: str
    username: str
    password: str


class KeyRingBaseProvider(ABC):
    """Keyring base provider interface"""

    has_keyring: bool

    @abstractmethod
    def get_auth_info(self, url: str, username: Optional[str]) -> Optional[AuthInfo]:
        """
        Return stored credentials for the given service URL and optional username.
        
        If a matching credential pair is available, return an (username, password) tuple; otherwise return None.
        When `username` is None, implementations may attempt to look up any credential associated with `url` (if supported by the backend). The `url` argument is used as the key/service name for the keyring lookup and may be a full URL or a normalized service identifier depending on the provider implementation.
        """
        ...

    @abstractmethod
    def save_auth_info(self, url: str, username: str, password: str) -> None:
        """
        Save credentials to the system keyring using the configured keyring CLI.
        
        Invokes the keyring CLI to store the given password for the service identified by `url`
        and the specified `username`. The password is written to the CLI's stdin using UTF-8.
        
        Parameters:
            url (str): Service name or URL used as the keyring "service".
            username (str): Account name to associate the password with.
            password (str): Password to store.
        
        Raises:
            subprocess.CalledProcessError: If the keyring CLI exits with a non-zero status.
            OSError: If an I/O error occurs while invoking the CLI or writing to its stdin.
        """
        ...


class KeyRingNullProvider(KeyRingBaseProvider):
    """Keyring null provider"""

    has_keyring = False

    def get_auth_info(self, url: str, username: Optional[str]) -> Optional[AuthInfo]:
        """
        Always returns None; this provider represents the absence of a keyring backend.
        
        Parameters:
            url (str): Ignored.
            username (Optional[str]): Ignored.
        
        Returns:
            None: No credentials are available from this provider.
        """
        return None

    def save_auth_info(self, url: str, username: str, password: str) -> None:
        """
        No-op placeholder for saving credentials when no keyring backend is available.
        
        This implementation intentionally does nothing; it's used by the null keyring provider to satisfy the
        KeyRingBaseProvider interface. The provided `url`, `username`, and `password` arguments are ignored.
        """
        return None


class KeyRingPythonProvider(KeyRingBaseProvider):
    """Keyring interface which uses locally imported `keyring`"""

    has_keyring = True

    def __init__(self) -> None:
        """
        Initialize the Python keyring provider by importing the `keyring` module and storing it on the instance.
        
        This makes the installed keyring library available for subsequent get/set credential operations.
        """
        import keyring

        self.keyring = keyring

    def get_auth_info(self, url: str, username: Optional[str]) -> Optional[AuthInfo]:
        # Support keyring's get_credential interface which supports getting
        # credentials without a username. This is only available for
        # keyring>=15.2.0.
        """
        Retrieve credentials from the configured keyring backend.
        
        Tries to use the keyring backend's `get_credential(url, username)` interface when available (supported since keyring>=15.2.0) which can return credentials even if `username` is None. If `get_credential` is not present, and a `username` is provided, falls back to `get_password(url, username)`.
        
        Parameters:
            url (str): Service name or URL used as the key in the keyring.
            username (Optional[str]): Username to look up; may be None when using backends that support credential lookup without a username.
        
        Returns:
            Optional[AuthInfo]: A tuple (username, password) if credentials are found, otherwise None.
        """
        if hasattr(self.keyring, "get_credential"):
            logger.debug("Getting credentials from keyring for %s", url)
            cred = self.keyring.get_credential(url, username)
            if cred is not None:
                return cred.username, cred.password
            return None

        if username is not None:
            logger.debug("Getting password from keyring for %s", url)
            password = self.keyring.get_password(url, username)
            if password:
                return username, password
        return None

    def save_auth_info(self, url: str, username: str, password: str) -> None:
        """
        Persist the given username and password to the configured keyring backend for the specified service (url).
        
        Parameters:
            url (str): Service name used by the keyring backend (typically the request/index URL or its netloc).
            username (str): Account username to associate with the stored password.
            password (str): Password to store in the keyring.
        """
        self.keyring.set_password(url, username, password)


class KeyRingCliProvider(KeyRingBaseProvider):
    """Provider which uses `keyring` cli

    Instead of calling the keyring package installed alongside pip
    we call keyring on the command line which will enable pip to
    use which ever installation of keyring is available first in
    PATH.
    """

    has_keyring = True

    def __init__(self, cmd: str) -> None:
        """
        Initialize the CLI-based keyring provider.
        
        Parameters:
            cmd (str): Path or command name for the `keyring` CLI executable to invoke.
        """
        self.keyring = cmd

    def get_auth_info(self, url: str, username: Optional[str]) -> Optional[AuthInfo]:
        # This is the default implementation of keyring.get_credential
        # https://github.com/jaraco/keyring/blob/97689324abcf01bd1793d49063e7ca01e03d7d07/keyring/backend.py#L134-L139
        """
        Return username and password retrieved from the keyring CLI for the given service name.
        
        If a username is provided, attempts to obtain the password via the CLI-backed provider and returns an (username, password) tuple if found; otherwise returns None.
        
        Parameters:
            url (str): Service name or URL used as the keyring service identifier.
            username (Optional[str]): Username to look up; if None, no lookup is attempted.
        
        Returns:
            Optional[AuthInfo]: (username, password) tuple when credentials are found, otherwise None.
        """
        if username is not None:
            password = self._get_password(url, username)
            if password is not None:
                return username, password
        return None

    def save_auth_info(self, url: str, username: str, password: str) -> None:
        """
        Persist credentials for the given service name using the configured keyring CLI.
        
        Parameters:
            url (str): Service name or URL used as the keyring service identifier.
            username (str): Account username to associate with the stored password.
            password (str): Password to store in the keyring.
        
        Returns:
            None
        """
        return self._set_password(url, username, password)

    def _get_password(self, service_name: str, username: str) -> Optional[str]:
        """
        Retrieve a password from the keyring CLI for the given service and username.
        
        If the CLI executable is not configured (self.keyring is None) or the
        `keyring get <service> <username>` command exits with a nonâ€‘zero status,
        returns None. On success returns the decoded password string with trailing
        line breaks stripped. The CLI is invoked with PYTHONIOENCODING=utf-8 to
        ensure UTF-8 decoding.
        """
        if self.keyring is None:
            return None

        cmd = [self.keyring, "get", service_name, username]
        env = os.environ.copy()
        env["PYTHONIOENCODING"] = "utf-8"
        res = subprocess.run(
            cmd,
            stdin=subprocess.DEVNULL,
            stdout=subprocess.PIPE,
            env=env,
        )
        if res.returncode:
            return None
        return res.stdout.decode("utf-8").strip(os.linesep)

    def _set_password(self, service_name: str, username: str, password: str) -> None:
        """
        Set a password in the system keyring via the keyring CLI.
        
        If this provider has no CLI configured (self.keyring is None) the call is a no-op.
        Writes the password (UTF-8 encoded with a trailing newline) to the keyring CLI's stdin
        and forces UTF-8 decoding for the subprocess via PYTHONIOENCODING.
        
        Parameters:
            service_name (str): Service identifier passed to the keyring CLI.
            username (str): Account/username passed to the keyring CLI.
            password (str): Password written to the keyring CLI stdin.
        
        Raises:
            subprocess.CalledProcessError: If the keyring CLI exits with a non-zero status.
        """
        if self.keyring is None:
            return None
        env = os.environ.copy()
        env["PYTHONIOENCODING"] = "utf-8"
        subprocess.run(
            [self.keyring, "set", service_name, username],
            input=f"{password}{os.linesep}".encode("utf-8"),
            env=env,
            check=True,
        )
        return None


@lru_cache(maxsize=None)
def get_keyring_provider(provider: str) -> KeyRingBaseProvider:
    """
    Return a KeyRing provider implementation chosen according to `provider`.
    
    Parameters:
        provider (str): Selection strategy for the keyring backend. Recognized values:
            - "import": prefer the Python `keyring` package implementation.
            - "subprocess": prefer the external `keyring` CLI executable.
            - "auto": try the Python package first, fall back to the CLI if available.
            - "disabled": never use a keyring backend.
            Other strings are treated as a request for no keyring support.
    
    Returns:
        KeyRingBaseProvider: An instance of a KeyRing provider (Python-based, CLI-based, or a null/no-op provider).
    
    Notes:
        - If the module-level flag `KEYRING_DISABLED` is set, this function will behave as if "disabled" was requested.
        - The function may emit warnings if an available keyring backend fails to initialize; callers should not rely on exceptions being raised for backend discovery failures.
    """
    logger.verbose("Keyring provider requested: %s", provider)

    # keyring has previously failed and been disabled
    if KEYRING_DISABLED:
        provider = "disabled"
    if provider in ["import", "auto"]:
        try:
            impl = KeyRingPythonProvider()
            logger.verbose("Keyring provider set: import")
            return impl
        except ImportError:
            pass
        except Exception as exc:
            # In the event of an unexpected exception
            # we should warn the user
            msg = "Installed copy of keyring fails with exception %s"
            if provider == "auto":
                msg = msg + ", trying to find a keyring executable as a fallback"
            logger.warning(msg, exc, exc_info=logger.isEnabledFor(logging.DEBUG))
    if provider in ["subprocess", "auto"]:
        cli = shutil.which("keyring")
        if cli and cli.startswith(sysconfig.get_path("scripts")):
            # all code within this function is stolen from shutil.which implementation
            @typing.no_type_check
            def PATH_as_shutil_which_determines_it() -> str:
                """
                Return the PATH string that should be used by shutil.which to search executables.
                
                This returns the value of the PATH environment variable if present. If PATH
                is not set (i.e., os.environ.get("PATH") is None), it falls back to
                os.confstr("CS_PATH") when available; if os.confstr is unavailable or
                CS_PATH is not defined, it falls back to os.defpath. An empty PATH
                environment variable is preserved (os.defpath is not used in that case).
                
                Returns:
                    str: The PATH string to use for locating executables.
                """
                path = os.environ.get("PATH", None)
                if path is None:
                    try:
                        path = os.confstr("CS_PATH")
                    except (AttributeError, ValueError):
                        # os.confstr() or CS_PATH is not available
                        path = os.defpath
                # bpo-35755: Don't use os.defpath if the PATH environment variable is
                # set to an empty string

                return path

            scripts = Path(sysconfig.get_path("scripts"))

            paths = []
            for path in PATH_as_shutil_which_determines_it().split(os.pathsep):
                p = Path(path)
                try:
                    if not p.samefile(scripts):
                        paths.append(path)
                except FileNotFoundError:
                    pass

            path = os.pathsep.join(paths)

            cli = shutil.which("keyring", path=path)

        if cli:
            logger.verbose("Keyring provider set: subprocess with executable %s", cli)
            return KeyRingCliProvider(cli)

    logger.verbose("Keyring provider set: disabled")
    return KeyRingNullProvider()


class MultiDomainBasicAuth(AuthBase):
    def __init__(
        self,
        prompting: bool = True,
        index_urls: Optional[List[str]] = None,
        keyring_provider: str = "auto",
    ) -> None:
        """
        Initialize the MultiDomainBasicAuth instance.
        
        Parameters:
            prompting (bool): If True, allow interactive prompts for missing credentials.
            index_urls (Optional[List[str]]): Optional list of index base URLs used to prefer credentials
                associated with a matching index when resolving credentials for a request.
            keyring_provider (str): Keyring provider selection string (e.g., "auto", "import", "subprocess",
                "disabled") used to configure how credential storage is accessed.
        
        Behavior:
            - Creates an in-memory cache (self.passwords) mapping netloc -> (username, password) pairs.
            - Initializes self._credentials_to_save to hold credentials that the user entered and
              opted to persist to the keyring; these are saved later by calling save_credentials.
        """
        self.prompting = prompting
        self.index_urls = index_urls
        self.keyring_provider = keyring_provider  # type: ignore[assignment]
        self.passwords: Dict[str, AuthInfo] = {}
        # When the user is prompted to enter credentials and keyring is
        # available, we will offer to save them. If the user accepts,
        # this value is set to the credentials they entered. After the
        # request authenticates, the caller should call
        # ``save_credentials`` to save these.
        self._credentials_to_save: Optional[Credentials] = None

    @property
    def keyring_provider(self) -> KeyRingBaseProvider:
        """
        Return the resolved KeyRing provider instance for the configured provider name.
        
        The property's stored provider string (self._keyring_provider) is passed to the cached
        factory `get_keyring_provider`, which returns a KeyRingBaseProvider implementation
        (e.g., Null, Python-backed, or CLI-backed). This ensures the provider instance is
        created and reused according to the factory's caching behavior.
        
        Returns:
            KeyRingBaseProvider: the resolved keyring provider instance.
        """
        return get_keyring_provider(self._keyring_provider)

    @keyring_provider.setter
    def keyring_provider(self, provider: str) -> None:
        # The free function get_keyring_provider has been decorated with
        # functools.cache. If an exception occurs in get_keyring_auth that
        # cache will be cleared and keyring disabled, take that into account
        # if you want to remove this indirection.
        """
        Set the keyring provider identifier used by this instance.
        
        The argument is a provider name (e.g. "auto", "import", "subprocess", "disabled") and is stored as-is.
        Resolution to an actual KeyRing provider instance happens lazily via the `keyring_provider` getter, which uses
        the module-level cached factory `get_keyring_provider`. Changing this string does not automatically clear that
        factory's cache.
        """
        self._keyring_provider = provider

    @property
    def use_keyring(self) -> bool:
        # We won't use keyring when --no-input is passed unless
        # a specific provider is requested because it might require
        # user interaction
        """
        Determine whether a keyring backend should be consulted for credentials.
        
        Returns True when interactive prompting is enabled or when a specific keyring
        provider has been explicitly requested (i.e., the configured provider string
        is not "auto" or "disabled"). Returns False when prompting is disabled and
        the provider is "auto" or "disabled", preventing potential user interaction.
        Returns:
            bool: True if keyring use is allowed, False otherwise.
        """
        return self.prompting or self._keyring_provider not in ["auto", "disabled"]

    def _get_keyring_auth(
        self,
        url: Optional[str],
        username: Optional[str],
    ) -> Optional[AuthInfo]:
        """
        Return credentials (username, password) from the configured keyring for the given URL.
        
        If `url` is falsy, returns None. If `username` is provided, the lookup may be scoped to that username.
        If the keyring backend raises an exception, keyring usage is disabled (global `KEYRING_DISABLED` is set),
        the cached provider factory is cleared, and None is returned.
        
        Returns:
            Optional[AuthInfo]: A (username, password) tuple if found, otherwise None.
        """
        # Do nothing if no url was provided
        if not url:
            return None

        try:
            return self.keyring_provider.get_auth_info(url, username)
        except Exception as exc:
            logger.warning(
                "Keyring is skipped due to an exception: %s",
                str(exc),
            )
            global KEYRING_DISABLED
            KEYRING_DISABLED = True
            get_keyring_provider.cache_clear()
            return None

    def _get_index_url(self, url: str) -> Optional[str]:
        """
        Return the original index URL from self.index_urls that best matches the given request URL.
        
        The provided `url` should have any embedded credentials removed. The method compares
        netloc first and then prefers index URLs whose path shares the deepest common
        prefix with the request URL. If the matching index URL originally contained
        embedded credentials, those credentials are preserved in the returned string.
        
        Returns None when no index URLs are configured, no candidate matches are found,
        or `url` is empty.
        """
        if not url or not self.index_urls:
            return None

        url = remove_auth_from_url(url).rstrip("/") + "/"
        parsed_url = urllib.parse.urlsplit(url)

        candidates = []

        for index in self.index_urls:
            index = index.rstrip("/") + "/"
            parsed_index = urllib.parse.urlsplit(remove_auth_from_url(index))
            if parsed_url == parsed_index:
                return index

            if parsed_url.netloc != parsed_index.netloc:
                continue

            candidate = urllib.parse.urlsplit(index)
            candidates.append(candidate)

        if not candidates:
            return None

        candidates.sort(
            reverse=True,
            key=lambda candidate: commonprefix(
                [
                    parsed_url.path,
                    candidate.path,
                ]
            ).rfind("/"),
        )

        return urllib.parse.urlunsplit(candidates[0])

    def _get_new_credentials(
        self,
        original_url: str,
        *,
        allow_netrc: bool = True,
        allow_keyring: bool = False,
    ) -> AuthInfo:
        """
        Return credentials for original_url by checking multiple sources in priority order.
        
        Checks, in order:
        1. Credentials embedded in the original URL.
        2. Credentials embedded in a matching index URL (from self.index_urls).
        3. netrc entries (if allow_netrc is True).
        4. Keyring (if allow_keyring is True) â€” tries the index URL first, then the request netloc.
        
        Parameters:
            original_url (str): The request URL to resolve credentials for. Used for embedded credentials,
                index-url matching, and netrc lookup.
            allow_netrc (bool): If True, consult netrc for credentials when no complete credentials
                have been found in the URL or index URL.
            allow_keyring (bool): If True, consult the configured keyring provider for credentials
                when no credentials were found via URL/index/netrc. The index URL is checked before
                the raw netloc.
        
        Returns:
            AuthInfo: A (username, password) pair. Returns the first complete username/password found
            from the checked sources. If no source provides both values, returns whatever username/password
            values were discovered (values may be None).
        """
        # Split the credentials and netloc from the url.
        url, netloc, url_user_password = split_auth_netloc_from_url(
            original_url,
        )

        # Start with the credentials embedded in the url
        username, password = url_user_password
        if username is not None and password is not None:
            logger.debug("Found credentials in url for %s", netloc)
            return url_user_password

        # Find a matching index url for this request
        index_url = self._get_index_url(url)
        if index_url:
            # Split the credentials from the url.
            index_info = split_auth_netloc_from_url(index_url)
            if index_info:
                index_url, _, index_url_user_password = index_info
                logger.debug("Found index url %s", index_url)

        # If an index URL was found, try its embedded credentials
        if index_url and index_url_user_password[0] is not None:
            username, password = index_url_user_password
            if username is not None and password is not None:
                logger.debug("Found credentials in index url for %s", netloc)
                return index_url_user_password

        # Get creds from netrc if we still don't have them
        if allow_netrc:
            netrc_auth = get_netrc_auth(original_url)
            if netrc_auth:
                logger.debug("Found credentials in netrc for %s", netloc)
                return netrc_auth

        # If we don't have a password and keyring is available, use it.
        if allow_keyring:
            # The index url is more specific than the netloc, so try it first
            # fmt: off
            kr_auth = (
                self._get_keyring_auth(index_url, username) or
                self._get_keyring_auth(netloc, username)
            )
            # fmt: on
            if kr_auth:
                logger.debug("Found credentials in keyring for %s", netloc)
                return kr_auth

        return username, password

    def _get_url_and_credentials(
        self, original_url: str
    ) -> Tuple[str, Optional[str], Optional[str]]:
        """
        Determine and return the sanitized URL and credentials to use for a request.
        
        This inspects the provided original_url for embedded credentials and may augment or
        replace them with credentials found from index URLs, netrc, keyring, or the instance's
        per-netloc cache. If either username or password is found, both values are normalized:
        missing values are converted to the empty string for caching and for use with
        HTTPBasicAuth. If no credentials are available, the function returns (url_without_credentials, None, None).
        
        Returns:
            Tuple[str, Optional[str], Optional[str]]: A 3-tuple of
            (url_without_credentials, username, password). When credentials are present,
            username and password are non-empty strings (possibly ""), otherwise both are None.
        
        Raises:
            AssertionError: if exactly one of username/password is None (indicates an internal invariant failure).
        """
        url, netloc, _ = split_auth_netloc_from_url(original_url)

        # Try to get credentials from original url
        username, password = self._get_new_credentials(original_url)

        # If credentials not found, use any stored credentials for this netloc.
        # Do this if either the username or the password is missing.
        # This accounts for the situation in which the user has specified
        # the username in the index url, but the password comes from keyring.
        if (username is None or password is None) and netloc in self.passwords:
            un, pw = self.passwords[netloc]
            # It is possible that the cached credentials are for a different username,
            # in which case the cache should be ignored.
            if username is None or username == un:
                username, password = un, pw

        if username is not None or password is not None:
            # Convert the username and password if they're None, so that
            # this netloc will show up as "cached" in the conditional above.
            # Further, HTTPBasicAuth doesn't accept None, so it makes sense to
            # cache the value that is going to be used.
            username = username or ""
            password = password or ""

            # Store any acquired credentials.
            self.passwords[netloc] = (username, password)

        assert (
            # Credentials were found
            (username is not None and password is not None)
            # Credentials were not found
            or (username is None and password is None)
        ), f"Could not load credentials from url: {original_url}"

        return url, username, password

    def __call__(self, req: Request) -> Request:
        # Get credentials for this request
        """
        Prepare a requests.Request by applying credentials and registering a 401 handler.
        
        Strips any embedded credentials from req.url, applies HTTP Basic Auth to the request
        when both username and password are available for the request's netloc, and registers
        the instance's 401 response handler so missing/invalid credentials can be handled on retry.
        
        Parameters:
            req (Request): The outgoing request to modify.
        
        Returns:
            Request: The modified request (URL sanitized, auth applied if credentials were found).
        """
        url, username, password = self._get_url_and_credentials(req.url)

        # Set the url of the request to the url without any credentials
        req.url = url

        if username is not None and password is not None:
            # Send the basic auth with this request
            req = HTTPBasicAuth(username, password)(req)

        # Attach a hook to handle 401 responses
        req.register_hook("response", self.handle_401)

        return req

    # Factored out to allow for easy patching in tests
    def _prompt_for_password(
        self, netloc: str
    ) -> Tuple[Optional[str], Optional[str], bool]:
        """
        Prompt the user for a username and password for the given network location.
        
        If prompting is disabled, returns (None, None, False). Otherwise asks for a username; if the user supplies one and a keyring is available, attempts to retrieve credentials from the keyring and returns them if found. If no keyring credentials are found, prompts for a password.
        
        Parameters:
            netloc (str): Network location (host[:port]) shown in the prompt.
        
        Returns:
            Tuple[Optional[str], Optional[str], bool]:
                - username (str | None): The entered or retrieved username, or None if prompting was skipped/cancelled.
                - password (str | None): The entered or retrieved password, or None if prompting was skipped/cancelled.
                - should_save (bool): True if the returned credentials were entered interactively and should be saved to keyring on success; False if credentials came from keyring or prompting was skipped.
        """
        username = ask_input(f"User for {netloc}: ") if self.prompting else None
        if not username:
            return None, None, False
        if self.use_keyring:
            auth = self._get_keyring_auth(netloc, username)
            if auth and auth[0] is not None and auth[1] is not None:
                return auth[0], auth[1], False
        password = ask_password("Password: ")
        return username, password, True

    # Factored out to allow for easy patching in tests
    def _should_save_password_to_keyring(self) -> bool:
        """
        Decide whether to prompt the user to save the current credentials to the keyring.
        
        Returns True only if prompting is enabled, keyring usage is permitted, a keyring backend is available, and the user explicitly confirms saving by answering "y" to the prompt. Otherwise returns False.
        """
        if (
            not self.prompting
            or not self.use_keyring
            or not self.keyring_provider.has_keyring
        ):
            return False
        return ask("Save credentials to keyring [y/N]: ", ["y", "n"]) == "y"

    def handle_401(self, resp: Response, **kwargs: Any) -> Response:
        # We only care about 401 responses, anything else we want to just
        #   pass through the actual response
        """
        Handle HTTP 401 Unauthorized responses by optionally obtaining new credentials, retrying the request, and optionally saving credentials to keyring.
        
        If the response status is not 401, returns the original response unchanged. For 401 responses this will:
        - Attempt to obtain credentials from keyring if configured.
        - If prompting is enabled and no credentials were found, prompt the user for username/password.
        - Cache the new credentials for the request netloc and, if the user agreed and the keyring is available, mark them to be saved.
        - Consume the original response content and release its connection to allow connection reuse.
        - Attach HTTP Basic Auth to a retry of the original request, register a hook to warn on subsequent 401s, and (when applicable) register a hook to save credentials after a successful retry.
        - Send the retried request, append the original response to the retry's history, and return the new response.
        
        Parameters:
            resp (Response): The original HTTP response to inspect and potentially retry.
            **kwargs: Passed through to the underlying request sender when retrying the request.
        
        Returns:
            Response: The original response if not a 401 or if no retry is performed; otherwise the response from the retried request.
        """
        if resp.status_code != 401:
            return resp

        username, password = None, None

        # Query the keyring for credentials:
        if self.use_keyring:
            username, password = self._get_new_credentials(
                resp.url,
                allow_netrc=False,
                allow_keyring=True,
            )

        # We are not able to prompt the user so simply return the response
        if not self.prompting and not username and not password:
            return resp

        parsed = urllib.parse.urlparse(resp.url)

        # Prompt the user for a new username and password
        save = False
        if not username and not password:
            username, password, save = self._prompt_for_password(parsed.netloc)

        # Store the new username and password to use for future requests
        self._credentials_to_save = None
        if username is not None and password is not None:
            self.passwords[parsed.netloc] = (username, password)

            # Prompt to save the password to keyring
            if save and self._should_save_password_to_keyring():
                self._credentials_to_save = Credentials(
                    url=parsed.netloc,
                    username=username,
                    password=password,
                )

        # Consume content and release the original connection to allow our new
        #   request to reuse the same one.
        # The result of the assignment isn't used, it's just needed to consume
        # the content.
        _ = resp.content
        resp.raw.release_conn()

        # Add our new username and password to the request
        req = HTTPBasicAuth(username or "", password or "")(resp.request)
        req.register_hook("response", self.warn_on_401)

        # On successful request, save the credentials that were used to
        # keyring. (Note that if the user responded "no" above, this member
        # is not set and nothing will be saved.)
        if self._credentials_to_save:
            req.register_hook("response", self.save_credentials)

        # Send our new request
        new_resp = resp.connection.send(req, **kwargs)
        new_resp.history.append(resp)

        return new_resp

    def warn_on_401(self, resp: Response, **kwargs: Any) -> None:
        """Response callback to warn about incorrect credentials."""
        if resp.status_code == 401:
            logger.warning(
                "401 Error, Credentials not correct for %s",
                resp.request.url,
            )

    def save_credentials(self, resp: Response, **kwargs: Any) -> None:
        """
        Save pending credentials to the configured keyring after a successful response.
        
        This response callback will attempt to persist credentials previously marked
        for saving (stored in self._credentials_to_save) using the active keyring
        provider. It clears the pending credentials regardless of outcome.
        
        Conditions:
        - Only runs when a keyring backend is available (self.keyring_provider.has_keyring).
        - Credentials are saved only if `creds` existed and the response status code is < 400.
        
        Any exceptions raised while saving are caught and not propagated.
        """
        assert (
            self.keyring_provider.has_keyring
        ), "should never reach here without keyring"

        creds = self._credentials_to_save
        self._credentials_to_save = None
        if creds and resp.status_code < 400:
            try:
                logger.info("Saving credentials to keyring")
                self.keyring_provider.save_auth_info(
                    creds.url, creds.username, creds.password
                )
            except Exception:
                logger.exception("Failed to save credentials")
