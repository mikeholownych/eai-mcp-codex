import logging
import mimetypes
import os
from collections import defaultdict
from typing import Callable, Dict, Iterable, List, Optional, Tuple

from pip._vendor.packaging.utils import (
    InvalidSdistFilename,
    InvalidVersion,
    InvalidWheelFilename,
    canonicalize_name,
    parse_sdist_filename,
    parse_wheel_filename,
)

from pip._internal.models.candidate import InstallationCandidate
from pip._internal.models.link import Link
from pip._internal.utils.urls import path_to_url, url_to_path
from pip._internal.vcs import is_url

logger = logging.getLogger(__name__)

FoundCandidates = Iterable[InstallationCandidate]
FoundLinks = Iterable[Link]
CandidatesFromPage = Callable[[Link], Iterable[InstallationCandidate]]
PageValidator = Callable[[Link], bool]


class LinkSource:
    @property
    def link(self) -> Optional[Link]:
        """Returns the underlying link, if there's one."""
        raise NotImplementedError()

    def page_candidates(self) -> FoundCandidates:
        """
        Return an iterable of InstallationCandidate objects discovered by parsing the source's HTML index page.
        
        This represents candidates extracted from a page (for example, an index or directory listing) associated with this LinkSource. Implementations should yield zero or more InstallationCandidate instances; the iterable may be lazy.
        """
        raise NotImplementedError()

    def file_links(self) -> FoundLinks:
        """
        Iterate links to distribution files directly exposed by this source.
        
        Yield Link objects that point to distribution archives (wheels, sdists, or other artifact files) that the source can provide without parsing an HTML page. These links are distinct from the candidates produced by page_candidates() â€” implementations may return an empty iterable when no direct file links are available.
        """
        raise NotImplementedError()


def _is_html_file(file_url: str) -> bool:
    """
    Return True if the given file URL appears to be an HTML file based on its MIME type.
    
    The check uses mimetypes.guess_type(..., strict=False) on the URL/path and compares the
    guessed content type to "text/html".
    
    Parameters:
        file_url (str): A file path or URL (typically a filename or URL string) whose MIME
            type will be guessed.
    
    Returns:
        bool: True if the guessed MIME type is "text/html", False otherwise.
    """
    return mimetypes.guess_type(file_url, strict=False)[0] == "text/html"


class _FlatDirectoryToUrls:
    """Scans directory and caches results"""

    def __init__(self, path: str) -> None:
        """
        Initialize the directory scanner state.
        
        Parameters:
            path (str): Filesystem path of the directory to scan. Scanning is deferred until
                the properties that expose results are accessed.
        
        Description:
            Creates empty caches for HTML page URLs and a mapping from canonical project
            names to file URLs, and marks the directory as not yet scanned.
        """
        self._path = path
        self._page_candidates: List[str] = []
        self._project_name_to_urls: Dict[str, List[str]] = defaultdict(list)
        self._scanned_directory = False

    def _scan_directory(self) -> None:
        """
        Scan the directory at self._path once and populate cached listings.
        
        Reads directory entries (os.scandir), converts each entry path to a URL, and updates:
        - self._page_candidates with URLs that appear to be HTML pages.
        - self._project_name_to_urls mapping by parsing distribution filenames:
          - If an entry's filename parses as a wheel or sdist, its URL is appended under the parsed project name.
        Entries that are neither HTML nor valid distribution filenames are ignored. After scanning, sets self._scanned_directory to True.
        
        Side effects:
        - Mutates self._page_candidates (list[str])
        - Mutates self._project_name_to_urls (dict[str, list[str]])
        - Sets self._scanned_directory to True
        
        Returns:
            None
        """
        for entry in os.scandir(self._path):
            url = path_to_url(entry.path)
            if _is_html_file(url):
                self._page_candidates.append(url)
                continue

            # File must have a valid wheel or sdist name,
            # otherwise not worth considering as a package
            try:
                project_filename = parse_wheel_filename(entry.name)[0]
            except (InvalidWheelFilename, InvalidVersion):
                try:
                    project_filename = parse_sdist_filename(entry.name)[0]
                except (InvalidSdistFilename, InvalidVersion):
                    continue

            self._project_name_to_urls[project_filename].append(url)
        self._scanned_directory = True

    @property
    def page_candidates(self) -> List[str]:
        """
        Return the cached list of HTML page URLs found in the directory.
        
        If the directory has not yet been scanned, this will perform a one-time scan to
        collect HTML file URLs (used as index pages) and populate the internal cache.
        
        Returns:
            List[str]: URLs of HTML pages discovered in the directory.
        """
        if not self._scanned_directory:
            self._scan_directory()

        return self._page_candidates

    @property
    def project_name_to_urls(self) -> Dict[str, List[str]]:
        """
        Return a mapping from canonical project names to lists of file URLs found in the directory.
        
        This property triggers a lazy scan of the directory on first access; after scanning, the returned
        dictionary maps each normalized project name to the list of file URLs (as strings) in that
        directory that were recognized as distribution files (wheels or sdists).
        """
        if not self._scanned_directory:
            self._scan_directory()

        return self._project_name_to_urls


class _FlatDirectorySource(LinkSource):
    """Link source specified by ``--find-links=<path-to-dir>``.

    This looks the content of the directory, and returns:

    * ``page_candidates``: Links listed on each HTML file in the directory.
    * ``file_candidates``: Archives in the directory.
    """

    _paths_to_urls: Dict[str, _FlatDirectoryToUrls] = {}

    def __init__(
        self,
        candidates_from_page: CandidatesFromPage,
        path: str,
        project_name: str,
    ) -> None:
        """
        Initialize a FlatDirectory source for a directory specified by path.
        
        Creates or reuses a shared _FlatDirectoryToUrls cache for the given path, stores the
        callback used to extract candidates from an HTML page, and canonicalizes the
        project name used when enumerating per-project file links.
        
        Parameters:
            candidates_from_page: Callable that yields InstallationCandidate objects for a
                given page Link; used by page_candidates().
            path: Filesystem path to the directory. Instances share a cached scan for the same path.
            project_name: Project name (will be canonicalized) used to look up files for this project.
        """
        self._candidates_from_page = candidates_from_page
        self._project_name = canonicalize_name(project_name)

        # Get existing instance of _FlatDirectoryToUrls if it exists
        if path in self._paths_to_urls:
            self._path_to_urls = self._paths_to_urls[path]
        else:
            self._path_to_urls = _FlatDirectoryToUrls(path=path)
            self._paths_to_urls[path] = self._path_to_urls

    @property
    def link(self) -> Optional[Link]:
        """
        Return the associated Link for this source, or None if there is no single link.
        
        This implementation returns None to indicate the source does not represent a single URL/link
        (e.g., a directory-backed source that exposes multiple file links or page candidates).
        
        Returns:
            Optional[Link]: None when the source has no single associated Link.
        """
        return None

    def page_candidates(self) -> FoundCandidates:
        """
        Yield installation candidates discovered by parsing HTML pages in the directory.
        
        For each HTML page URL cached for the directory, invokes the configured
        candidates_from_page callback with a Link built from that URL and yields
        all resulting InstallationCandidate objects.
        """
        for url in self._path_to_urls.page_candidates:
            yield from self._candidates_from_page(Link(url))

    def file_links(self) -> FoundLinks:
        """
        Yield Link objects for every file URL in the directory that matches the source's canonical project name.
        
        Returns an iterable of Link instances for each stored URL associated with the configured project name in the directory's cached mapping.
        """
        for url in self._path_to_urls.project_name_to_urls[self._project_name]:
            yield Link(url)


class _LocalFileSource(LinkSource):
    """``--find-links=<path-or-url>`` or ``--[extra-]index-url=<path-or-url>``.

    If a URL is supplied, it must be a ``file:`` URL. If a path is supplied to
    the option, it is converted to a URL first. This returns:

    * ``page_candidates``: Links listed on an HTML file.
    * ``file_candidates``: The non-HTML file.
    """

    def __init__(
        self,
        candidates_from_page: CandidatesFromPage,
        link: Link,
    ) -> None:
        """
        Initialize a LocalFileSource for a local file link.
        
        Parameters:
            candidates_from_page: Callable used to extract InstallationCandidate objects when the link points to an HTML page.
            link: The Link object representing the local file or file URL stored by this source.
        """
        self._candidates_from_page = candidates_from_page
        self._link = link

    @property
    def link(self) -> Optional[Link]:
        """
        Return the primary Link for this source, or None if the source has no single associated link.
        
        Returns:
            Optional[Link]: The Link associated with this source, or None when the source represents a directory/index or otherwise has no single link.
        """
        return self._link

    def page_candidates(self) -> FoundCandidates:
        """
        Yield installation candidates parsed from the stored local Link if it points to an HTML file.
        
        If the Link's URL does not appear to be HTML (based on MIME/extension heuristics), the method yields nothing.
        Otherwise it delegates to the configured `candidates_from_page` callback and yields the InstallationCandidate items it returns.
        
        Returns:
            Iterable[InstallationCandidate]: An iterable of candidates found on the page; empty if the link is not an HTML file.
        """
        if not _is_html_file(self._link.url):
            return
        yield from self._candidates_from_page(self._link)

    def file_links(self) -> FoundLinks:
        """
        Yield the stored Link when it refers to a non-HTML local file.
        
        If the link's URL appears to be an HTML file (directory listing or HTML page),
        this method yields nothing. Otherwise it yields the single stored Link.
        """
        if _is_html_file(self._link.url):
            return
        yield self._link


class _RemoteFileSource(LinkSource):
    """``--find-links=<url>`` or ``--[extra-]index-url=<url>``.

    This returns:

    * ``page_candidates``: Links listed on an HTML file.
    * ``file_candidates``: The non-HTML file.
    """

    def __init__(
        self,
        candidates_from_page: CandidatesFromPage,
        page_validator: PageValidator,
        link: Link,
    ) -> None:
        """
        Initialize a remote file source.
        
        Parameters:
            candidates_from_page: Callable that, given a Link to a page, yields InstallationCandidate objects found on that page.
            page_validator: Callable that returns True if the given Link should be parsed as a page (allowing candidates_from_page to be invoked).
            link: The Link representing the remote location this source wraps.
        """
        self._candidates_from_page = candidates_from_page
        self._page_validator = page_validator
        self._link = link

    @property
    def link(self) -> Optional[Link]:
        """
        Return the primary Link for this source, or None if the source has no single associated link.
        
        Returns:
            Optional[Link]: The Link associated with this source, or None when the source represents a directory/index or otherwise has no single link.
        """
        return self._link

    def page_candidates(self) -> FoundCandidates:
        """
        Yield installation candidates parsed from the remote page link.
        
        This generator returns candidates produced by the configured `candidates_from_page`
        callback for this source's link only if the configured `page_validator` accepts
        the link; otherwise it yields nothing.
        
        Yields:
            InstallationCandidate: candidates discovered on the remote page.
        """
        if not self._page_validator(self._link):
            return
        yield from self._candidates_from_page(self._link)

    def file_links(self) -> FoundLinks:
        """
        Yield the stored Link as a direct file link.
        
        Returns an iterable containing the single Link associated with this source.
        """
        yield self._link


class _IndexDirectorySource(LinkSource):
    """``--[extra-]index-url=<path-to-directory>``.

    This is treated like a remote URL; ``candidates_from_page`` contains logic
    for this by appending ``index.html`` to the link.
    """

    def __init__(
        self,
        candidates_from_page: CandidatesFromPage,
        link: Link,
    ) -> None:
        """
        Initialize a LocalFileSource for a local file link.
        
        Parameters:
            candidates_from_page: Callable used to extract InstallationCandidate objects when the link points to an HTML page.
            link: The Link object representing the local file or file URL stored by this source.
        """
        self._candidates_from_page = candidates_from_page
        self._link = link

    @property
    def link(self) -> Optional[Link]:
        """
        Return the primary Link for this source, or None if the source has no single associated link.
        
        Returns:
            Optional[Link]: The Link associated with this source, or None when the source represents a directory/index or otherwise has no single link.
        """
        return self._link

    def page_candidates(self) -> FoundCandidates:
        """
        Yield installation candidates found by parsing this source's page link.
        
        Returns an iterable of InstallationCandidate objects produced by calling the configured
        candidates_from_page callback with this source's Link. If the link does not point to an
        HTML/index page the callback may return an empty iterable.
        """
        yield from self._candidates_from_page(self._link)

    def file_links(self) -> FoundLinks:
        """
        Return an empty iterable â€” index-style directory URLs do not expose direct file links.
        
        Returns:
            FoundLinks: An empty iterable (tuple) since this source only yields page candidates.
        """
        return ()


def build_source(
    location: str,
    *,
    candidates_from_page: CandidatesFromPage,
    page_validator: PageValidator,
    expand_dir: bool,
    cache_link_parsing: bool,
    project_name: str,
) -> Tuple[Optional[str], Optional[LinkSource]]:
    """
    Determine the kind of link source represented by `location` and return its URL and a corresponding LinkSource.
    
    Given a location string (a filesystem path, a `file:` URL, or an HTTP(S) URL), this function:
    - Resolves the input to a URL and an optional local filesystem path.
    - Constructs and returns an appropriate LinkSource:
      - _RemoteFileSource for remote URLs (no local path).
      - _LocalFileSource for local files.
      - _FlatDirectorySource for local directories when expand_dir is True (scans the directory for pages and per-project file URLs).
      - _IndexDirectorySource for local directories when expand_dir is False (treat the directory as an index URL).
    - If the location cannot be resolved to a URL, or the resolved path is neither a file nor directory, logs a warning and returns (None, None) or (url, None) respectively.
    
    Parameters:
        candidates_from_page: Callable used to extract InstallationCandidate objects from a page Link.
        page_validator: Callable used to decide whether a page Link should be parsed.
        expand_dir: If True and `location` is a local directory, use a flat-directory source that enumerates files per project; otherwise treat the directory as an index URL.
        cache_link_parsing: Passed to Link creation to control link parsing cache behavior.
        project_name: Project name used to select per-project file links when expanding a directory.
    
    Returns:
        A tuple (url, source) where `url` is the resolved URL string (or None if the location could not be resolved) and `source` is a LinkSource instance appropriate for that location, or None if the location is unsupported.
    """
    path: Optional[str] = None
    url: Optional[str] = None
    if os.path.exists(location):  # Is a local path.
        url = path_to_url(location)
        path = location
    elif location.startswith("file:"):  # A file: URL.
        url = location
        path = url_to_path(location)
    elif is_url(location):
        url = location

    if url is None:
        msg = (
            "Location '%s' is ignored: "
            "it is either a non-existing path or lacks a specific scheme."
        )
        logger.warning(msg, location)
        return (None, None)

    if path is None:
        source: LinkSource = _RemoteFileSource(
            candidates_from_page=candidates_from_page,
            page_validator=page_validator,
            link=Link(url, cache_link_parsing=cache_link_parsing),
        )
        return (url, source)

    if os.path.isdir(path):
        if expand_dir:
            source = _FlatDirectorySource(
                candidates_from_page=candidates_from_page,
                path=path,
                project_name=project_name,
            )
        else:
            source = _IndexDirectorySource(
                candidates_from_page=candidates_from_page,
                link=Link(url, cache_link_parsing=cache_link_parsing),
            )
        return (url, source)
    elif os.path.isfile(path):
        source = _LocalFileSource(
            candidates_from_page=candidates_from_page,
            link=Link(url, cache_link_parsing=cache_link_parsing),
        )
        return (url, source)
    logger.warning(
        "Location '%s' is ignored: it is neither a file nor a directory.",
        location,
    )
    return (url, None)
