import logging
from optparse import Values
from typing import Any, Iterable, List, Optional, Union

from pip._vendor.packaging.version import LegacyVersion, Version

from pip._internal.cli import cmdoptions
from pip._internal.cli.req_command import IndexGroupCommand
from pip._internal.cli.status_codes import ERROR, SUCCESS
from pip._internal.commands.search import print_dist_installation_info
from pip._internal.exceptions import CommandError, DistributionNotFound, PipError
from pip._internal.index.collector import LinkCollector
from pip._internal.index.package_finder import PackageFinder
from pip._internal.models.selection_prefs import SelectionPreferences
from pip._internal.models.target_python import TargetPython
from pip._internal.network.session import PipSession
from pip._internal.utils.misc import write_output

logger = logging.getLogger(__name__)


class IndexCommand(IndexGroupCommand):
    """
    Inspect information available from package indexes.
    """

    ignore_require_venv = True
    usage = """
        %prog versions <package>
    """

    def add_options(self) -> None:
        """
        Register command-line options required by the `index` subcommand.
        
        Adds target-Python related options and the following index-specific options:
        - --ignore-requires-python
        - --pre
        - --no-binary
        - --only-binary
        
        Creates an index option group and inserts the index group and the command options into the parser (at the front) so they appear before other option groups.
        """
        cmdoptions.add_target_python_options(self.cmd_opts)

        self.cmd_opts.add_option(cmdoptions.ignore_requires_python())
        self.cmd_opts.add_option(cmdoptions.pre())
        self.cmd_opts.add_option(cmdoptions.no_binary())
        self.cmd_opts.add_option(cmdoptions.only_binary())

        index_opts = cmdoptions.make_option_group(
            cmdoptions.index_group,
            self.parser,
        )

        self.parser.insert_option_group(0, index_opts)
        self.parser.insert_option_group(0, self.cmd_opts)

    def run(self, options: Values, args: List[str]) -> int:
        """
        Dispatch the requested index subcommand action and return a process exit code.
        
        This method validates the first element of `args` as the requested action (currently only "versions"), emits an experimental-command warning, invokes the corresponding handler with the remaining args, and maps PipError exceptions to an error exit code.
        
        Parameters:
            options (Values): Parsed command options passed to the handler.
            args (List[str]): Command arguments; the first element must be the action name and subsequent elements are passed to the handler.
        
        Returns:
            int: SUCCESS (on successful handler execution) or ERROR (if the action is missing/invalid or a PipError occurs).
        """
        handlers = {
            "versions": self.get_available_package_versions,
        }

        logger.warning(
            "pip index is currently an experimental command. "
            "It may be removed/changed in a future release "
            "without prior warning."
        )

        # Determine action
        if not args or args[0] not in handlers:
            logger.error(
                "Need an action (%s) to perform.",
                ", ".join(sorted(handlers)),
            )
            return ERROR

        action = args[0]

        # Error handling happens here, not in the action-handlers.
        try:
            handlers[action](options, args[1:])
        except PipError as e:
            logger.error(e.args[0])
            return ERROR

        return SUCCESS

    def _build_package_finder(
        self,
        options: Values,
        session: PipSession,
        target_python: Optional[TargetPython] = None,
        ignore_requires_python: Optional[bool] = None,
    ) -> PackageFinder:
        """
        Create and return a PackageFinder configured for the index command.
        
        Builds a LinkCollector from the provided session and options, and constructs
        SelectionPreferences with:
        - allow_yanked=False (yanked releases ignored),
        - allow_all_prereleases derived from options.pre,
        - ignore_requires_python set from the parameter.
        
        Parameters:
            ignore_requires_python: When True, ignore `Requires-Python` metadata when
                selecting candidates; when False, enforce it; when None, use default
                finder behavior.
            target_python: Optional target Python interpreter metadata used to filter
                candidates for compatibility.
        
        Returns:
            PackageFinder: a finder instance using the created LinkCollector and
            selection preferences.
        """
        link_collector = LinkCollector.create(session, options=options)

        # Pass allow_yanked=False to ignore yanked versions.
        selection_prefs = SelectionPreferences(
            allow_yanked=False,
            allow_all_prereleases=options.pre,
            ignore_requires_python=ignore_requires_python,
        )

        return PackageFinder.create(
            link_collector=link_collector,
            selection_prefs=selection_prefs,
            target_python=target_python,
        )

    def get_available_package_versions(self, options: Values, args: List[Any]) -> None:
        """
        List available versions for a given package name from configured package indexes and print the latest plus installation hint.
        
        Requires exactly one positional argument: the package query/name. Uses the provided options to build a session and PackageFinder (respecting options like `pre` and `ignore_requires_python`) and collects candidate versions from all found links. Filters out prereleases unless `options.pre` is true, deduplicates and sorts versions in descending order, then writes the latest and the full list to output and prints installation guidance for the latest version.
        
        Parameters:
            options: Parsed command-line options (controls behavior such as `pre` and `ignore_requires_python`).
            args: Positional arguments; must contain exactly one element â€” the package name/query.
        
        Raises:
            CommandError: If the number of positional arguments is not exactly one.
            DistributionNotFound: If no matching distributions are found for the given query.
        """
        if len(args) != 1:
            raise CommandError("You need to specify exactly one argument")

        target_python = cmdoptions.make_target_python(options)
        query = args[0]

        with self._build_session(options) as session:
            finder = self._build_package_finder(
                options=options,
                session=session,
                target_python=target_python,
                ignore_requires_python=options.ignore_requires_python,
            )

            versions: Iterable[Union[LegacyVersion, Version]] = (
                candidate.version for candidate in finder.find_all_candidates(query)
            )

            if not options.pre:
                # Remove prereleases
                versions = (
                    version for version in versions if not version.is_prerelease
                )
            versions = set(versions)

            if not versions:
                raise DistributionNotFound(
                    f"No matching distribution found for {query}"
                )

            formatted_versions = [str(ver) for ver in sorted(versions, reverse=True)]
            latest = formatted_versions[0]

        write_output(f"{query} ({latest})")
        write_output("Available versions: {}".format(", ".join(formatted_versions)))
        print_dist_installation_info(query, latest)
