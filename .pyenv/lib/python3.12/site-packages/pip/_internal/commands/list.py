import json
import logging
from optparse import Values
from typing import TYPE_CHECKING, Generator, List, Optional, Sequence, Tuple, cast

from pip._vendor.packaging.utils import canonicalize_name

from pip._internal.cli import cmdoptions
from pip._internal.cli.req_command import IndexGroupCommand
from pip._internal.cli.status_codes import SUCCESS
from pip._internal.exceptions import CommandError
from pip._internal.index.collector import LinkCollector
from pip._internal.index.package_finder import PackageFinder
from pip._internal.metadata import BaseDistribution, get_environment
from pip._internal.models.selection_prefs import SelectionPreferences
from pip._internal.network.session import PipSession
from pip._internal.utils.compat import stdlib_pkgs
from pip._internal.utils.misc import tabulate, write_output

if TYPE_CHECKING:
    from pip._internal.metadata.base import DistributionVersion

    class _DistWithLatestInfo(BaseDistribution):
        """Give the distribution object a couple of extra fields.

        These will be populated during ``get_outdated()``. This is dirty but
        makes the rest of the code much cleaner.
        """

        latest_version: DistributionVersion
        latest_filetype: str

    _ProcessedDists = Sequence[_DistWithLatestInfo]


from pip._vendor.packaging.version import parse

logger = logging.getLogger(__name__)


class ListCommand(IndexGroupCommand):
    """
    List installed packages, including editables.

    Packages are listed in a case-insensitive sorted order.
    """

    ignore_require_venv = True
    usage = """
      %prog [options]"""

    def add_options(self) -> None:
        """
        Register command-line options for the `list` command.
        
        Adds flags controlling which installed packages are shown and how they are formatted,
        including:
        - --outdated / -o: show packages with newer available versions.
        - --uptodate / -u: show packages at their latest available version.
        - --editable / -e: include editable projects.
        - --local / -l and --user: scope listing to local (non-global) or user-site installs.
        - --pre: include pre-release and development versions when checking latest versions.
        - --format: choose output format ("columns" (default), "freeze", or "json").
        - --not-required: show only packages that are not dependencies of other installed packages.
        - --exclude-editable / --include-editable: control inclusion of editable packages.
        Also registers path and index-related option groups required by the command.
        """
        self.cmd_opts.add_option(
            "-o",
            "--outdated",
            action="store_true",
            default=False,
            help="List outdated packages",
        )
        self.cmd_opts.add_option(
            "-u",
            "--uptodate",
            action="store_true",
            default=False,
            help="List uptodate packages",
        )
        self.cmd_opts.add_option(
            "-e",
            "--editable",
            action="store_true",
            default=False,
            help="List editable projects.",
        )
        self.cmd_opts.add_option(
            "-l",
            "--local",
            action="store_true",
            default=False,
            help=(
                "If in a virtualenv that has global access, do not list "
                "globally-installed packages."
            ),
        )
        self.cmd_opts.add_option(
            "--user",
            dest="user",
            action="store_true",
            default=False,
            help="Only output packages installed in user-site.",
        )
        self.cmd_opts.add_option(cmdoptions.list_path())
        self.cmd_opts.add_option(
            "--pre",
            action="store_true",
            default=False,
            help=(
                "Include pre-release and development versions. By default, "
                "pip only finds stable versions."
            ),
        )

        self.cmd_opts.add_option(
            "--format",
            action="store",
            dest="list_format",
            default="columns",
            choices=("columns", "freeze", "json"),
            help=(
                "Select the output format among: columns (default), freeze, or json. "
                "The 'freeze' format cannot be used with the --outdated option."
            ),
        )

        self.cmd_opts.add_option(
            "--not-required",
            action="store_true",
            dest="not_required",
            help="List packages that are not dependencies of installed packages.",
        )

        self.cmd_opts.add_option(
            "--exclude-editable",
            action="store_false",
            dest="include_editable",
            help="Exclude editable package from output.",
        )
        self.cmd_opts.add_option(
            "--include-editable",
            action="store_true",
            dest="include_editable",
            help="Include editable package from output.",
            default=True,
        )
        self.cmd_opts.add_option(cmdoptions.list_exclude())
        index_opts = cmdoptions.make_option_group(cmdoptions.index_group, self.parser)

        self.parser.insert_option_group(0, index_opts)
        self.parser.insert_option_group(0, self.cmd_opts)

    def _build_package_finder(
        self, options: Values, session: PipSession
    ) -> PackageFinder:
        """
        Create and return a PackageFinder configured for the list command.
        
        This builds a LinkCollector from the provided pip session and options, and constructs
        SelectionPreferences that:
        - always ignore yanked releases (allow_yanked=False),
        - allow prerelease candidates when options.pre is true.
        
        Parameters:
            options (Values): Command-line options; `options.pre` controls whether prereleases
                are considered.
        
        Returns:
            PackageFinder: A finder that uses the constructed LinkCollector and selection preferences.
        """
        link_collector = LinkCollector.create(session, options=options)

        # Pass allow_yanked=False to ignore yanked versions.
        selection_prefs = SelectionPreferences(
            allow_yanked=False,
            allow_all_prereleases=options.pre,
        )

        return PackageFinder.create(
            link_collector=link_collector,
            selection_prefs=selection_prefs,
        )

    def run(self, options: Values, args: List[str]) -> int:
        """
        Execute the list command: validate options, collect installed distributions according to filters,
        optionally filter by dependency status or up-to-dateness, and print the resulting package listing.
        
        Parameters:
            options: Parsed command-line options. Relevant fields used:
                - outdated / uptodate: mutually exclusive filters for outdated or up-to-date packages.
                - list_format: output format (e.g., "columns", "freeze", "json"); "freeze" is incompatible with --outdated.
                - excludes: iterable of package names to skip.
                - local, user, editable, include_editable: scope flags that control which installed distributions are considered.
                - not_required: if set, exclude packages that are dependencies of other installed packages.
                - path: environment path used to locate installed distributions.
            args: Remaining command-line arguments (not used by this command).
        
        Raises:
            CommandError: if incompatible option combinations are provided (e.g., --outdated with --uptodate,
                         or --outdated with list_format "freeze").
        
        Returns:
            int: EXIT status (SUCCESS on normal completion).
        """
        if options.outdated and options.uptodate:
            raise CommandError("Options --outdated and --uptodate cannot be combined.")

        if options.outdated and options.list_format == "freeze":
            raise CommandError(
                "List format 'freeze' cannot be used with the --outdated option."
            )

        cmdoptions.check_list_path_option(options)

        skip = set(stdlib_pkgs)
        if options.excludes:
            skip.update(canonicalize_name(n) for n in options.excludes)

        packages: "_ProcessedDists" = [
            cast("_DistWithLatestInfo", d)
            for d in get_environment(options.path).iter_installed_distributions(
                local_only=options.local,
                user_only=options.user,
                editables_only=options.editable,
                include_editables=options.include_editable,
                skip=skip,
            )
        ]

        # get_not_required must be called firstly in order to find and
        # filter out all dependencies correctly. Otherwise a package
        # can't be identified as requirement because some parent packages
        # could be filtered out before.
        if options.not_required:
            packages = self.get_not_required(packages, options)

        if options.outdated:
            packages = self.get_outdated(packages, options)
        elif options.uptodate:
            packages = self.get_uptodate(packages, options)

        self.output_package_listing(packages, options)
        return SUCCESS

    def get_outdated(
        self, packages: "_ProcessedDists", options: Values
    ) -> "_ProcessedDists":
        """
        Return the subset of given distributions that have a newer available release.
        
        Parameters:
            packages ("_ProcessedDists"): Sequence of installed distributions to check. Each item is a distribution-like object; latest version info is obtained by this method via network queries.
            options (Values): Command options that affect resolution (e.g., whether to allow prereleases).
        
        Returns:
            "_ProcessedDists": A list of the input distributions for which the resolved `latest_version` is greater than the installed `version`.
        """
        return [
            dist
            for dist in self.iter_packages_latest_infos(packages, options)
            if parse(str(dist.latest_version)) > parse(str(dist.version))
        ]

    def get_uptodate(
        self, packages: "_ProcessedDists", options: Values
    ) -> "_ProcessedDists":
        """
        Return the subset of packages that are up-to-date (installed version equals the latest available).
        
        Parameters:
            packages (_ProcessedDists): Sequence of distribution-like objects to check. Each item should be suitable for iter_packages_latest_infos to annotate with `latest_version`.
            options (Values): Command options that control how latest versions are resolved (passed to iter_packages_latest_infos).
        
        Returns:
            _ProcessedDists: A list of the input distributions whose installed version equals the latest available version.
        """
        return [
            dist
            for dist in self.iter_packages_latest_infos(packages, options)
            if parse(str(dist.latest_version)) == parse(str(dist.version))
        ]

    def get_not_required(
        self, packages: "_ProcessedDists", options: Values
    ) -> "_ProcessedDists":
        """
        Return the subset of packages that are not required (i.e., are not listed as a dependency of any other package in the input).
        
        Each package's canonical name is compared against the canonicalized names of all declared dependencies; packages whose canonical name does not appear in that dependency set are returned. The result is a list (order unspecified) of the input distribution-like objects.
        """
        dep_keys = {
            canonicalize_name(dep.name)
            for dist in packages
            for dep in (dist.iter_dependencies() or ())
        }

        # Create a set to remove duplicate packages, and cast it to a list
        # to keep the return type consistent with get_outdated and
        # get_uptodate
        return list({pkg for pkg in packages if pkg.canonical_name not in dep_keys})

    def iter_packages_latest_infos(
        self, packages: "_ProcessedDists", options: Values
    ) -> Generator["_DistWithLatestInfo", None, None]:
        """
        Yield each distribution from `packages` augmented with latest remote version information.
        
        For each distribution this opens a network session and uses a PackageFinder to fetch all available
        candidates for the distribution's canonical name, optionally excluding prerelease candidates unless
        `options.pre` is true. The best candidate is selected; if one exists, the distribution is mutated
        to set `latest_version` (a parsed Version) and `latest_filetype` ("wheel" or "sdist"), and the
        distribution is yielded. Distributions with no available candidates are skipped.
        
        Parameters:
            packages (_ProcessedDists): Iterable of distribution-like objects. Each item is expected to
                have a `canonical_name` attribute and may be annotated with `latest_version` and
                `latest_filetype`.
            options (Values): Parsed CLI options; only `options.pre` is used to control prerelease
                inclusion.
        
        Returns:
            Generator[_DistWithLatestInfo, None, None]: Yields distributions from `packages` that have a
            best remote candidate; each yielded distribution has `latest_version` and `latest_filetype`
            set as side effects.
        """
        with self._build_session(options) as session:
            finder = self._build_package_finder(options, session)

            def latest_info(
                dist: "_DistWithLatestInfo",
            ) -> Optional["_DistWithLatestInfo"]:
                all_candidates = finder.find_all_candidates(dist.canonical_name)
                if not options.pre:
                    # Remove prereleases
                    all_candidates = [
                        candidate
                        for candidate in all_candidates
                        if not candidate.version.is_prerelease
                    ]

                evaluator = finder.make_candidate_evaluator(
                    project_name=dist.canonical_name,
                )
                best_candidate = evaluator.sort_best_candidate(all_candidates)
                if best_candidate is None:
                    return None

                remote_version = best_candidate.version
                if best_candidate.link.is_wheel:
                    typ = "wheel"
                else:
                    typ = "sdist"
                dist.latest_version = remote_version
                dist.latest_filetype = typ
                return dist

            for dist in map(latest_info, packages):
                if dist is not None:
                    yield dist

    def output_package_listing(
        self, packages: "_ProcessedDists", options: Values
    ) -> None:
        """
        Write a list of distributions to the configured output according to the selected format.
        
        Sorts the given processed distributions by canonical name and prints them using the format specified by options.list_format:
        - "columns": formats as a table (uses format_for_columns and output_package_listing_columns).
        - "freeze": one line per distribution in the form `name==version`; if options.verbose >= 1, appends the distribution location in parentheses.
        - "json": writes a JSON array produced by format_for_json.
        
        Parameters:
            packages: Sequence of distribution-like objects (each may have attributes like raw_name, version,
                canonical_name, location, and optionally latest_version/latest_filetype) to be listed.
            options: Parsed command-line options with at least `list_format` (one of "columns", "freeze", "json")
                and `verbose` attributes that influence output formatting.
        """
        packages = sorted(
            packages,
            key=lambda dist: dist.canonical_name,
        )
        if options.list_format == "columns" and packages:
            data, header = format_for_columns(packages, options)
            self.output_package_listing_columns(data, header)
        elif options.list_format == "freeze":
            for dist in packages:
                if options.verbose >= 1:
                    write_output(
                        "%s==%s (%s)", dist.raw_name, dist.version, dist.location
                    )
                else:
                    write_output("%s==%s", dist.raw_name, dist.version)
        elif options.list_format == "json":
            write_output(format_for_json(packages, options))

    def output_package_listing_columns(
        self, data: List[List[str]], header: List[str]
    ) -> None:
        # insert the header first: we need to know the size of column names
        """
        Format and write a tabular package listing to the configured output.
        
        If `data` is non-empty, `header` is prepended as the first row and a separator
        line is inserted after the header. The rows in `data` are formatted into
        columns using the module's tabulate utility, and each resulting line is written
        via write_output.
        
        Parameters:
            data: Rows of package information where each inner list is a row of strings.
            header: Column names to insert above `data` when `data` is non-empty.
        
        Returns:
            None
        """
        if len(data) > 0:
            data.insert(0, header)

        pkg_strings, sizes = tabulate(data)

        # Create and add a separator.
        if len(data) > 0:
            pkg_strings.insert(1, " ".join("-" * x for x in sizes))

        for val in pkg_strings:
            write_output(val)


def format_for_columns(
    pkgs: "_ProcessedDists", options: Values
) -> Tuple[List[List[str]], List[str]]:
    """
    Convert the package data into something usable
    by output_package_listing_columns.
    """
    header = ["Package", "Version"]

    running_outdated = options.outdated
    if running_outdated:
        header.extend(["Latest", "Type"])

    has_editables = any(x.editable for x in pkgs)
    if has_editables:
        header.append("Editable project location")

    if options.verbose >= 1:
        header.append("Location")
    if options.verbose >= 1:
        header.append("Installer")

    data = []
    for proj in pkgs:
        # if we're working on the 'outdated' list, separate out the
        # latest_version and type
        row = [proj.raw_name, str(proj.version)]

        if running_outdated:
            row.append(str(proj.latest_version))
            row.append(proj.latest_filetype)

        if has_editables:
            row.append(proj.editable_project_location or "")

        if options.verbose >= 1:
            row.append(proj.location or "")
        if options.verbose >= 1:
            row.append(proj.installer)

        data.append(row)

    return data, header


def format_for_json(packages: "_ProcessedDists", options: Values) -> str:
    """
    Return a JSON string describing the given packages.
    
    The function returns a JSON array where each element is an object with at least the keys:
    - "name": distribution raw name
    - "version": distribution version as a string
    
    Additional keys included conditionally:
    - If options.verbose >= 1: "location" (empty string if unknown) and "installer".
    - If options.outdated: "latest_version" and "latest_filetype".
    - If the distribution has an editable project location: "editable_project_location".
    
    Parameters:
    - packages: sequence of distribution-like objects (each may expose raw_name, version, location, installer, latest_version, latest_filetype, editable_project_location).
    - options: parsed CLI options controlling which optional fields are included (uses options.verbose and options.outdated).
    
    Returns:
    A JSON-formatted string representing the array of package objects.
    """
    data = []
    for dist in packages:
        info = {
            "name": dist.raw_name,
            "version": str(dist.version),
        }
        if options.verbose >= 1:
            info["location"] = dist.location or ""
            info["installer"] = dist.installer
        if options.outdated:
            info["latest_version"] = str(dist.latest_version)
            info["latest_filetype"] = dist.latest_filetype
        editable_project_location = dist.editable_project_location
        if editable_project_location:
            info["editable_project_location"] = editable_project_location
        data.append(info)
    return json.dumps(data)
