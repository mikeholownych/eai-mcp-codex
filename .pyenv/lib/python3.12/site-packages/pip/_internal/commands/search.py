import logging
import shutil
import sys
import textwrap
import xmlrpc.client
from collections import OrderedDict
from optparse import Values
from typing import TYPE_CHECKING, Dict, List, Optional

from pip._vendor.packaging.version import parse as parse_version

from pip._internal.cli.base_command import Command
from pip._internal.cli.req_command import SessionCommandMixin
from pip._internal.cli.status_codes import NO_MATCHES_FOUND, SUCCESS
from pip._internal.exceptions import CommandError
from pip._internal.metadata import get_default_environment
from pip._internal.models.index import PyPI
from pip._internal.network.xmlrpc import PipXmlrpcTransport
from pip._internal.utils.logging import indent_log
from pip._internal.utils.misc import write_output

if TYPE_CHECKING:
    from typing import TypedDict

    class TransformedHit(TypedDict):
        name: str
        summary: str
        versions: List[str]


logger = logging.getLogger(__name__)


class SearchCommand(Command, SessionCommandMixin):
    """Search for PyPI packages whose name or summary contains <query>."""

    usage = """
      %prog [options] <query>"""
    ignore_require_venv = True

    def add_options(self) -> None:
        """
        Add command-line options for the search command.
        
        Specifically, registers the -i/--index option (destination `index`, metavar `URL`)
        with a default of PyPI's base URL, and inserts the option group into the parser
        so the option is available to the command-line interface.
        """
        self.cmd_opts.add_option(
            "-i",
            "--index",
            dest="index",
            metavar="URL",
            default=PyPI.pypi_url,
            help="Base URL of Python Package Index (default %default)",
        )

        self.parser.insert_option_group(0, self.cmd_opts)

    def run(self, options: Values, args: List[str]) -> int:
        """
        Run the search command: validate the query, perform the PyPI search, and print formatted results.
        
        The provided positional arguments are used as the search query (matched against package name and summary). This method performs the XML-RPC search via self.search(), aggregates results with transform_hits(), determines the terminal width when stdout is a TTY, and prints results with print_results().
        
        Parameters:
            options (Values): Parsed command options (e.g., index URL and network/session-related flags).
            args (List[str]): One or more query terms to search for.
        
        Returns:
            int: Exit status code; SUCCESS if any matches were found, otherwise NO_MATCHES_FOUND.
        
        Raises:
            CommandError: If no query arguments are provided.
        """
        if not args:
            raise CommandError("Missing required argument (search query).")
        query = args
        pypi_hits = self.search(query, options)
        hits = transform_hits(pypi_hits)

        terminal_width = None
        if sys.stdout.isatty():
            terminal_width = shutil.get_terminal_size()[0]

        print_results(hits, terminal_width=terminal_width)
        if pypi_hits:
            return SUCCESS
        return NO_MATCHES_FOUND

    def search(self, query: List[str], options: Values) -> List[Dict[str, str]]:
        """
        Search the configured XML-RPC index for packages whose name or summary match the provided query.
        
        The query terms are sent to the index as the values for the "name" and "summary" fields with the "or" operator.
        
        Parameters:
            query (List[str]): One or more search terms to match against package names and summaries.
        
        Returns:
            List[Dict[str, str]]: Raw hits returned by the XML-RPC `search` call; each hit is a mapping
            containing keys such as "name", "summary", and "version".
        
        Raises:
            CommandError: If the XML-RPC call fails (wraps xmlrpc.client.Fault with a formatted message).
        """
        index_url = options.index

        session = self.get_default_session(options)

        transport = PipXmlrpcTransport(index_url, session)
        pypi = xmlrpc.client.ServerProxy(index_url, transport)
        try:
            hits = pypi.search({"name": query, "summary": query}, "or")
        except xmlrpc.client.Fault as fault:
            message = "XMLRPC request failed [code: {code}]\n{string}".format(
                code=fault.faultCode,
                string=fault.faultString,
            )
            raise CommandError(message)
        assert isinstance(hits, list)
        return hits


def transform_hits(hits: List[Dict[str, str]]) -> List["TransformedHit"]:
    """
    Convert a flat list of PyPI search hits (one per release) into a list of packages each containing all discovered versions.
    
    Each input hit must be a dict with keys "name", "summary", and "version". For each package name, this function aggregates release versions into a list and keeps the summary associated with the highest-seen version. The original package insertion order is preserved.
    
    Parameters:
        hits (List[Dict[str, str]]): PyPI-style hit dicts (per-release) with keys "name", "summary", and "version".
    
    Returns:
        List[TransformedHit]: A list of package dictionaries in insertion order, each with:
            - "name" (str): package name
            - "summary" (str): summary corresponding to the highest version seen so far
            - "versions" (List[str]): collected version strings for the package
    """
    packages: Dict[str, "TransformedHit"] = OrderedDict()
    for hit in hits:
        name = hit["name"]
        summary = hit["summary"]
        version = hit["version"]

        if name not in packages.keys():
            packages[name] = {
                "name": name,
                "summary": summary,
                "versions": [version],
            }
        else:
            packages[name]["versions"].append(version)

            # if this is the highest version, replace summary and score
            if version == highest_version(packages[name]["versions"]):
                packages[name]["summary"] = summary

    return list(packages.values())


def print_dist_installation_info(name: str, latest: str) -> None:
    """
    Print installation status and latest-version information for the named distribution.
    
    Checks the current environment for an installed distribution matching `name`. If
    found, writes the installed version and, when it differs from `latest`, writes
    the latest available version. If `latest` is a pre-release, a note suggests
    installing with `--pre`.
    
    Parameters:
        name (str): The distribution/project name to look up in the current
            environment.
        latest (str): The latest available version string for the distribution.
    """
    env = get_default_environment()
    dist = env.get_distribution(name)
    if dist is not None:
        with indent_log():
            if dist.version == latest:
                write_output("INSTALLED: %s (latest)", dist.version)
            else:
                write_output("INSTALLED: %s", dist.version)
                if parse_version(latest).pre:
                    write_output(
                        "LATEST:    %s (pre-release; install"
                        " with `pip install --pre`)",
                        latest,
                    )
                else:
                    write_output("LATEST:    %s", latest)


def print_results(
    hits: List["TransformedHit"],
    name_column_width: Optional[int] = None,
    terminal_width: Optional[int] = None,
) -> None:
    """
    Print formatted search results to stdout.
    
    Each entry in `hits` should be a mapping with keys "name", "summary", and "versions" (a list of version strings). For each hit this prints a line of the form:
        "name (latest)    - summary"
    and then calls print_dist_installation_info(name, latest) to show installed/latest status.
    
    Parameters:
        hits: List of transformed search results (name, summary, versions).
        name_column_width: Optional fixed width for the name + version column. If omitted it is computed as the maximum of (len(name) + len(latest_version)) across hits, plus 4.
        terminal_width: Optional terminal width used to wrap long summaries. When provided and large enough, summaries are wrapped and subsequent lines are indented to align with the summary column.
    
    Notes:
    - The function writes output via write_output and may call into environment inspection helpers; UnicodeEncodeError from output is suppressed.
    """
    if not hits:
        return
    if name_column_width is None:
        name_column_width = (
            max(
                [
                    len(hit["name"]) + len(highest_version(hit.get("versions", ["-"])))
                    for hit in hits
                ]
            )
            + 4
        )

    for hit in hits:
        name = hit["name"]
        summary = hit["summary"] or ""
        latest = highest_version(hit.get("versions", ["-"]))
        if terminal_width is not None:
            target_width = terminal_width - name_column_width - 5
            if target_width > 10:
                # wrap and indent summary to fit terminal
                summary_lines = textwrap.wrap(summary, target_width)
                summary = ("\n" + " " * (name_column_width + 3)).join(summary_lines)

        name_latest = f"{name} ({latest})"
        line = f"{name_latest:{name_column_width}} - {summary}"
        try:
            write_output(line)
            print_dist_installation_info(name, latest)
        except UnicodeEncodeError:
            pass


def highest_version(versions: List[str]) -> str:
    """
    Return the highest version string from a list of version identifiers.
    
    Compares versions using packaging.version.parse (PEP 440 semantics) and returns
    the original version string that sorts highest.
    
    Parameters:
        versions (List[str]): Iterable of version strings (PEP 440 compatible).
    
    Returns:
        str: The version string from `versions` that is considered the highest.
    """
    return max(versions, key=parse_version)
