import logging
from optparse import Values
from typing import Any, Dict, List

from pip._vendor.packaging.markers import default_environment
from pip._vendor.rich import print_json

from pip import __version__
from pip._internal.cli import cmdoptions
from pip._internal.cli.req_command import Command
from pip._internal.cli.status_codes import SUCCESS
from pip._internal.metadata import BaseDistribution, get_environment
from pip._internal.utils.compat import stdlib_pkgs
from pip._internal.utils.urls import path_to_url

logger = logging.getLogger(__name__)


class InspectCommand(Command):
    """
    Inspect the content of a Python environment and produce a report in JSON format.
    """

    ignore_require_venv = True
    usage = """
      %prog [options]"""

    def add_options(self) -> None:
        """
        Add command-line options for the inspect command.
        
        Registers:
        - --local: when in a virtual environment with global access, restricts output to non-global packages.
        - --user: output only packages installed in the user site.
        - list-path options from cmdoptions.list_path().
        
        Inserts the option group at the front of the parser.
        """
        self.cmd_opts.add_option(
            "--local",
            action="store_true",
            default=False,
            help=(
                "If in a virtualenv that has global access, do not list "
                "globally-installed packages."
            ),
        )
        self.cmd_opts.add_option(
            "--user",
            dest="user",
            action="store_true",
            default=False,
            help="Only output packages installed in user-site.",
        )
        self.cmd_opts.add_option(cmdoptions.list_path())
        self.parser.insert_option_group(0, self.cmd_opts)

    def run(self, options: Values, args: List[str]) -> int:
        """
        Inspect the current Python environment and print a JSON report of installed distributions.
        
        Builds a JSON object containing:
        - version: schema version ("1")
        - pip_version: pip's current version
        - installed: list of installed distributions serialized via _dist_to_dict
        - environment: output of default_environment()
        
        Parameters:
            options (optparse.Values): Command options. Expects at least:
                - options.local (bool): limit to non-global packages when in a venv with global access.
                - options.user (bool): limit to user-site installed packages.
                - options.path (str|None): environment path to inspect.
            args (List[str]): Positional arguments (unused).
        
        Returns:
            int: SUCCESS (exit status code).
        
        Side effects:
            Writes the JSON report to stdout via print_json().
        """
        cmdoptions.check_list_path_option(options)
        dists = get_environment(options.path).iter_installed_distributions(
            local_only=options.local,
            user_only=options.user,
            skip=set(stdlib_pkgs),
        )
        output = {
            "version": "1",
            "pip_version": __version__,
            "installed": [self._dist_to_dict(dist) for dist in dists],
            "environment": default_environment(),
            # TODO tags? scheme?
        }
        print_json(data=output)
        return SUCCESS

    def _dist_to_dict(self, dist: BaseDistribution) -> Dict[str, Any]:
        """
        Convert a BaseDistribution into a JSON-serializable dictionary describing the installed distribution.
        
        The returned dictionary always contains:
        - "metadata": the distribution's metadata as a dict.
        - "metadata_location": the on-disk location of the distribution's metadata.
        
        If available, the dictionary also includes:
        - "direct_url": a dict produced from distribution.direct_url.to_dict(); if direct_url is absent but the distribution is a legacy editable install, an emulated direct_url is provided with a URL derived from the editable project path and dir_info.editable = True.
        - "installer": the recorded installer name.
        - "requested": a boolean indicating whether the distribution was explicitly requested (present only when installed_with_dist_info is True).
        
        Parameters:
            dist (BaseDistribution): The distribution to serialize.
        
        Returns:
            Dict[str, Any]: A dictionary suitable for JSON output describing the distribution.
        """
        res: Dict[str, Any] = {
            "metadata": dist.metadata_dict,
            "metadata_location": dist.info_location,
        }
        # direct_url. Note that we don't have download_info (as in the installation
        # report) since it is not recorded in installed metadata.
        direct_url = dist.direct_url
        if direct_url is not None:
            res["direct_url"] = direct_url.to_dict()
        else:
            # Emulate direct_url for legacy editable installs.
            editable_project_location = dist.editable_project_location
            if editable_project_location is not None:
                res["direct_url"] = {
                    "url": path_to_url(editable_project_location),
                    "dir_info": {
                        "editable": True,
                    },
                }
        # installer
        installer = dist.installer
        if dist.installer:
            res["installer"] = installer
        # requested
        if dist.installed_with_dist_info:
            res["requested"] = dist.requested
        return res
