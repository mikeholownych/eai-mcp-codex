import email.message
import importlib.metadata
import os
import pathlib
import zipfile
from typing import (
    Collection,
    Dict,
    Iterable,
    Iterator,
    Mapping,
    Optional,
    Sequence,
    cast,
)

from pip._vendor.packaging.requirements import Requirement
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
from pip._vendor.packaging.version import parse as parse_version

from pip._internal.exceptions import InvalidWheel, UnsupportedWheel
from pip._internal.metadata.base import (
    BaseDistribution,
    BaseEntryPoint,
    DistributionVersion,
    InfoPath,
    Wheel,
)
from pip._internal.utils.misc import normalize_path
from pip._internal.utils.temp_dir import TempDirectory
from pip._internal.utils.wheel import parse_wheel, read_wheel_metadata_file

from ._compat import BasePath, get_dist_name


class WheelDistribution(importlib.metadata.Distribution):
    """An ``importlib.metadata.Distribution`` read from a wheel.

    Although ``importlib.metadata.PathDistribution`` accepts ``zipfile.Path``,
    its implementation is too "lazy" for pip's needs (we can't keep the ZipFile
    handle open for the entire lifetime of the distribution object).

    This implementation eagerly reads the entire metadata directory into the
    memory instead, and operates from that.
    """

    def __init__(
        self,
        files: Mapping[pathlib.PurePosixPath, bytes],
        info_location: pathlib.PurePosixPath,
    ) -> None:
        """
        Initialize a WheelDistribution with in-memory wheel metadata.
        
        Parameters:
            files: Mapping of relative metadata file paths (PurePosixPath, relative to the wheel's
                metadata directory) to their raw bytes contents.
            info_location: The PurePosixPath of the distribution's metadata directory inside the wheel
                (the .dist-info/ or .egg-info/ directory path as found in the archive).
        """
        self._files = files
        self.info_location = info_location

    @classmethod
    def from_zipfile(
        cls,
        zf: zipfile.ZipFile,
        name: str,
        location: str,
    ) -> "WheelDistribution":
        """
        Create a WheelDistribution by loading the wheel's metadata files from an open ZipFile.
        
        Scans the zip for the wheel's metadata directory (determined via parse_wheel), reads each file under that directory into memory (as bytes) using read_wheel_metadata_file, and sets the distribution's info_location to location joined with the discovered metadata directory.
        
        Parameters:
            zf (zipfile.ZipFile): Open ZIP file for the wheel.
            name (str): The archive-internal filename used to identify the wheel contents (used by parse_wheel).
            location (str): Filesystem location of the wheel archive; used to build the returned distribution's info_location.
        
        Returns:
            WheelDistribution: A new instance with an in-memory mapping of metadata file paths to bytes and its info_location set to location/<info-dir>.
        """
        info_dir, _ = parse_wheel(zf, name)
        paths = (
            (name, pathlib.PurePosixPath(name.split("/", 1)[-1]))
            for name in zf.namelist()
            if name.startswith(f"{info_dir}/")
        )
        files = {
            relpath: read_wheel_metadata_file(zf, fullpath)
            for fullpath, relpath in paths
        }
        info_location = pathlib.PurePosixPath(location, info_dir)
        return cls(files, info_location)

    def iterdir(self, path: InfoPath) -> Iterator[pathlib.PurePosixPath]:
        # Only allow iterating through the metadata directory.
        """
        Return an iterator over metadata file paths when requesting the metadata root.
        
        If `path` corresponds to the loaded metadata directory, yields the stored
        metadata file paths (pathlib.PurePosixPath) contained in this WheelDistribution.
        If `path` is not the metadata directory, raises FileNotFoundError.
        """
        if pathlib.PurePosixPath(str(path)) in self._files:
            return iter(self._files)
        raise FileNotFoundError(path)

    def read_text(self, filename: str) -> Optional[str]:
        """
        Return the decoded UTF-8 content of a metadata file stored in this WheelDistribution.
        
        Parameters:
            filename (str): Relative path (within the wheel's .dist-info/.egg-info metadata directory) of the metadata file to read.
        
        Returns:
            Optional[str]: The file contents decoded as UTF-8, or None if the file is not present in the in-memory metadata.
        
        Raises:
            UnsupportedWheel: If the file is present but cannot be decoded as UTF-8 (includes the wheel location and filename in the error).
        """
        try:
            data = self._files[pathlib.PurePosixPath(filename)]
        except KeyError:
            return None
        try:
            text = data.decode("utf-8")
        except UnicodeDecodeError as e:
            wheel = self.info_location.parent
            error = f"Error decoding metadata for {wheel}: {e} in {filename} file"
            raise UnsupportedWheel(error)
        return text


class Distribution(BaseDistribution):
    def __init__(
        self,
        dist: importlib.metadata.Distribution,
        info_location: Optional[BasePath],
        installed_location: Optional[BasePath],
    ) -> None:
        """
        Initialize the Distribution wrapper.
        
        Parameters:
            dist: The underlying importlib.metadata.Distribution instance providing metadata and entry points.
            info_location: Filesystem path (or path-like) to the distribution's metadata directory (e.g., .dist-info or .egg-info), or None if unavailable.
            installed_location: Filesystem path (or path-like) to the installed package location (parent of info_location), or None if unknown.
        """
        self._dist = dist
        self._info_location = info_location
        self._installed_location = installed_location

    @classmethod
    def from_directory(cls, directory: str) -> BaseDistribution:
        """
        Create a Distribution from an on-disk metadata directory.
        
        Given a path to a distribution metadata directory (e.g., a ".dist-info" or
        ".egg-info" directory), constructs an importlib.metadata.Distribution from that
        directory and returns a Distribution wrapper whose info_location is the
        directory and whose installed_location is the directory's parent.
        
        Parameters:
            directory (str): Path to the metadata directory.
        
        Returns:
            BaseDistribution: A Distribution instance wrapping the metadata at
            `directory`.
        """
        info_location = pathlib.Path(directory)
        dist = importlib.metadata.Distribution.at(info_location)
        return cls(dist, info_location, info_location.parent)

    @classmethod
    def from_metadata_file_contents(
        cls,
        metadata_contents: bytes,
        filename: str,
        project_name: str,
    ) -> BaseDistribution:
        # Generate temp dir to contain the metadata file, and write the file contents.
        """
        Create a Distribution from raw METADATA file contents by writing them to a temporary metadata directory.
        
        Writes metadata_contents (bytes) to a newly created temporary directory as "METADATA", constructs an importlib.metadata.Distribution from that directory, and returns a Distribution wrapping it. The created distribution's info_location points to the temporary directory and its installed_location is None.
        
        Parameters:
            metadata_contents (bytes): Raw bytes for a METADATA file to write.
            filename (str): Accepted for API compatibility but not used; the METADATA file is always written as "METADATA".
            project_name (str): Accepted for API compatibility but not used.
        
        Returns:
            BaseDistribution: A Distribution instance backed by the temporary metadata directory.
        """
        temp_dir = pathlib.Path(
            TempDirectory(kind="metadata", globally_managed=True).path
        )
        metadata_path = temp_dir / "METADATA"
        metadata_path.write_bytes(metadata_contents)
        # Construct dist pointing to the newly created directory.
        dist = importlib.metadata.Distribution.at(metadata_path.parent)
        return cls(dist, metadata_path.parent, None)

    @classmethod
    def from_wheel(cls, wheel: Wheel, name: str) -> BaseDistribution:
        """
        Create a Distribution wrapper from a Wheel by reading its metadata from the wheel file.
        
        Attempts to open the given Wheel as a ZIP archive and build a WheelDistribution from its in-archive metadata, then returns a Distribution instance that wraps that WheelDistribution. The returned Distribution's info_location is set to the in-wheel metadata location and its installed_location is set to the wheel's filesystem location.
        
        Parameters:
            wheel (Wheel): Wheel object to read metadata from.
            name (str): Display name used when reporting wheel-related errors.
        
        Returns:
            BaseDistribution: A Distribution wrapping the wheel's metadata.
        
        Raises:
            InvalidWheel: If the wheel file is not a valid zip archive.
            UnsupportedWheel: If the wheel's metadata cannot be decoded or is otherwise unsupported.
        """
        try:
            with wheel.as_zipfile() as zf:
                dist = WheelDistribution.from_zipfile(zf, name, wheel.location)
        except zipfile.BadZipFile as e:
            raise InvalidWheel(wheel.location, name) from e
        except UnsupportedWheel as e:
            raise UnsupportedWheel(f"{name} has an invalid wheel, {e}")
        return cls(dist, dist.info_location, pathlib.PurePosixPath(wheel.location))

    @property
    def location(self) -> Optional[str]:
        """
        Return the distribution's installed location directory path.
        
        If the distribution has an associated metadata location, this returns the parent
        directory of that metadata location as a string. Returns None when metadata
        location is unavailable.
        """
        if self._info_location is None:
            return None
        return str(self._info_location.parent)

    @property
    def info_location(self) -> Optional[str]:
        """
        Return the distribution metadata directory path as a string, or None if unavailable.
        
        If the Distribution was created from in-memory or otherwise lacks a metadata location, this property returns None; otherwise it returns the string form of the metadata directory path (e.g., the `.dist-info` or `.egg-info` directory).
        """
        if self._info_location is None:
            return None
        return str(self._info_location)

    @property
    def installed_location(self) -> Optional[str]:
        """
        Return the normalized installed location path for the distribution, or None if unavailable.
        
        Returns:
            Optional[str]: The installed location as a normalized string path, or None when no installed location is set.
        """
        if self._installed_location is None:
            return None
        return normalize_path(str(self._installed_location))

    def _get_dist_name_from_location(self) -> Optional[str]:
        """Try to get the name from the metadata directory name.

        This is much faster than reading metadata.
        """
        if self._info_location is None:
            return None
        stem, suffix = os.path.splitext(self._info_location.name)
        if suffix not in (".dist-info", ".egg-info"):
            return None
        return stem.split("-", 1)[0]

    @property
    def canonical_name(self) -> NormalizedName:
        """
        Return the canonical (PEP 503-normalized) distribution name.
        
        If the distribution directory name (e.g., "<name>-<version>.dist-info" or
        "<name>.egg-info") allows deriving a name, that is used; otherwise the name is
        taken from the underlying importlib.metadata.Distribution. The result is
        normalized with `canonicalize_name`.
         
        Returns:
            NormalizedName: The PEP 503-normalized distribution name.
        """
        name = self._get_dist_name_from_location() or get_dist_name(self._dist)
        return canonicalize_name(name)

    @property
    def version(self) -> DistributionVersion:
        """
        Return the parsed distribution version.
        
        Returns the distribution version from the underlying importlib.metadata.Distribution,
        parsed into a packaging.version.Version (typed as DistributionVersion).
        """
        return parse_version(self._dist.version)

    def is_file(self, path: InfoPath) -> bool:
        """
        Return True if the distribution contains and can read the given metadata file.
        
        The `path` is a metadata-relative path (for example "METADATA", "entry_points.txt",
        or a file under the distribution's info directory). Returns True when the underlying
        distribution can produce text for that path (i.e., `read_text` does not return None).
        """
        return self._dist.read_text(str(path)) is not None

    def iter_distutils_script_names(self) -> Iterator[str]:
        # A distutils installation is always "flat" (not in e.g. egg form), so
        # if this distribution's info location is NOT a pathlib.Path (but e.g.
        # zipfile.Path), it can never contain any distutils scripts.
        """
        Yield the names of distutils-installed script files from the distribution's metadata.
        
        This only applies to filesystem-backed distributions: if the distribution's
        info_location is not a pathlib.Path (for example, when metadata is inside a
        zip), the generator yields nothing. When present, iterates the `scripts`
        subdirectory of the info_location and yields each entry's filename.
        
        Yields:
            str: The filename of each script in the `scripts` metadata directory.
        
        Raises:
            FileNotFoundError: If the `scripts` directory does not exist under the
                info_location.
        """
        if not isinstance(self._info_location, pathlib.Path):
            return
        for child in self._info_location.joinpath("scripts").iterdir():
            yield child.name

    def read_text(self, path: InfoPath) -> str:
        """
        Return the text contents of a distribution metadata file.
        
        Parameters:
            path (InfoPath): Relative path within the distribution metadata (e.g., "METADATA", "entry_points.txt").
        
        Returns:
            str: The decoded text content of the requested metadata file.
        
        Raises:
            FileNotFoundError: If the requested path is not present in the distribution metadata.
        """
        content = self._dist.read_text(str(path))
        if content is None:
            raise FileNotFoundError(path)
        return content

    def iter_entry_points(self) -> Iterable[BaseEntryPoint]:
        # importlib.metadata's EntryPoint structure sasitfies BaseEntryPoint.
        """
        Return the distribution's entry points.
        
        Provides the entry points object from the underlying importlib.metadata.Distribution, yielding BaseEntryPoint items.
        """
        return self._dist.entry_points

    def _metadata_impl(self) -> email.message.Message:
        # From Python 3.10+, importlib.metadata declares PackageMetadata as the
        # return type. This protocol is unfortunately a disaster now and misses
        # a ton of fields that we need, including get() and get_payload(). We
        # rely on the implementation that the object is actually a Message now,
        # until upstream can improve the protocol. (python/cpython#94952)
        """
        Return the distribution metadata as an email.message.Message.
        
        The importlib.metadata API advertises a more limited protocol for package metadata, but the actual object provided is a full email.message.Message. This method casts and returns that Message so callers can use methods like `get()` and `get_payload()` reliably.
          
        Returns:
            email.message.Message: The parsed METADATA as an email.message.Message.
        """
        return cast(email.message.Message, self._dist.metadata)

    def iter_provided_extras(self) -> Iterable[str]:
        """
        Return the extras advertised by this distribution.
        
        Reads the `Provides-Extra` metadata headers and returns them as an iterable of strings.
        If the metadata contains no `Provides-Extra` entries, an empty iterable is returned.
        """
        return self.metadata.get_all("Provides-Extra", [])

    def is_extra_provided(self, extra: str) -> bool:
        """
        Return True if the distribution advertises the given extra in its `Provides-Extra` metadata.
        
        The comparison is done case-insensitively by canonicalizing both the requested extra and each provided extra using `canonicalize_name`.
        
        Parameters:
            extra (str): The extra name to check.
        
        Returns:
            bool: True if `extra` is listed in `Provides-Extra`, otherwise False.
        """
        return any(
            canonicalize_name(provided_extra) == canonicalize_name(extra)
            for provided_extra in self.metadata.get_all("Provides-Extra", [])
        )

    def iter_dependencies(self, extras: Collection[str] = ()) -> Iterable[Requirement]:
        """
        Yield Requirement objects for the distribution filtered by the given extras.
        
        For each `Requires-Dist` metadata entry, parse it into a `packaging.requirements.Requirement`
        and yield it if any of the following is true:
        - the requirement has no environment marker,
        - `extras` is empty and the requirement's marker evaluates true with `{"extra": ""}`,
        - the requirement's marker evaluates true for at least one provided extra (marker evaluated
          with `{"extra": <extra>}`).
        
        Parameters:
            extras (Collection[str], optional): Extra names to consider when evaluating markers.
                If empty (the default), only requirements without markers or those whose marker
                is true for the empty extra are yielded.
        
        Returns:
            Iterable[packaging.requirements.Requirement]: An iterator of parsed Requirement objects
            that apply for the given extras.
        """
        contexts: Sequence[Dict[str, str]] = [{"extra": e} for e in extras]
        for req_string in self.metadata.get_all("Requires-Dist", []):
            req = Requirement(req_string)
            if not req.marker:
                yield req
            elif not extras and req.marker.evaluate({"extra": ""}):
                yield req
            elif any(req.marker.evaluate(context) for context in contexts):
                yield req
