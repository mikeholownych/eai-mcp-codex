import functools
import importlib.metadata
import logging
import os
import pathlib
import sys
import zipfile
import zipimport
from typing import Iterator, List, Optional, Sequence, Set, Tuple

from pip._vendor.packaging.utils import NormalizedName, canonicalize_name

from pip._internal.metadata.base import BaseDistribution, BaseEnvironment
from pip._internal.models.wheel import Wheel
from pip._internal.utils.deprecation import deprecated
from pip._internal.utils.filetypes import WHEEL_EXTENSION

from ._compat import BadMetadata, BasePath, get_dist_name, get_info_location
from ._dists import Distribution

logger = logging.getLogger(__name__)


def _looks_like_wheel(location: str) -> bool:
    """
    Return True if the given filesystem path appears to be a valid wheel file.
    
    Checks that the path ends with the wheel extension, is an existing regular file,
    its basename matches the wheel filename regular expression, and the file is a
    valid ZIP archive. Returns False for non-files, names that don't match the
    wheel pattern, or non-zip files.
    """
    if not location.endswith(WHEEL_EXTENSION):
        return False
    if not os.path.isfile(location):
        return False
    if not Wheel.wheel_file_re.match(os.path.basename(location)):
        return False
    return zipfile.is_zipfile(location)


class _DistributionFinder:
    """Finder to locate distributions.

    The main purpose of this class is to memoize found distributions' names, so
    only one distribution is returned for each package name. At lot of pip code
    assumes this (because it is setuptools's behavior), and not doing the same
    can potentially cause a distribution in lower precedence path to override a
    higher precedence one if the caller is not careful.

    Eventually we probably want to make it possible to see lower precedence
    installations as well. It's useful feature, after all.
    """

    FoundResult = Tuple[importlib.metadata.Distribution, Optional[BasePath]]

    def __init__(self) -> None:
        """
        Initialize the finder.
        
        Creates the internal set used to track canonicalized distribution names that have
        already been seen, ensuring each package name is yielded at most once.
        """
        self._found_names: Set[NormalizedName] = set()

    def _find_impl(self, location: str) -> Iterator[FoundResult]:
        """
        Yield distributions discovered at the given filesystem location.
        
        This scans the single path `location` with importlib.metadata to find distribution
        metadata and yields (distribution, info_location) pairs. Behavior details:
        - If `location` looks like a wheel file, nothing is yielded.
        - Distributions with invalid metadata (BadMetadata) are skipped; a warning is emitted.
        - Package names are canonicalized and deduplicated across calls â€” once a
          canonical name has been yielded, subsequent occurrences are skipped.
        - Yields tuples (importlib.metadata.Distribution, Optional[BasePath]) where
          `info_location` is the path to the distribution's `.dist-info`/metadata or None.
        
        Parameters:
            location (str): A file or directory path to inspect for distributions.
        """
        # Skip looking inside a wheel. Since a package inside a wheel is not
        # always valid (due to .data directories etc.), its .dist-info entry
        # should not be considered an installed distribution.
        if _looks_like_wheel(location):
            return
        # To know exactly where we find a distribution, we have to feed in the
        # paths one by one, instead of dumping the list to importlib.metadata.
        for dist in importlib.metadata.distributions(path=[location]):
            info_location = get_info_location(dist)
            try:
                raw_name = get_dist_name(dist)
            except BadMetadata as e:
                logger.warning("Skipping %s due to %s", info_location, e.reason)
                continue
            normalized_name = canonicalize_name(raw_name)
            if normalized_name in self._found_names:
                continue
            self._found_names.add(normalized_name)
            yield dist, info_location

    def find(self, location: str) -> Iterator[BaseDistribution]:
        """
        Yield Distribution wrappers for all distributions discovered at the given filesystem location.
        
        The location may be a directory or a ZIP archive. For each discovered importlib.metadata.Distribution this
        method yields a pip.metadata.BaseDistribution (specifically a Distribution wrapper) that includes the
        distribution metadata location (`info_location`) and an `installed_location` set to `info_location.parent`
        when available, otherwise None.
        
        This finder skips wheel files, uses importlib.metadata for discovery, and deduplicates results by
        canonical package name so at most one distribution per package name is yielded.
        """
        for dist, info_location in self._find_impl(location):
            if info_location is None:
                installed_location: Optional[BasePath] = None
            else:
                installed_location = info_location.parent
            yield Distribution(dist, info_location, installed_location)

    def find_linked(self, location: str) -> Iterator[BaseDistribution]:
        """
        Yield distributions referenced by .egg-link files in the given directory.
        
        If `location` is not a directory, yields nothing. For each *.egg-link file in the directory this reads the first non-empty line as the target path (relative paths are resolved against the egg-link's containing directory) and yields distributions found at that target. The yielded Distribution objects have their `installed_location` set to the egg-link directory.
        """
        path = pathlib.Path(location)
        if not path.is_dir():
            return
        for child in path.iterdir():
            if child.suffix != ".egg-link":
                continue
            with child.open() as f:
                lines = (line.strip() for line in f)
                target_rel = next((line for line in lines if line), "")
            if not target_rel:
                continue
            target_location = str(path.joinpath(target_rel))
            for dist, info_location in self._find_impl(target_location):
                yield Distribution(dist, info_location, path)

    def _find_eggs_in_dir(self, location: str) -> Iterator[BaseDistribution]:
        """
        Yield legacy egg-style distributions found directly inside a directory.
        
        Scans the given directory for entries whose names end with ".egg" and, for each such entry,
        uses pkg_resources.find_distributions to locate any egg distributions inside that entry.
        Each found distribution is wrapped as a legacy Distribution and yielded.
        
        Parameters:
            location (str): Path to a directory to scan for ".egg" entries.
        
        Yields:
            BaseDistribution: Legacy `pkg_resources`-backed distributions for each egg found in the directory.
        """
        from pip._vendor.pkg_resources import find_distributions

        from pip._internal.metadata import pkg_resources as legacy

        with os.scandir(location) as it:
            for entry in it:
                if not entry.name.endswith(".egg"):
                    continue
                for dist in find_distributions(entry.path):
                    yield legacy.Distribution(dist)

    def _find_eggs_in_zip(self, location: str) -> Iterator[BaseDistribution]:
        """
        Yield legacy `BaseDistribution` objects for any eggs found inside a zip archive.
        
        Scans the given filesystem path (expected to be a zip file or .egg file) using zipimport and
        pkg_resources' `find_eggs_in_zip`. Each discovered pkg_resources distribution is wrapped as a
        legacy `Distribution` and yielded.
        
        Parameters:
            location (str): Filesystem path to the zip archive to scan.
        
        Returns:
            Iterator[BaseDistribution]: An iterator yielding legacy Distribution wrappers for each egg
            found. If `location` cannot be opened by `zipimport` (raises ZipImportError), the function
            returns without yielding anything.
        """
        from pip._vendor.pkg_resources import find_eggs_in_zip

        from pip._internal.metadata import pkg_resources as legacy

        try:
            importer = zipimport.zipimporter(location)
        except zipimport.ZipImportError:
            return
        for dist in find_eggs_in_zip(importer, location):
            yield legacy.Distribution(dist)

    def find_eggs(self, location: str) -> Iterator[BaseDistribution]:
        """
        Yield legacy (pkg_resources-style) egg distributions found at the given location.
        
        If the location is a directory, scans for .egg directories and files; if it is a zipfile, scans for eggs inside the archive. Uses the legacy pkg_resources backend, and therefore may trigger pkg_resources import-time cost or deprecation handling elsewhere in the module.
        """
        if os.path.isdir(location):
            yield from self._find_eggs_in_dir(location)
        if zipfile.is_zipfile(location):
            yield from self._find_eggs_in_zip(location)


@functools.lru_cache(maxsize=None)  # Warn a distribution exactly once.
def _emit_egg_deprecation(location: Optional[str]) -> None:
    """
    Emit a deprecation warning for loading an egg from the given location.
    
    If a non-None location is provided, records a deprecation reason advising to install
    the package with pip instead of loading an egg. The emission is cached so the
    warning is produced at most once per location.
    
    Parameters:
        location (Optional[str]): Path or identifier of the egg being loaded. May be None.
    """
    deprecated(
        reason=f"Loading egg at {location} is deprecated.",
        replacement="to use pip for package installation.",
        gone_in="24.3",
        issue=12330,
    )


class Environment(BaseEnvironment):
    def __init__(self, paths: Sequence[str]) -> None:
        """
        Initialize the Environment with a sequence of filesystem paths to search for distributions.
        
        Parameters:
            paths (Sequence[str]): Ordered collection of filesystem paths (directories or zip files) that will be scanned when enumerating distributions.
        """
        self._paths = paths

    @classmethod
    def default(cls) -> BaseEnvironment:
        """
        Return an Environment initialized with the current interpreter's sys.path.
        
        Creates and returns an instance of the environment class using the interpreter
        module search paths (sys.path) as the locations to scan for distributions.
        
        Returns:
            BaseEnvironment: an Environment instance configured with sys.path.
        """
        return cls(sys.path)

    @classmethod
    def from_paths(cls, paths: Optional[List[str]]) -> BaseEnvironment:
        """
        Create an Environment for the given search paths.
        
        If `paths` is None, the current interpreter sys.path is used. The returned
        Environment will enumerate distributions by scanning the provided paths.
        
        Parameters:
            paths (Optional[List[str]]): Sequence of filesystem paths (directories or
                zip files) to search for distributions; if None, use sys.path.
        
        Returns:
            BaseEnvironment: A new Environment instance configured to search `paths`.
        """
        if paths is None:
            return cls(sys.path)
        return cls(paths)

    def _iter_distributions(self) -> Iterator[BaseDistribution]:
        """
        Iterate over all distributions found on the environment's search paths.
        
        Yields BaseDistribution objects from each configured path in a stable order:
        1. Directly discovered distributions (importlib.metadata-based).
        2. Egg distributions (legacy pkg_resources); a deprecation warning is emitted once per egg location.
        3. Distributions referenced by .egg-link files (this is yielded last to preserve pkg_resources' tie-breaking).
        
        Returns:
            Iterator[BaseDistribution]: An iterator over discovered distributions across the environment's paths.
        """
        finder = _DistributionFinder()
        for location in self._paths:
            yield from finder.find(location)
            for dist in finder.find_eggs(location):
                _emit_egg_deprecation(dist.location)
                yield dist
            # This must go last because that's how pkg_resources tie-breaks.
            yield from finder.find_linked(location)

    def get_distribution(self, name: str) -> Optional[BaseDistribution]:
        """
        Return the first distribution whose canonical name matches the given name.
        
        Name matching is performed using canonicalize_name (case- and normalization-insensitive).
        Returns the first matching BaseDistribution or None if no distribution is found.
        """
        matches = (
            distribution
            for distribution in self.iter_all_distributions()
            if distribution.canonical_name == canonicalize_name(name)
        )
        return next(matches, None)
