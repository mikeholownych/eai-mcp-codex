import email.message
import email.parser
import logging
import os
import zipfile
from typing import Collection, Iterable, Iterator, List, Mapping, NamedTuple, Optional

from pip._vendor import pkg_resources
from pip._vendor.packaging.requirements import Requirement
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
from pip._vendor.packaging.version import parse as parse_version

from pip._internal.exceptions import InvalidWheel, NoneMetadataError, UnsupportedWheel
from pip._internal.utils.egg_link import egg_link_path_from_location
from pip._internal.utils.misc import display_path, normalize_path
from pip._internal.utils.wheel import parse_wheel, read_wheel_metadata_file

from .base import (
    BaseDistribution,
    BaseEntryPoint,
    BaseEnvironment,
    DistributionVersion,
    InfoPath,
    Wheel,
)

__all__ = ["NAME", "Distribution", "Environment"]

logger = logging.getLogger(__name__)

NAME = "pkg_resources"


class EntryPoint(NamedTuple):
    name: str
    value: str
    group: str


class InMemoryMetadata:
    """IMetadataProvider that reads metadata files from a dictionary.

    This also maps metadata decoding exceptions to our internal exception type.
    """

    def __init__(self, metadata: Mapping[str, bytes], wheel_name: str) -> None:
        """
        Initialize the in-memory metadata provider.
        
        Parameters:
            metadata (Mapping[str, bytes]): Mapping of metadata file paths to their raw bytes content.
            wheel_name (str): Human-readable wheel name used in error messages and context.
        """
        self._metadata = metadata
        self._wheel_name = wheel_name

    def has_metadata(self, name: str) -> bool:
        """
        Return True if the in-memory metadata store contains an entry with the given name.
        
        Parameters:
            name (str): The metadata file name (e.g., 'METADATA', 'top_level.txt') to check.
        
        Returns:
            bool: True if the metadata name exists in the in-memory mapping, False otherwise.
        """
        return name in self._metadata

    def get_metadata(self, name: str) -> str:
        """
        Return the metadata named `name` as a decoded string.
        
        The metadata is read from the in-memory bytes store and decoded (UTF-8). If the metadata bytes cannot be decoded, raises UnsupportedWheel with a message that includes the wheel name and the metadata file name.
        
        Parameters:
            name (str): The metadata filename/key to retrieve.
        
        Returns:
            str: The decoded metadata contents.
        
        Raises:
            UnsupportedWheel: If the metadata bytes cannot be decoded as UTF-8.
        """
        try:
            return self._metadata[name].decode()
        except UnicodeDecodeError as e:
            # Augment the default error with the origin of the file.
            raise UnsupportedWheel(
                f"Error decoding metadata for {self._wheel_name}: {e} in {name} file"
            )

    def get_metadata_lines(self, name: str) -> Iterable[str]:
        """
        Return an iterable of lines for the named metadata file.
        
        Parameters:
            name (str): The metadata filename to read (e.g., 'METADATA' or 'PKG-INFO').
        
        Returns:
            Iterable[str]: An iterator over the decoded lines of the metadata file.
        """
        return pkg_resources.yield_lines(self.get_metadata(name))

    def metadata_isdir(self, name: str) -> bool:
        """
        Return False for any queried metadata path.
        
        This in-memory metadata provider does not expose directory-like metadata entries;
        calls to metadata_isdir always return False. The `name` argument is ignored.
        """
        return False

    def metadata_listdir(self, name: str) -> List[str]:
        """
        Return an empty list for any metadata directory query.
        
        This in-memory metadata provider does not expose directory listings; callers will always receive an empty list regardless of `name`.
        """
        return []

    def run_script(self, script_name: str, namespace: str) -> None:
        """
        No-op handler for running a distribution script when metadata is provided in-memory.
        
        This implementation accepts the script name and namespace for API compatibility but does not execute anything â€” in-memory metadata has no runnable script context, so both arguments are ignored.
        
        Parameters:
            script_name (str): Name of the script that would be run (ignored).
            namespace (str): Execution namespace for the script (ignored).
        """
        pass


class Distribution(BaseDistribution):
    def __init__(self, dist: pkg_resources.Distribution) -> None:
        """
        Initialize a Distribution wrapper around a pkg_resources.Distribution.
        
        Parameters:
            dist: The underlying pkg_resources.Distribution instance to wrap and retain for metadata and attribute access.
        """
        self._dist = dist

    @classmethod
    def from_directory(cls, directory: str) -> BaseDistribution:
        """
        Create a Distribution wrapper from a metadata directory on disk.
        
        Given a directory path pointing at either an *.egg-info or *.dist-info directory,
        this builds a pkg_resources.PathMetadata for that directory, constructs the
        appropriate underlying pkg_resources distribution type (Distribution for
        *.egg-info, DistInfoDistribution for *.dist-info), and returns a new wrapper
        instance around it.
        
        Parameters:
            directory (str): Path to a package metadata directory (must end with
                '.egg-info' or '.dist-info'). Trailing path separators are ignored.
        
        Returns:
            BaseDistribution: A Distribution wrapper around the constructed
            pkg_resources distribution.
        
        Notes:
            - For '.egg-info' the project name is taken from the directory basename
              without the extension.
            - For '.dist-info' the project name is taken from the directory basename
              (without the extension) split at the first '-' (the portion before the
              hyphen is used).
            - The function assumes the provided path points to a valid metadata
              directory; behavior is undefined for other inputs.
        """
        dist_dir = directory.rstrip(os.sep)

        # Build a PathMetadata object, from path to metadata. :wink:
        base_dir, dist_dir_name = os.path.split(dist_dir)
        metadata = pkg_resources.PathMetadata(base_dir, dist_dir)

        # Determine the correct Distribution object type.
        if dist_dir.endswith(".egg-info"):
            dist_cls = pkg_resources.Distribution
            dist_name = os.path.splitext(dist_dir_name)[0]
        else:
            assert dist_dir.endswith(".dist-info")
            dist_cls = pkg_resources.DistInfoDistribution
            dist_name = os.path.splitext(dist_dir_name)[0].split("-")[0]

        dist = dist_cls(base_dir, project_name=dist_name, metadata=metadata)
        return cls(dist)

    @classmethod
    def from_metadata_file_contents(
        cls,
        metadata_contents: bytes,
        filename: str,
        project_name: str,
    ) -> BaseDistribution:
        """
        Create a Distribution from raw METADATA contents.
        
        Constructs an in-memory DistInfoDistribution using the provided METADATA file bytes and returns a wrapped BaseDistribution.
        
        Parameters:
            metadata_contents (bytes): Raw bytes of a METADATA file.
            filename (str): Path or identifier used as the distribution location and for error context.
            project_name (str): Project name to associate with the created distribution.
        
        Returns:
            BaseDistribution: A Distribution wrapping the created pkg_resources DistInfoDistribution.
        """
        metadata_dict = {
            "METADATA": metadata_contents,
        }
        dist = pkg_resources.DistInfoDistribution(
            location=filename,
            metadata=InMemoryMetadata(metadata_dict, filename),
            project_name=project_name,
        )
        return cls(dist)

    @classmethod
    def from_wheel(cls, wheel: Wheel, name: str) -> BaseDistribution:
        """
        Create a Distribution wrapper from a Wheel by reading its .dist-info metadata.
        
        Reads the wheel archive, collects all files under the wheel's info directory into an in-memory
        metadata provider, and returns a Distribution wrapping a pkg_resources DistInfoDistribution
        populated with that metadata and the given project name.
        
        Parameters:
            wheel (Wheel): Wheel object to read the metadata from.
            name (str): Project name to associate with the produced distribution.
        
        Returns:
            BaseDistribution: A Distribution wrapping a pkg_resources DistInfoDistribution built
            from the wheel's metadata.
        
        Raises:
            InvalidWheel: If the wheel archive is not a valid zip file.
            UnsupportedWheel: If the wheel's contents or metadata are not supported/valid.
        """
        try:
            with wheel.as_zipfile() as zf:
                info_dir, _ = parse_wheel(zf, name)
                metadata_dict = {
                    path.split("/", 1)[-1]: read_wheel_metadata_file(zf, path)
                    for path in zf.namelist()
                    if path.startswith(f"{info_dir}/")
                }
        except zipfile.BadZipFile as e:
            raise InvalidWheel(wheel.location, name) from e
        except UnsupportedWheel as e:
            raise UnsupportedWheel(f"{name} has an invalid wheel, {e}")
        dist = pkg_resources.DistInfoDistribution(
            location=wheel.location,
            metadata=InMemoryMetadata(metadata_dict, wheel.location),
            project_name=name,
        )
        return cls(dist)

    @property
    def location(self) -> Optional[str]:
        """
        Return the filesystem location of the underlying distribution.
        
        Returns:
            Optional[str]: Absolute path to the distribution location, or `None` if the
            underlying pkg_resources distribution does not expose a location.
        """
        return self._dist.location

    @property
    def installed_location(self) -> Optional[str]:
        """
        Return the installed location path for this distribution, preferring an egg-link target when present.
        
        If an egg-link file is associated with the distribution, its target is returned; otherwise the distribution's location is returned. The returned path is normalized. Returns None if no location is available.
        """
        egg_link = egg_link_path_from_location(self.raw_name)
        if egg_link:
            location = egg_link
        elif self.location:
            location = self.location
        else:
            return None
        return normalize_path(location)

    @property
    def info_location(self) -> Optional[str]:
        """
        Return the path to the distribution's metadata directory (the .egg-info or .dist-info location).
        
        Returns:
            Optional[str]: Absolute or relative path to the distribution's metadata directory, or None if unavailable.
        """
        return self._dist.egg_info

    @property
    def installed_by_distutils(self) -> bool:
        # A distutils-installed distribution is provided by FileMetadata. This
        # provider has a "path" attribute not present anywhere else. Not the
        # best introspection logic, but pip has been doing this for a long time.
        """
        Return True if this distribution appears to have been installed by distutils.
        
        Determines this by checking whether the underlying pkg_resources distribution's
        metadata provider exposes a `path` attribute (the heuristic used here to
        identify FileMetadata-backed, distutils-style installations). Returns False
        if that attribute is absent or falsy.
        """
        try:
            return bool(self._dist._provider.path)
        except AttributeError:
            return False

    @property
    def canonical_name(self) -> NormalizedName:
        """
        Return the distribution's canonicalized (normalized) project name.
        
        The canonical name is produced by normalizing the underlying pkg_resources
        distribution's project_name using pip's canonicalization rules.
        
        Returns:
            NormalizedName: The normalized project name suitable for comparisons and
            lookups.
        """
        return canonicalize_name(self._dist.project_name)

    @property
    def version(self) -> DistributionVersion:
        """
        Return the distribution's version as a parsed DistributionVersion.
        
        The value is the package version from the underlying pkg_resources distribution,
        parsed into a DistributionVersion (a normalized, comparable version object).
        """
        return parse_version(self._dist.version)

    def is_file(self, path: InfoPath) -> bool:
        """
        Return whether the distribution contains the given metadata file.
        
        Parameters:
            path (InfoPath): Path (relative to the distribution's metadata/info directory) to check.
        
        Returns:
            bool: True if the metadata file exists, False otherwise.
        """
        return self._dist.has_metadata(str(path))

    def iter_distutils_script_names(self) -> Iterator[str]:
        """
        Yield the names of Distutils-style scripts provided by the distribution.
        
        This iterates the distribution's metadata "scripts" directory and yields each
        script filename as a string.
        
        Returns:
            Iterator[str]: An iterator over script filenames listed in the distribution's
            metadata "scripts" directory.
        """
        yield from self._dist.metadata_listdir("scripts")

    def read_text(self, path: InfoPath) -> str:
        """
        Return the contents of a metadata file for this distribution.
        
        Parameters:
            path (InfoPath): Path-like identifier of a metadata file (e.g., "METADATA", "PKG-INFO",
                or other files inside the distribution's info directory).
        
        Returns:
            str: The decoded text content of the requested metadata file.
        
        Raises:
            FileNotFoundError: If the distribution does not contain the named metadata file.
            NoneMetadataError: If the underlying pkg_resources distribution reports the file but
                returns None for its contents.
        """
        name = str(path)
        if not self._dist.has_metadata(name):
            raise FileNotFoundError(name)
        content = self._dist.get_metadata(name)
        if content is None:
            raise NoneMetadataError(self, name)
        return content

    def iter_entry_points(self) -> Iterable[BaseEntryPoint]:
        """
        Yield entry points declared by the underlying distribution.
        
        Each yielded EntryPoint is a NamedTuple with fields (name, value, group). Entry points are read from the distribution's entry map; the map's keys are used as the `group`. Each entry's string form is split on the first '=' to separate the entry point name (left) and value (right), and both sides are stripped of surrounding whitespace.
        """
        for group, entries in self._dist.get_entry_map().items():
            for name, entry_point in entries.items():
                name, _, value = str(entry_point).partition("=")
                yield EntryPoint(name=name.strip(), value=value.strip(), group=group)

    def _metadata_impl(self) -> email.message.Message:
        """
        Return the parsed distribution metadata as an email.message.Message.
        
        Selects the appropriate metadata file name ("METADATA" for dist-info, "PKG-INFO" otherwise),
        reads its text, and parses it with an email FeedParser. If the metadata file is missing,
        an empty string is parsed instead (a warning is emitted). The caller receives the parsed
        email.message.Message representing the distribution metadata.
        
        Returns:
            email.message.Message: Parsed metadata message.
        
        Raises:
            NoneMetadataError: If the distribution reports its metadata exists but the metadata
                provider returns None for the file contents.
        """
        if isinstance(self._dist, pkg_resources.DistInfoDistribution):
            metadata_name = "METADATA"
        else:
            metadata_name = "PKG-INFO"
        try:
            metadata = self.read_text(metadata_name)
        except FileNotFoundError:
            if self.location:
                displaying_path = display_path(self.location)
            else:
                displaying_path = repr(self.location)
            logger.warning("No metadata found in %s", displaying_path)
            metadata = ""
        feed_parser = email.parser.FeedParser()
        feed_parser.feed(metadata)
        return feed_parser.close()

    def iter_dependencies(self, extras: Collection[str] = ()) -> Iterable[Requirement]:
        """
        Return the distribution's requirements, optionally filtered by extras.
        
        If `extras` are provided, names are sanitized with `pkg_resources.safe_extra`
        and restricted to extras actually provided by the distribution before querying
        pkg_resources. Returns an iterable of `Requirement` objects.
        """
        if extras:  # pkg_resources raises on invalid extras, so we sanitize.
            extras = frozenset(pkg_resources.safe_extra(e) for e in extras)
            extras = extras.intersection(self._dist.extras)
        return self._dist.requires(extras)

    def iter_provided_extras(self) -> Iterable[str]:
        """
        Return an iterable of extras provided by this distribution.
        
        The extras are the optional feature names declared by the underlying pkg_resources
        distribution and are returned as strings.
        """
        return self._dist.extras

    def is_extra_provided(self, extra: str) -> bool:
        """
        Return True if the distribution provides the given extra.
        
        The extra name is normalized (via pkg_resources.safe_extra) before checking
        against the distribution's declared extras.
        
        Parameters:
            extra (str): The extra name to check.
        
        Returns:
            bool: True if the normalized extra is declared by the distribution, False otherwise.
        """
        return pkg_resources.safe_extra(extra) in self._dist.extras


class Environment(BaseEnvironment):
    def __init__(self, ws: pkg_resources.WorkingSet) -> None:
        """
        Initialize the Environment with a pkg_resources.WorkingSet.
        
        The provided WorkingSet is stored as the backend used to list and locate
        distributions.
        """
        self._ws = ws

    @classmethod
    def default(cls) -> BaseEnvironment:
        """
        Create an Environment backed by the global pkg_resources working set.
        
        Returns:
            BaseEnvironment: An Environment instance using pkg_resources.working_set as its
            underlying WorkingSet.
        """
        return cls(pkg_resources.working_set)

    @classmethod
    def from_paths(cls, paths: Optional[List[str]]) -> BaseEnvironment:
        """
        Create an Environment backed by a pkg_resources.WorkingSet built from the given paths.
        
        Parameters:
            paths (Optional[List[str]]): Iterable of filesystem paths to search for distributions. If None, pkg_resources.WorkingSet will use its default search paths.
        
        Returns:
            BaseEnvironment: An Environment wrapping the constructed WorkingSet.
        """
        return cls(pkg_resources.WorkingSet(paths))

    def _iter_distributions(self) -> Iterator[BaseDistribution]:
        """
        Yield Distribution wrappers for every distribution in the underlying WorkingSet.
        
        Returns:
            Iterator[BaseDistribution]: An iterator over Distribution instances that wrap
            the pkg_resources distributions present in the working set.
        """
        for dist in self._ws:
            yield Distribution(dist)

    def _search_distribution(self, name: str) -> Optional[BaseDistribution]:
        """Find a distribution matching the ``name`` in the environment.

        This searches from *all* distributions available in the environment, to
        match the behavior of ``pkg_resources.get_distribution()``.
        """
        canonical_name = canonicalize_name(name)
        for dist in self.iter_all_distributions():
            if dist.canonical_name == canonical_name:
                return dist
        return None

    def get_distribution(self, name: str) -> Optional[BaseDistribution]:
        # Search the distribution by looking through the working set.
        """
        Return the distribution matching `name` from the environment, or None if not found.
        
        This first searches the cached working set. If no match is found, it calls
        the underlying pkg_resources.WorkingSet.require(name) to refresh the working
        set and retries the search. If the requirement is not present, returns None.
        
        Note: no version specifiers are provided when calling `require`, so
        pkg_resources.VersionConflict cannot occur here; pkg_resources.DistributionNotFound
        is handled and results in returning None. Calling this method may mutate the
        underlying WorkingSet.
        """
        dist = self._search_distribution(name)
        if dist:
            return dist

        # If distribution could not be found, call working_set.require to
        # update the working set, and try to find the distribution again.
        # This might happen for e.g. when you install a package twice, once
        # using setup.py develop and again using setup.py install. Now when
        # running pip uninstall twice, the package gets removed from the
        # working set in the first uninstall, so we have to populate the
        # working set again so that pip knows about it and the packages gets
        # picked up and is successfully uninstalled the second time too.
        try:
            # We didn't pass in any version specifiers, so this can never
            # raise pkg_resources.VersionConflict.
            self._ws.require(name)
        except pkg_resources.DistributionNotFound:
            return None
        return self._search_distribution(name)
