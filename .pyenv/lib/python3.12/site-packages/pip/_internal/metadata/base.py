import csv
import email.message
import functools
import json
import logging
import pathlib
import re
import zipfile
from typing import (
    IO,
    TYPE_CHECKING,
    Any,
    Collection,
    Container,
    Dict,
    Iterable,
    Iterator,
    List,
    NamedTuple,
    Optional,
    Tuple,
    Union,
)

from pip._vendor.packaging.requirements import Requirement
from pip._vendor.packaging.specifiers import InvalidSpecifier, SpecifierSet
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
from pip._vendor.packaging.version import LegacyVersion, Version

from pip._internal.exceptions import NoneMetadataError
from pip._internal.locations import site_packages, user_site
from pip._internal.models.direct_url import (
    DIRECT_URL_METADATA_NAME,
    DirectUrl,
    DirectUrlValidationError,
)
from pip._internal.utils.compat import stdlib_pkgs  # TODO: Move definition here.
from pip._internal.utils.egg_link import egg_link_path_from_sys_path
from pip._internal.utils.misc import is_local, normalize_path
from pip._internal.utils.urls import url_to_path

from ._json import msg_to_json

if TYPE_CHECKING:
    from typing import Protocol
else:
    Protocol = object

DistributionVersion = Union[LegacyVersion, Version]

InfoPath = Union[str, pathlib.PurePath]

logger = logging.getLogger(__name__)


class BaseEntryPoint(Protocol):
    @property
    def name(self) -> str:
        """
        Return the distribution's declared name.
        
        This should provide the distribution name as reported by its metadata (suitable for display).
        Implementations may return the raw metadata Name value or a canonicalized form depending on context.
        """
        raise NotImplementedError()

    @property
    def value(self) -> str:
        """
        Return the entry point's declared value string.
        
        This is the raw target specifier for the entry point as declared by the distribution
        (e.g., "package.module:attribute" or a console script specifier). Implementations
        should return the exact string used in metadata, not a resolved object.
        """
        raise NotImplementedError()

    @property
    def group(self) -> str:
        """
        Return the entry-point group name.
        
        Returns:
            str: The entry-point group (namespace) this entry point is registered under,
            for example "console_scripts" or a plugin group name.
        """
        raise NotImplementedError()


def _convert_installed_files_path(
    entry: Tuple[str, ...],
    info: Tuple[str, ...],
) -> str:
    """
    Convert a legacy installed-files.txt entry (path parts) into a RECORD-style path
    relative to the package root.
    
    The legacy entries are stored relative to the distribution's info directory
    (e.g., *.egg-info). This function folds leading ".." components from the entry
    into the provided info path parts: each leading ".." removes one trailing part
    from `info` (or, if `info` is already empty or ends with "..", accumulates
    ".." into `info`). The remaining entry parts are then joined onto the trimmed
    `info` parts and returned as a string path. This avoids using absolute paths or
    Path.resolve() so symlink layouts are preserved.
    
    Parameters:
        entry (Tuple[str, ...]): Path components from installed-files.txt entry.
        info (Tuple[str, ...]): Path components of the distribution's info
            directory relative to the package root.
    
    Returns:
        str: A POSIX/OS path string for the entry relative to the package root.
    """
    while entry and entry[0] == "..":
        if not info or info[-1] == "..":
            info += ("..",)
        else:
            info = info[:-1]
        entry = entry[1:]
    return str(pathlib.Path(*info, *entry))


class RequiresEntry(NamedTuple):
    requirement: str
    extra: str
    marker: str


class BaseDistribution(Protocol):
    @classmethod
    def from_directory(cls, directory: str) -> "BaseDistribution":
        """Load the distribution from a metadata directory.

        :param directory: Path to a metadata directory, e.g. ``.dist-info``.
        """
        raise NotImplementedError()

    @classmethod
    def from_metadata_file_contents(
        cls,
        metadata_contents: bytes,
        filename: str,
        project_name: str,
    ) -> "BaseDistribution":
        """
        Create a "shallow" BaseDistribution from the raw bytes of a METADATA file.
        
        This is used to implement PEP 658: build a lightweight distribution object suitable
        for dependency resolution without downloading or unpacking the full distribution.
        
        Parameters:
            metadata_contents (bytes): Raw contents of a METADATA file.
            filename (str): Logical filename to associate with this metadata (used for
                reporting or provenance).
            project_name (str): The project name this metadata describes.
        
        Returns:
            BaseDistribution: A distribution instance that exposes metadata and other
            read-only properties required for resolution.
        """
        raise NotImplementedError()

    @classmethod
    def from_wheel(cls, wheel: "Wheel", name: str) -> "BaseDistribution":
        """
        Create a BaseDistribution instance by loading metadata from the provided wheel.
        
        Parameters:
            wheel: A Wheel implementing as_zipfile(); the source wheel archive to load.
            name: The wheel filename (used for diagnostics and metadata-derived name when needed).
        
        Raises:
            InvalidWheel: If the wheel archive cannot be read (e.g., zipfile.BadZipFile).
            UnsupportedWheel: If the wheel is a valid zip but its internal layout or metadata is incompatible.
        """
        raise NotImplementedError()

    def __repr__(self) -> str:
        """
        Return a developer-facing representation of the distribution.
        
        The string includes the distribution's raw name, version, and location in the format:
            "<raw_name> <version> (<location>)"
        Used primarily for debugging and logging.
        """
        return f"{self.raw_name} {self.version} ({self.location})"

    def __str__(self) -> str:
        """
        Return a concise human-readable representation of the distribution.
        
        The string is the distribution's raw name followed by its version, separated by a space.
        Returns:
            A short display string like "PackageName 1.2.3".
        """
        return f"{self.raw_name} {self.version}"

    @property
    def location(self) -> Optional[str]:
        """Where the distribution is loaded from.

        A string value is not necessarily a filesystem path, since distributions
        can be loaded from other sources, e.g. arbitrary zip archives. ``None``
        means the distribution is created in-memory.

        Do not canonicalize this value with e.g. ``pathlib.Path.resolve()``. If
        this is a symbolic link, we want to preserve the relative path between
        it and files in the distribution.
        """
        raise NotImplementedError()

    @property
    def editable_project_location(self) -> Optional[str]:
        """
        Return the filesystem path to the editable project's root, or None.
        
        If the distribution was installed as a local editable (via a Direct URL marked editable),
        this returns the local path referenced by that direct URL (the directory containing
        pyproject.toml or setup.py). As a fallback for legacy editable installs recorded with
        an .egg-link, this returns the distribution's recorded location. Returns None when the
        distribution is not editable.
        """
        # TODO: this property is relatively costly to compute, memoize it ?
        direct_url = self.direct_url
        if direct_url:
            if direct_url.is_local_editable():
                return url_to_path(direct_url.url)
        else:
            # Search for an .egg-link file by walking sys.path, as it was
            # done before by dist_is_editable().
            egg_link_path = egg_link_path_from_sys_path(self.raw_name)
            if egg_link_path:
                # TODO: get project location from second line of egg_link file
                #       (https://github.com/pypa/pip/issues/10243)
                return self.location
        return None

    @property
    def installed_location(self) -> Optional[str]:
        """
        Return the distribution's installed location, typically a site-packages directory.
        
        This is the filesystem path where the package is actually installed for import/use.
        For most distributions this equals the distribution's `location`. For legacy
        develop (editable) installs, `location` may point at the project source tree;
        `installed_location` instead points to the installation target referenced by
        the corresponding `.egg-link` file. The path returned is normalized (symlinks
        resolved/removed) when available. May be None for in-memory or non-filesystem
        distributions.
        """
        raise NotImplementedError()

    @property
    def info_location(self) -> Optional[str]:
        """Location of the .[egg|dist]-info directory or file.

        Similarly to ``location``, a string value is not necessarily a
        filesystem path. ``None`` means the distribution is created in-memory.

        For a modern .dist-info installation on disk, this should be something
        like ``{location}/{raw_name}-{version}.dist-info``.

        Do not canonicalize this value with e.g. ``pathlib.Path.resolve()``. If
        this is a symbolic link, we want to preserve the relative path between
        it and other files in the distribution.
        """
        raise NotImplementedError()

    @property
    def installed_by_distutils(self) -> bool:
        """
        Return True if the distribution's metadata is stored as a legacy distutils file.
        
        For legacy distutils installs, metadata is stored in a single file at
        `info_location` (rather than a directory like `.dist-info`/`.egg-info`). This
        method returns True when `info_location` is set and points to a file, which
        is used to differentiate uninstall behavior for such installs.
        """
        info_location = self.info_location
        if not info_location:
            return False
        return pathlib.Path(info_location).is_file()

    @property
    def installed_as_egg(self) -> bool:
        """Whether this distribution is installed as an egg.

        This usually indicates the distribution was installed by (older versions
        of) easy_install.
        """
        location = self.location
        if not location:
            return False
        return location.endswith(".egg")

    @property
    def installed_with_setuptools_egg_info(self) -> bool:
        """Whether this distribution is installed with the ``.egg-info`` format.

        This usually indicates the distribution was installed with setuptools
        with an old pip version or with ``single-version-externally-managed``.

        Note that this ensure the metadata store is a directory. distutils can
        also installs an ``.egg-info``, but as a file, not a directory. This
        property is *False* for that case. Also see ``installed_by_distutils``.
        """
        info_location = self.info_location
        if not info_location:
            return False
        if not info_location.endswith(".egg-info"):
            return False
        return pathlib.Path(info_location).is_dir()

    @property
    def installed_with_dist_info(self) -> bool:
        """Whether this distribution is installed with the "modern format".

        This indicates a "modern" installation, e.g. storing metadata in the
        ``.dist-info`` directory. This applies to installations made by
        setuptools (but through pip, not directly), or anything using the
        standardized build backend interface (PEP 517).
        """
        info_location = self.info_location
        if not info_location:
            return False
        if not info_location.endswith(".dist-info"):
            return False
        return pathlib.Path(info_location).is_dir()

    @property
    def canonical_name(self) -> NormalizedName:
        """
        Return the distribution's canonical normalized name.
        
        This is the normalized project name (PEP 503 / packaging.normalize) used for
        comparison and lookup (e.g., keys in dependency resolution or environment
        queries).
        
        Returns:
            NormalizedName: The distribution name in its canonical, normalized form.
        """
        raise NotImplementedError()

    @property
    def version(self) -> DistributionVersion:
        """
        Return the distribution's version.
        
        Returns:
            DistributionVersion: The distribution version object (a PEP 440 `Version` or a legacy `LegacyVersion`), representing the installed/package version.
        """
        raise NotImplementedError()

    @property
    def setuptools_filename(self) -> str:
        """Convert a project name to its setuptools-compatible filename.

        This is a copy of ``pkg_resources.to_filename()`` for compatibility.
        """
        return self.raw_name.replace("-", "_")

    @property
    def direct_url(self) -> Optional[DirectUrl]:
        """
        Return the parsed DirectUrl for this distribution, or None.
        
        Reads the distribution metadata file named by DIRECT_URL_METADATA_NAME and returns
        a DirectUrl parsed from its JSON contents. Returns None if the metadata file is
        missing or if the file exists but cannot be decoded/validated. A warning is
        logged when parsing or validation fails.
        """
        try:
            content = self.read_text(DIRECT_URL_METADATA_NAME)
        except FileNotFoundError:
            return None
        try:
            return DirectUrl.from_json(content)
        except (
            UnicodeDecodeError,
            json.JSONDecodeError,
            DirectUrlValidationError,
        ) as e:
            logger.warning(
                "Error parsing %s for %s: %s",
                DIRECT_URL_METADATA_NAME,
                self.canonical_name,
                e,
            )
            return None

    @property
    def installer(self) -> str:
        """
        Return the installer recorded in the distribution's INSTALLER file.
        
        Reads the "INSTALLER" entry from the distribution's info and returns the first non-empty
        line (stripped). If the file is missing, unreadable, contains only blank lines, or
        parsing fails (OSError, ValueError, or NoneMetadataError), an empty string is returned.
        """
        try:
            installer_text = self.read_text("INSTALLER")
        except (OSError, ValueError, NoneMetadataError):
            return ""  # Fail silently if the installer file cannot be read.
        for line in installer_text.splitlines():
            cleaned_line = line.strip()
            if cleaned_line:
                return cleaned_line
        return ""

    @property
    def requested(self) -> bool:
        """
        Return True if this distribution is marked as "requested" (i.e., its info directory contains a `REQUESTED` file).
        
        Returns:
            bool: True when a `REQUESTED` file is present, otherwise False.
        """
        return self.is_file("REQUESTED")

    @property
    def editable(self) -> bool:
        """
        Return True if the distribution is installed in editable (development) mode.
        
        Returns:
            bool: True when an editable project location is available, False otherwise.
        """
        return bool(self.editable_project_location)

    @property
    def local(self) -> bool:
        """
        Return True if the distribution is installed in the current Python environment.
        
        Returns False if the distribution has no recorded installed location. For installations
        outside a virtual environment this will be True (i.e., when running outside a venv the
        environment is considered local).
        """
        if self.installed_location is None:
            return False
        return is_local(self.installed_location)

    @property
    def in_usersite(self) -> bool:
        """
        Return True if the distribution is installed in the current user's site-packages directory.
        
        Returns:
            bool: True when the distribution has an installed_location and that location is under the environment's user-site directory; False if the installed location is unknown or the user-site directory is unavailable.
        """
        if self.installed_location is None or user_site is None:
            return False
        return self.installed_location.startswith(normalize_path(user_site))

    @property
    def in_site_packages(self) -> bool:
        """
        Return True if the distribution is installed in the environment's site-packages directory.
        
        Returns False when the distribution has no known installed_location or when the environment's
        site-packages path is not available.
        """
        if self.installed_location is None or site_packages is None:
            return False
        return self.installed_location.startswith(normalize_path(site_packages))

    def is_file(self, path: InfoPath) -> bool:
        """Check whether an entry in the info directory is a file."""
        raise NotImplementedError()

    def iter_distutils_script_names(self) -> Iterator[str]:
        """
        Yield the names of script files declared via setuptools/distutils `scripts` in the distribution.
        
        Some projects declare plain script files via the `scripts` argument in setup.py/setup.cfg; those files are installed into the distribution's scripts directory. This method should iterate over the recorded script filenames (not entry-point names) for the distribution and yield each filename as a string.
        """
        raise NotImplementedError()

    def read_text(self, path: InfoPath) -> str:
        """
        Read and return the text contents of a file from the distribution's info directory.
        
        The `path` is interpreted relative to the distribution's info directory (e.g., a
        path inside a .dist-info or .egg-info). Implementations should return the file
        contents decoded as text.
        
        Raises:
            FileNotFoundError: If `path` does not exist in the info directory.
            NoneMetadataError: If `path` exists but the metadata cannot be read or is
                otherwise unavailable.
        """
        raise NotImplementedError()

    def iter_entry_points(self) -> Iterable[BaseEntryPoint]:
        """
        Yield the distribution's declared entry points.
        
        Return an iterable of BaseEntryPoint objects representing the entry points declared by
        the distribution (eg. those defined in `entry_points.txt` or equivalent metadata).
        Each yielded entry point exposes `name`, `value`, and `group`.
        
        Returns:
            Iterable[BaseEntryPoint]: An iterator over the distribution's entry points.
        """
        raise NotImplementedError()

    def _metadata_impl(self) -> email.message.Message:
        """
        Return the parsed distribution metadata as an email.message.Message.
        
        This abstract method must be implemented by concrete distributions to produce
        the raw parsed METADATA/PKG-INFO content for the distribution. The returned
        object is used as the authoritative metadata message within the distribution
        API.
        
        Returns:
            email.message.Message: The parsed metadata message.
        
        Raises:
            NotImplementedError: Implementations must override this method.
        """
        raise NotImplementedError()

    @functools.lru_cache(maxsize=1)
    def _metadata_cached(self) -> email.message.Message:
        # When we drop python 3.7 support, move this to the metadata property and use
        # functools.cached_property instead of lru_cache.
        """
        Return the parsed distribution metadata message with egg-info requirements merged in.
        
        Calls the underlying _metadata_impl() to obtain an email.message.Message and ensures any legacy
        egg-info requires/provides-extra entries are added via _add_egg_info_requires. The returned
        Message may be mutated by that augmentation. This method is intended to be cached (single-result
        cache) for repeated access.
        """
        metadata = self._metadata_impl()
        self._add_egg_info_requires(metadata)
        return metadata

    @property
    def metadata(self) -> email.message.Message:
        """Metadata of distribution parsed from e.g. METADATA or PKG-INFO.

        This should return an empty message if the metadata file is unavailable.

        :raises NoneMetadataError: If the metadata file is available, but does
            not contain valid metadata.
        """
        return self._metadata_cached()

    @property
    def metadata_dict(self) -> Dict[str, Any]:
        """PEP 566 compliant JSON-serializable representation of METADATA or PKG-INFO.

        This should return an empty dict if the metadata file is unavailable.

        :raises NoneMetadataError: If the metadata file is available, but does
            not contain valid metadata.
        """
        return msg_to_json(self.metadata)

    @property
    def metadata_version(self) -> Optional[str]:
        """Value of "Metadata-Version:" in distribution metadata, if available."""
        return self.metadata.get("Metadata-Version")

    @property
    def raw_name(self) -> str:
        """
        Return the distribution's declared name from its metadata.
        
        If the metadata contains a `Name` field, that value is returned; otherwise
        falls back to the distribution's canonical_name.
        
        Returns:
            The distribution name as declared in metadata, or the canonical name if
            the metadata `Name` field is missing.
        """
        # The metadata should NEVER be missing the Name: key, but if it somehow
        # does, fall back to the known canonical name.
        return self.metadata.get("Name", self.canonical_name)

    @property
    def requires_python(self) -> SpecifierSet:
        """
        Return the parsed `SpecifierSet` for the distribution's "Requires-Python" metadata.
        
        If the metadata key is absent or its value is not a valid specifier, an empty
        `SpecifierSet` is returned. An invalid specifier will also emit a warning to
        the module logger.
        """
        value = self.metadata.get("Requires-Python")
        if value is None:
            return SpecifierSet()
        try:
            # Convert to str to satisfy the type checker; this can be a Header object.
            spec = SpecifierSet(str(value))
        except InvalidSpecifier as e:
            message = "Package %r has an invalid Requires-Python: %s"
            logger.warning(message, self.raw_name, e)
            return SpecifierSet()
        return spec

    def iter_dependencies(self, extras: Collection[str] = ()) -> Iterable[Requirement]:
        """
        Yield the distribution's install-time requirements as Requirement objects.
        
        For distributions with metadata (PEP 566/566+), this should yield the parsed
        `Requires-Dist` entries. Entries conditional on extras or environment markers
        must be preserved as Requirement objects with their markers.
        
        Parameters:
            extras (Collection[str]): An optional collection of extra names to consider
                active when evaluating extra-specific requirements. Implementations
                should include requirements that are unconditioned or conditioned on any
                of the provided extras.
        
        Returns:
            Iterable[Requirement]: An iterable of pkg_resources/packaging Requirement
            objects representing the distribution's declared dependencies.
        """
        raise NotImplementedError()

    def iter_provided_extras(self) -> Iterable[str]:
        """
        Return the extras this distribution advertises.
        
        One-line summary:
            Extras declared as provided by the distribution.
        
        Detailed:
            For modern distributions (PEP 376 .dist-info), these are the values of
            the `Provides-Extra` metadata entries. Legacy egg-info metadata may also
            expose extras (e.g., via requires.txt); names from older metadata may be
            inconsistently normalized.
        
        Returns:
            An iterable of extra names (str). For programmatic checks use
            `is_extra_provided` instead of relying on this sequence's normalization.
        """
        raise NotImplementedError()

    def is_extra_provided(self, extra: str) -> bool:
        """
        Return True if the distribution declares the given extra.
        
        The comparison is done after normalizing the supplied `extra` according to
        packaging/PEP normalization rules for extras (so callers need not provide a
        pre-normalized name). This exists to abstract over differences with legacy
        tools (e.g., pkg_resources) that may use different normalization rules.
        
        Parameters:
            extra (str): The name of the extra to check (may be in any case or form).
        
        Returns:
            bool: True if the extra is provided by this distribution, False otherwise.
        """
        raise NotImplementedError()

    def _iter_declared_entries_from_record(self) -> Optional[Iterator[str]]:
        """
        Yield normalized path entries declared in the distribution's RECORD file.
        
        Reads the "RECORD" file from the distribution info and returns an iterator over
        the first column of each CSV row (the recorded file paths), normalized via
        pathlib.Path to a string. If the RECORD file is not present, returns None.
        """
        try:
            text = self.read_text("RECORD")
        except FileNotFoundError:
            return None
        # This extra Path-str cast normalizes entries.
        return (str(pathlib.Path(row[0])) for row in csv.reader(text.splitlines()))

    def _iter_declared_entries_from_legacy(self) -> Optional[Iterator[str]]:
        """
        Return an iterator of declared distribution file paths derived from a legacy
        `installed-files.txt`, converted to RECORD-style paths when possible.
        
        If `installed-files.txt` is absent, returns None. If the distribution's
        location or info_location is unavailable, or the info directory is not a
        subpath of the distribution location, the function yields the raw lines from
        `installed-files.txt` unchanged. Otherwise, each legacy entry is converted
        (relative to the package root) using `_convert_installed_files_path` and
        yielded as a normalized string.
        """
        try:
            text = self.read_text("installed-files.txt")
        except FileNotFoundError:
            return None
        paths = (p for p in text.splitlines(keepends=False) if p)
        root = self.location
        info = self.info_location
        if root is None or info is None:
            return paths
        try:
            info_rel = pathlib.Path(info).relative_to(root)
        except ValueError:  # info is not relative to root.
            return paths
        if not info_rel.parts:  # info *is* root.
            return paths
        return (
            _convert_installed_files_path(pathlib.Path(p).parts, info_rel.parts)
            for p in paths
        )

    def iter_declared_entries(self) -> Optional[Iterator[str]]:
        """Iterate through file entries declared in this distribution.

        For modern .dist-info distributions, this is the files listed in the
        ``RECORD`` metadata file. For legacy setuptools distributions, this
        comes from ``installed-files.txt``, with entries normalized to be
        compatible with the format used by ``RECORD``.

        :return: An iterator for listed entries, or None if the distribution
            contains neither ``RECORD`` nor ``installed-files.txt``.
        """
        return (
            self._iter_declared_entries_from_record()
            or self._iter_declared_entries_from_legacy()
        )

    def _iter_requires_txt_entries(self) -> Iterator[RequiresEntry]:
        """Parse a ``requires.txt`` in an egg-info directory.

        This is an INI-ish format where an egg-info stores dependencies. A
        section name describes extra other environment markers, while each entry
        is an arbitrary string (not a key-value pair) representing a dependency
        as a requirement string (no markers).

        There is a construct in ``importlib.metadata`` called ``Sectioned`` that
        does mostly the same, but the format is currently considered private.
        """
        try:
            content = self.read_text("requires.txt")
        except FileNotFoundError:
            return
        extra = marker = ""  # Section-less entries don't have markers.
        for line in content.splitlines():
            line = line.strip()
            if not line or line.startswith("#"):  # Comment; ignored.
                continue
            if line.startswith("[") and line.endswith("]"):  # A section header.
                extra, _, marker = line.strip("[]").partition(":")
                continue
            yield RequiresEntry(requirement=line, extra=extra, marker=marker)

    def _iter_egg_info_extras(self) -> Iterable[str]:
        """
        Yield unique extras provided by the distribution's legacy egg-info (requires.txt).
        
        Yields canonicalized extra names (normalized with the project's canonicalization rules) in the order they are found in requires.txt.
        Empty extras are skipped and duplicates are suppressed.
        """
        known_extras = {""}
        for entry in self._iter_requires_txt_entries():
            extra = canonicalize_name(entry.extra)
            if extra in known_extras:
                continue
            known_extras.add(extra)
            yield extra

    def _iter_egg_info_dependencies(self) -> Iterable[str]:
        """
        Yield dependency strings derived from legacy egg-info requires.txt, normalized to PEP 508 form.
        
        Each returned string is a PEP 508 requirement (e.g. "pkg>=1.0" or
        "pkg; extra == \"feature\" and python_version<'3.8'"). Extras are
        normalized (canonicalized) before being placed into the environment marker,
        and when both an extra and an existing marker are present they are combined
        with a logical AND. The iterator yields one requirement string per entry
        from the egg-info requires.txt data.
        """
        for entry in self._iter_requires_txt_entries():
            extra = canonicalize_name(entry.extra)
            if extra and entry.marker:
                marker = f'({entry.marker}) and extra == "{extra}"'
            elif extra:
                marker = f'extra == "{extra}"'
            elif entry.marker:
                marker = entry.marker
            else:
                marker = ""
            if marker:
                yield f"{entry.requirement} ; {marker}"
            else:
                yield entry.requirement

    def _add_egg_info_requires(self, metadata: email.message.Message) -> None:
        """
        Add dependency and extras declarations to a parsed metadata message using legacy egg-info data.
        
        If the Message has no "Requires-Dist" headers, this populates them from the distribution's
        egg-info-derived dependencies (via _iter_egg_info_dependencies). If the Message has no
        "Provides-Extra" headers, this populates them from the distribution's egg-info extras
        (via _iter_egg_info_extras).
        
        The provided Message is modified in-place; the function returns None.
        Parameters:
            metadata (email.message.Message): Parsed distribution metadata to augment.
        """
        if not metadata.get_all("Requires-Dist"):
            for dep in self._iter_egg_info_dependencies():
                metadata["Requires-Dist"] = dep
        if not metadata.get_all("Provides-Extra"):
            for extra in self._iter_egg_info_extras():
                metadata["Provides-Extra"] = extra


class BaseEnvironment:
    """An environment containing distributions to introspect."""

    @classmethod
    def default(cls) -> "BaseEnvironment":
        """
        Create a BaseEnvironment representing the current Python environment.
        
        Implementations should return an environment instance configured with the default
        search paths and platform-specific settings for discovering installed
        distributions (e.g., site-packages, user site). This is an abstract factory
        method and must be overridden by concrete subclasses.
        
        Returns:
            BaseEnvironment: an environment instance for the current runtime.
        """
        raise NotImplementedError()

    @classmethod
    def from_paths(cls, paths: Optional[List[str]]) -> "BaseEnvironment":
        """
        Create a BaseEnvironment configured to inspect distributions found at the given filesystem paths.
        
        Implementations should use the provided list of paths as the locations to search for distributions. If `paths` is None, an implementation may choose a sensible default discovery behavior.
        
        Parameters:
            paths (Optional[List[str]]): Iterable of filesystem paths to include in the environment search (or None to allow default discovery).
        
        Returns:
            BaseEnvironment: An environment instance that will enumerate distributions found at the specified paths.
        """
        raise NotImplementedError()

    def get_distribution(self, name: str) -> Optional["BaseDistribution"]:
        """
        Return the installed distribution matching the given requirement name, or None if not found.
        
        The implementation must canonicalize the provided name (it may be unnormalized or use different case/format) before lookup.
        """
        raise NotImplementedError()

    def _iter_distributions(self) -> Iterator["BaseDistribution"]:
        """
        Yield distributions available in this environment.
        
        Subclasses must implement this to produce an iterator of BaseDistribution objects
        representing distributions discoverable by the environment. Do not call this
        method directly; use the public iteration helpers (for example,
        iter_all_distributions or iter_installed_distributions) which apply validation
        and filtering on top of these raw results.
        
        Returns:
            Iterator[BaseDistribution]: An iterator yielding discovered distributions.
        """
        raise NotImplementedError()

    def iter_all_distributions(self) -> Iterator[BaseDistribution]:
        """
        Yield all distributions discovered by the environment, skipping entries with invalid project names.
        
        This iterates the distributions produced by _iter_distributions() and yields each distribution
        whose canonical name matches the PEP 508 project-name pattern. Distributions with invalid
        project names are skipped and a warning is logged.
        
        Returns:
            Iterator[BaseDistribution]: An iterator over valid discovered distributions.
        """
        for dist in self._iter_distributions():
            # Make sure the distribution actually comes from a valid Python
            # packaging distribution. Pip's AdjacentTempDirectory leaves folders
            # e.g. ``~atplotlib.dist-info`` if cleanup was interrupted. The
            # valid project name pattern is taken from PEP 508.
            project_name_valid = re.match(
                r"^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$",
                dist.canonical_name,
                flags=re.IGNORECASE,
            )
            if not project_name_valid:
                logger.warning(
                    "Ignoring invalid distribution %s (%s)",
                    dist.canonical_name,
                    dist.location,
                )
                continue
            yield dist

    def iter_installed_distributions(
        self,
        local_only: bool = True,
        skip: Container[str] = stdlib_pkgs,
        include_editables: bool = True,
        editables_only: bool = False,
        user_only: bool = False,
    ) -> Iterator[BaseDistribution]:
        """
        Yield installed distributions from the environment, filtered by the provided options.
        
        This is a filtered view of iter_all_distributions(); by default it yields only
        distributions that are local to the environment (when in a virtualenv) and
        omits names listed in `skip` (defaults to `stdlib_pkgs`).
        
        Parameters:
            local_only (bool): If True (default), include only distributions considered
                local to the current environment.
            skip (Container[str]): Canonicalized project names to exclude from results.
                Defaults to `stdlib_pkgs`.
            include_editables (bool): If False, exclude editable installations.
            editables_only (bool): If True, include only editable installations.
            user_only (bool): If True, include only distributions installed into the
                user site directory.
        
        Returns:
            Iterator[BaseDistribution]: An iterator over matching distributions.
        """
        it = self.iter_all_distributions()
        if local_only:
            it = (d for d in it if d.local)
        if not include_editables:
            it = (d for d in it if not d.editable)
        if editables_only:
            it = (d for d in it if d.editable)
        if user_only:
            it = (d for d in it if d.in_usersite)
        return (d for d in it if d.canonical_name not in skip)


class Wheel(Protocol):
    location: str

    def as_zipfile(self) -> zipfile.ZipFile:
        """
        Return a ZipFile object for reading the wheel archive.
        
        Implementations should open and return a zipfile.ZipFile positioned at the wheel contents. The caller is responsible for closing the returned ZipFile.
        """
        raise NotImplementedError()


class FilesystemWheel(Wheel):
    def __init__(self, location: str) -> None:
        """
        Initialize a FilesystemWheel.
        
        Parameters:
            location (str): Filesystem path to the wheel archive. Stored as the wheel's `location` attribute.
        """
        self.location = location

    def as_zipfile(self) -> zipfile.ZipFile:
        """
        Open and return a ZipFile for the wheel file on the filesystem.
        
        Returns:
            zipfile.ZipFile: A ZipFile object for the wheel at self.location (opened with allowZip64=True).
        """
        return zipfile.ZipFile(self.location, allowZip64=True)


class MemoryWheel(Wheel):
    def __init__(self, location: str, stream: IO[bytes]) -> None:
        """
        Initialize a MemoryWheel.
        
        Parameters:
            location (str): A human-readable identifier for the wheel (typically a path or origin).
            stream (IO[bytes]): A binary file-like object containing the wheel archive. The instance stores a reference to this stream; the caller is responsible for keeping it open and managing its lifecycle.
        """
        self.location = location
        self.stream = stream

    def as_zipfile(self) -> zipfile.ZipFile:
        """
        Return a ZipFile opened from the in-memory wheel stream.
        
        The ZipFile is created from the instance's byte stream with allowZip64 enabled.
        The caller is responsible for closing the returned ZipFile. The underlying
        stream is used directly (no copy); its current position is used when opening.
        """
        return zipfile.ZipFile(self.stream, allowZip64=True)
