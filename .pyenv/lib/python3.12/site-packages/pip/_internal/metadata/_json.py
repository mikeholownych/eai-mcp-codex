# Extracted from https://github.com/pfmoore/pkg_metadata

from email.header import Header, decode_header, make_header
from email.message import Message
from typing import Any, Dict, List, Union

METADATA_FIELDS = [
    # Name, Multiple-Use
    ("Metadata-Version", False),
    ("Name", False),
    ("Version", False),
    ("Dynamic", True),
    ("Platform", True),
    ("Supported-Platform", True),
    ("Summary", False),
    ("Description", False),
    ("Description-Content-Type", False),
    ("Keywords", False),
    ("Home-page", False),
    ("Download-URL", False),
    ("Author", False),
    ("Author-email", False),
    ("Maintainer", False),
    ("Maintainer-email", False),
    ("License", False),
    ("Classifier", True),
    ("Requires-Dist", True),
    ("Requires-Python", False),
    ("Requires-External", True),
    ("Project-URL", True),
    ("Provides-Extra", True),
    ("Provides-Dist", True),
    ("Obsoletes-Dist", True),
]


def json_name(field: str) -> str:
    """
    Convert a metadata header field name to a JSON-style key.
    
    Lowercases the field and replaces hyphens with underscores (e.g. "Metadata-Version"
    -> "metadata_version").
    
    Parameters:
        field (str): The metadata header field name.
    
    Returns:
        str: The normalized JSON-style key.
    """
    return field.lower().replace("-", "_")


def msg_to_json(msg: Message) -> Dict[str, Any]:
    """
    Convert an email.message.Message into a JSON-serializable dict of package metadata.
    
    This reads the fields listed in METADATA_FIELDS from the provided Message and
    produces a dictionary whose keys are the JSON-style names (lowercased, hyphens
    replaced with underscores). Multi-valued metadata fields are returned as lists;
    single-valued fields are returned as strings except for `keywords`, which is
    normalized into a list (accepting both comma-separated and whitespace-separated
    forms for compatibility). If the message has a payload, it is stored under the
    "description" key.
    
    Header values are normalised via an internal sanitiser that decodes encoded
    header parts, treating "unknown-8bit" parts as UTF-8 when possible and falling
    back to Latin-1 to avoid decode errors.
    
    Parameters:
        msg (email.message.Message): The parsed email Message containing package
            metadata.
    
    Returns:
        dict: A JSON-compatible mapping of metadata keys to their values.
    """

    def sanitise_header(h: Union[Header, str]) -> str:
        """
        Normalize an email header value to a plain Python string.
        
        If `h` is an email.header.Header, decodes its parts using `decode_header`
        and reassembles them with `make_header`. Parts encoded with the special
        encoding `"unknown-8bit"` are first tested for UTF-8 decoding and, on
        failure, decoded as Latin-1 to avoid decode errors. If `h` is already a
        string, returns `str(h)`.
        
        Returns:
            A UTF-8-safe string representation of the header.
        """
        if isinstance(h, Header):
            chunks = []
            for bytes, encoding in decode_header(h):
                if encoding == "unknown-8bit":
                    try:
                        # See if UTF-8 works
                        bytes.decode("utf-8")
                        encoding = "utf-8"
                    except UnicodeDecodeError:
                        # If not, latin1 at least won't fail
                        encoding = "latin1"
                chunks.append((bytes, encoding))
            return str(make_header(chunks))
        return str(h)

    result = {}
    for field, multi in METADATA_FIELDS:
        if field not in msg:
            continue
        key = json_name(field)
        if multi:
            value: Union[str, List[str]] = [
                sanitise_header(v) for v in msg.get_all(field)  # type: ignore
            ]
        else:
            value = sanitise_header(msg.get(field))  # type: ignore
            if key == "keywords":
                # Accept both comma-separated and space-separated
                # forms, for better compatibility with old data.
                if "," in value:
                    value = [v.strip() for v in value.split(",")]
                else:
                    value = value.split()
        result[key] = value

    payload = msg.get_payload()
    if payload:
        result["description"] = payload

    return result
