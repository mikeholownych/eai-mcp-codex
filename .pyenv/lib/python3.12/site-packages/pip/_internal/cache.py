"""Cache Management
"""

import hashlib
import json
import logging
import os
from pathlib import Path
from typing import Any, Dict, List, Optional

from pip._vendor.packaging.tags import Tag, interpreter_name, interpreter_version
from pip._vendor.packaging.utils import canonicalize_name

from pip._internal.exceptions import InvalidWheelFilename
from pip._internal.models.direct_url import DirectUrl
from pip._internal.models.link import Link
from pip._internal.models.wheel import Wheel
from pip._internal.utils.temp_dir import TempDirectory, tempdir_kinds
from pip._internal.utils.urls import path_to_url

logger = logging.getLogger(__name__)

ORIGIN_JSON_NAME = "origin.json"


def _hash_dict(d: Dict[str, str]) -> str:
    """
    Return a deterministic SHA-224 hex digest for a mapping.
    
    The dictionary is serialized to JSON with sorted keys, compact separators, and ASCII
    encoding before hashing, so equivalent mappings (same keys/values, different order)
    produce the same digest.
    
    Parameters:
        d (Dict[str, str]): Mapping of string keys to string values to hash.
    
    Returns:
        str: Hexadecimal SHA-224 digest of the serialized mapping.
    """
    s = json.dumps(d, sort_keys=True, separators=(",", ":"), ensure_ascii=True)
    return hashlib.sha224(s.encode("ascii")).hexdigest()


class Cache:
    """An abstract class - provides cache directories for data from links

    :param cache_dir: The root of the cache.
    """

    def __init__(self, cache_dir: str) -> None:
        """
        Initialize the cache with a root directory.
        
        Parameters:
            cache_dir (str): Absolute path to the cache root. If empty, caching is disabled and
                the instance will treat the cache as unavailable (stored as None).
        
        Notes:
            The provided path must be absolute when non-empty; a ValueError is not raised here,
            but an assertion ensures callers pass an absolute path.
        """
        super().__init__()
        assert not cache_dir or os.path.isabs(cache_dir)
        self.cache_dir = cache_dir or None

    def _get_cache_path_parts(self, link: Link) -> List[str]:
        """
        Return four directory-name components that uniquely identify a Link for caching.
        
        The components are a deterministic split of a stable hash computed from the
        link's URL (without fragment) and any present link metadata (hash name/value,
        subdirectory fragment), together with the current interpreter name and
        version. The returned list of four strings is intended to be joined as a
        nested subpath under the cache root (e.g. cache_dir/<part0>/<part1>/<part2>/<part3>).
        
        Parameters:
            link (Link): The link whose cache path parts should be computed.
        
        Returns:
            List[str]: Four path components (strings) forming a nested cache subpath.
        """

        # We want to generate an url to use as our cache key, we don't want to
        # just re-use the URL because it might have other items in the fragment
        # and we don't care about those.
        key_parts = {"url": link.url_without_fragment}
        if link.hash_name is not None and link.hash is not None:
            key_parts[link.hash_name] = link.hash
        if link.subdirectory_fragment:
            key_parts["subdirectory"] = link.subdirectory_fragment

        # Include interpreter name, major and minor version in cache key
        # to cope with ill-behaved sdists that build a different wheel
        # depending on the python version their setup.py is being run on,
        # and don't encode the difference in compatibility tags.
        # https://github.com/pypa/pip/issues/7296
        key_parts["interpreter_name"] = interpreter_name()
        key_parts["interpreter_version"] = interpreter_version()

        # Encode our key url with sha224, we'll use this because it has similar
        # security properties to sha256, but with a shorter total output (and
        # thus less secure). However the differences don't make a lot of
        # difference for our use case here.
        hashed = _hash_dict(key_parts)

        # We want to nest the directories some to prevent having a ton of top
        # level directories where we might run out of sub directories on some
        # FS.
        parts = [hashed[:2], hashed[2:4], hashed[4:6], hashed[6:]]

        return parts

    def _get_candidates(self, link: Link, canonical_package_name: str) -> List[Any]:
        """
        Return candidate cached filenames for a link's cache directory.
        
        If caching is unavailable (no cache_dir set, missing canonical_package_name, or no link),
        returns an empty list. Otherwise, determines the filesystem directory for the link via
        get_path_for_link(link). If that path is an existing directory, returns a list of
        (filename, directory_path) tuples for each entry in that directory; otherwise returns [].
        
        Parameters:
            link (Link): The link whose cache directory to inspect.
            canonical_package_name (str): Canonicalized package name used to decide whether
                caching is applicable (only its presence is checked).
        
        Returns:
            List[tuple[str, str]]: A list of (candidate_filename, directory_path) tuples.
        """
        can_not_cache = not self.cache_dir or not canonical_package_name or not link
        if can_not_cache:
            return []

        path = self.get_path_for_link(link)
        if os.path.isdir(path):
            return [(candidate, path) for candidate in os.listdir(path)]
        return []

    def get_path_for_link(self, link: Link) -> str:
        """
        Return the filesystem directory path where cached items for the given Link should be stored.
        
        Implementations must return a string path (typically under the cache root) that will be used to store/retrieve cached files associated with `link`. This method is abstract and must be overridden by subclasses.
        """
        raise NotImplementedError()

    def get(
        self,
        link: Link,
        package_name: Optional[str],
        supported_tags: List[Tag],
    ) -> Link:
        """Returns a link to a cached item if it exists, otherwise returns the
        passed link.
        """
        raise NotImplementedError()


class SimpleWheelCache(Cache):
    """A cache of wheels for future installs."""

    def __init__(self, cache_dir: str) -> None:
        """
        Initialize a SimpleWheelCache using the given cache directory.
        
        Parameters:
            cache_dir (str): Path to the root cache directory. May be an empty string to disable caching;
                otherwise should be an absolute path (validation is performed by the base Cache class).
        """
        super().__init__(cache_dir)

    def get_path_for_link(self, link: Link) -> str:
        """
        Return the directory path where wheels for the given link should be cached.
        
        This is a dedicated per-link wheels directory under the cache root so multiple
        wheel files (for different platforms/tags) can be stored for the same source
        link.
        
        Parameters:
            link (Link): The source link (typically an sdist) whose wheels are cached.
        
        Returns:
            str: Filesystem path to the directory for cached wheel files for this link.
        """
        parts = self._get_cache_path_parts(link)
        assert self.cache_dir
        # Store wheels within the root cache_dir
        return os.path.join(self.cache_dir, "wheels", *parts)

    def get(
        self,
        link: Link,
        package_name: Optional[str],
        supported_tags: List[Tag],
    ) -> Link:
        """
        Return a Link to a cached wheel for the given link and package, or the original link if none found.
        
        Searches the cache candidates for the requested package name and supported tags, selects a compatible cached wheel (if any), and returns a Link pointing to the cached wheel file. If package_name is not provided or no compatible cached wheel is found, the original link is returned.
        
        Notes:
        - Candidate filenames that are not valid wheel filenames are ignored.
        - Candidates whose distribution name (canonicalized) does not match the requested package are ignored.
        - Only wheels compatible with the provided supported_tags are considered.
        - When multiple compatible wheels are available, the candidate with the best (lowest) support index is chosen.
        """
        candidates = []

        if not package_name:
            return link

        canonical_package_name = canonicalize_name(package_name)
        for wheel_name, wheel_dir in self._get_candidates(link, canonical_package_name):
            try:
                wheel = Wheel(wheel_name)
            except InvalidWheelFilename:
                continue
            if canonicalize_name(wheel.name) != canonical_package_name:
                logger.debug(
                    "Ignoring cached wheel %s for %s as it "
                    "does not match the expected distribution name %s.",
                    wheel_name,
                    link,
                    package_name,
                )
                continue
            if not wheel.supported(supported_tags):
                # Built for a different python/arch/etc
                continue
            candidates.append(
                (
                    wheel.support_index_min(supported_tags),
                    wheel_name,
                    wheel_dir,
                )
            )

        if not candidates:
            return link

        _, wheel_name, wheel_dir = min(candidates)
        return Link(path_to_url(os.path.join(wheel_dir, wheel_name)))


class EphemWheelCache(SimpleWheelCache):
    """A SimpleWheelCache that creates it's own temporary cache directory"""

    def __init__(self) -> None:
        """
        Initialize an ephemeral wheel cache.
        
        Creates a temporary, globally managed directory (kind EPHEM_WHEEL_CACHE) and initializes
        the SimpleWheelCache base with that temporary directory's path. The cache contents are
        transient and live only for the lifetime of the TempDirectory.
        """
        self._temp_dir = TempDirectory(
            kind=tempdir_kinds.EPHEM_WHEEL_CACHE,
            globally_managed=True,
        )

        super().__init__(self._temp_dir.path)


class CacheEntry:
    def __init__(
        self,
        link: Link,
        persistent: bool,
    ):
        """
        Initialize a CacheEntry representing a cached file and (optionally) its origin metadata.
        
        Parameters:
            link: The Link pointing to the cached file on disk.
            persistent: True if the cached file is stored in persistent cache storage; False for ephemeral.
        
        Behavior:
            - Sets self.link and self.persistent.
            - Attempts to load origin metadata from an `origin.json` file located alongside the cached file; if present and valid, stores a DirectUrl in self.origin.
            - If the origin file exists but cannot be parsed, logs a warning and leaves self.origin as None.
        """
        self.link = link
        self.persistent = persistent
        self.origin: Optional[DirectUrl] = None
        origin_direct_url_path = Path(self.link.file_path).parent / ORIGIN_JSON_NAME
        if origin_direct_url_path.exists():
            try:
                self.origin = DirectUrl.from_json(
                    origin_direct_url_path.read_text(encoding="utf-8")
                )
            except Exception as e:
                logger.warning(
                    "Ignoring invalid cache entry origin file %s for %s (%s)",
                    origin_direct_url_path,
                    link.filename,
                    e,
                )


class WheelCache(Cache):
    """Wraps EphemWheelCache and SimpleWheelCache into a single Cache

    This Cache allows for gracefully degradation, using the ephem wheel cache
    when a certain link is not found in the simple wheel cache first.
    """

    def __init__(self, cache_dir: str) -> None:
        """
        Initialize a WheelCache composed of a persistent and an ephemeral wheel cache.
        
        Parameters:
            cache_dir (str): Path to the persistent cache directory. If empty or not absolute,
                behavior is delegated to the underlying Cache initializer.
        """
        super().__init__(cache_dir)
        self._wheel_cache = SimpleWheelCache(cache_dir)
        self._ephem_cache = EphemWheelCache()

    def get_path_for_link(self, link: Link) -> str:
        """
        Return the filesystem directory path in the persistent wheel cache that would hold files for the given link.
        
        The returned path is computed using the same keying logic as SimpleWheelCache (nested subdirectories derived from the link and interpreter). This is the persistent cache location; ephemeral cache paths are available via get_ephem_path_for_link.
        
        Parameters:
            link (Link): The candidate Link whose cache directory is requested.
        
        Returns:
            str: Filesystem path to the persistent wheel cache directory for the link.
        """
        return self._wheel_cache.get_path_for_link(link)

    def get_ephem_path_for_link(self, link: Link) -> str:
        """
        Return the filesystem path inside the ephemeral wheel cache that corresponds to the given link.
        
        The path is where ephemeral cached items for `link` would be stored; this delegates to the internal ephemeral cache implementation and mirrors the persistent cache's path layout.
        
        Returns:
            str: Absolute filesystem path for the link within the ephemeral wheel cache.
        """
        return self._ephem_cache.get_path_for_link(link)

    def get(
        self,
        link: Link,
        package_name: Optional[str],
        supported_tags: List[Tag],
    ) -> Link:
        """
        Return a cached Link for the given remote link if a matching wheel is available.
        
        If a cached wheel matching the requested package name and supported tags is found
        in the persistent or ephemeral wheel caches, the cached Link is returned;
        otherwise the original `link` is returned unchanged.
        
        Parameters:
            link: The original Link to a remote distribution.
            package_name: The (possibly None) package name to match against cached wheels.
            supported_tags: A list of compatibility tags used to select a compatible wheel.
        
        Returns:
            A Link to the cached wheel when available, or the input `link` if no cache
            entry was found.
        """
        cache_entry = self.get_cache_entry(link, package_name, supported_tags)
        if cache_entry is None:
            return link
        return cache_entry.link

    def get_cache_entry(
        self,
        link: Link,
        package_name: Optional[str],
        supported_tags: List[Tag],
    ) -> Optional[CacheEntry]:
        """
        Return a CacheEntry for a cached wheel matching the given link and tags, or None if no cached item is available.
        
        Checks the persistent wheel cache first, then the ephemeral (temporary) cache. If a match is found, the returned CacheEntry.wraps the cached Link and has its `persistent` flag set True for the persistent cache and False for the ephemeral cache.
        
        Parameters:
            link: The original Link being looked up.
            package_name: Canonical package name to match against cached wheel names; if None, no package-name filtering is performed.
            supported_tags: The set of compatibility tags used to determine a matching wheel.
        
        Returns:
            A CacheEntry describing the matched cached item, or None when no suitable cached wheel is found.
        """
        retval = self._wheel_cache.get(
            link=link,
            package_name=package_name,
            supported_tags=supported_tags,
        )
        if retval is not link:
            return CacheEntry(retval, persistent=True)

        retval = self._ephem_cache.get(
            link=link,
            package_name=package_name,
            supported_tags=supported_tags,
        )
        if retval is not link:
            return CacheEntry(retval, persistent=False)

        return None

    @staticmethod
    def record_download_origin(cache_dir: str, download_info: DirectUrl) -> None:
        """
        Record the DirectUrl provenance for a cached entry by writing an origin.json file.
        
        Writes download_info.to_json() to (cache_dir / "origin.json"). If an existing
        origin.json is present, the file is attempted to be read and parsed; a parse
        failure produces a warning and the file is overwritten. If the existing origin's
        URL differs from download_info.url a warning is emitted and the file is
        overwritten.
        
        Parameters:
            cache_dir (str): Filesystem directory path of the cache entry (the file
                written is <cache_dir>/origin.json).
            download_info (DirectUrl): DirectUrl object whose JSON representation will
                be persisted alongside the cached item.
        """
        origin_path = Path(cache_dir) / ORIGIN_JSON_NAME
        if origin_path.exists():
            try:
                origin = DirectUrl.from_json(origin_path.read_text(encoding="utf-8"))
            except Exception as e:
                logger.warning(
                    "Could not read origin file %s in cache entry (%s). "
                    "Will attempt to overwrite it.",
                    origin_path,
                    e,
                )
            else:
                # TODO: use DirectUrl.equivalent when
                # https://github.com/pypa/pip/pull/10564 is merged.
                if origin.url != download_info.url:
                    logger.warning(
                        "Origin URL %s in cache entry %s does not match download URL "
                        "%s. This is likely a pip bug or a cache corruption issue. "
                        "Will overwrite it with the new value.",
                        origin.url,
                        cache_dir,
                        download_info.url,
                    )
        origin_path.write_text(download_info.to_json(), encoding="utf-8")
