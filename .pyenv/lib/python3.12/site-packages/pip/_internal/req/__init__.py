import collections
import logging
from typing import Generator, List, Optional, Sequence, Tuple

from pip._internal.utils.logging import indent_log

from .req_file import parse_requirements
from .req_install import InstallRequirement
from .req_set import RequirementSet

__all__ = [
    "RequirementSet",
    "InstallRequirement",
    "parse_requirements",
    "install_given_reqs",
]

logger = logging.getLogger(__name__)


class InstallationResult:
    def __init__(self, name: str) -> None:
        """
        Initialize an InstallationResult for a processed package.
        
        Parameters:
            name (str): The package name associated with this installation result; stored on the instance as `self.name`.
        """
        self.name = name

    def __repr__(self) -> str:
        """
        Return a developer-oriented string representation of the InstallationResult.
        
        The returned string has the form "InstallationResult(name='...')" and includes the stored package name for debugging.
        """
        return f"InstallationResult(name={self.name!r})"


def _validate_requirements(
    requirements: List[InstallRequirement],
) -> Generator[Tuple[str, InstallRequirement], None, None]:
    """
    Yield (requirement name, InstallRequirement) pairs for each requirement in the given list.
    
    Validates that each InstallRequirement has a truthy `name` (raises AssertionError with
    message "invalid to-be-installed requirement: {req}" if not), and yields tuples
    in the same order as the input list.
    
    Parameters:
        requirements: List of InstallRequirement objects to validate and iterate.
    
    Returns:
        Generator yielding (name, InstallRequirement) tuples.
    """
    for req in requirements:
        assert req.name, f"invalid to-be-installed requirement: {req}"
        yield req.name, req


def install_given_reqs(
    requirements: List[InstallRequirement],
    global_options: Sequence[str],
    root: Optional[str],
    home: Optional[str],
    prefix: Optional[str],
    warn_script_location: bool,
    use_user_site: bool,
    pycompile: bool,
) -> List[InstallationResult]:
    """
    Install the given list of InstallRequirement objects and return results.
    
    Installs each requirement in the order provided. If a requirement indicates it should
    be reinstalled, an uninstall is attempted first; the uninstall is rolled back if the
    subsequent install fails, and committed if the install succeeds.
    
    Parameters:
        requirements: Ordered list of InstallRequirement objects to install.
        global_options: Sequence of global options passed through to the install step.
        root: Optional root path to use for installation (affects installation target).
        home: Optional home directory to use for installation.
        prefix: Optional installation prefix.
        warn_script_location: If True, warn when installing scripts to locations that may be unexpected.
        use_user_site: If True, prefer the user-site installation location.
        pycompile: If True, compile installed .py files to .pyc/.pyo as part of installation.
    
    Returns:
        List[InstallationResult]: A list of InstallationResult objects, one per processed requirement,
        preserving the input order.
    """
    to_install = collections.OrderedDict(_validate_requirements(requirements))

    if to_install:
        logger.info(
            "Installing collected packages: %s",
            ", ".join(to_install.keys()),
        )

    installed = []

    with indent_log():
        for req_name, requirement in to_install.items():
            if requirement.should_reinstall:
                logger.info("Attempting uninstall: %s", req_name)
                with indent_log():
                    uninstalled_pathset = requirement.uninstall(auto_confirm=True)
            else:
                uninstalled_pathset = None

            try:
                requirement.install(
                    global_options,
                    root=root,
                    home=home,
                    prefix=prefix,
                    warn_script_location=warn_script_location,
                    use_user_site=use_user_site,
                    pycompile=pycompile,
                )
            except Exception:
                # if install did not succeed, rollback previous uninstall
                if uninstalled_pathset and not requirement.install_succeeded:
                    uninstalled_pathset.rollback()
                raise
            else:
                if uninstalled_pathset and requirement.install_succeeded:
                    uninstalled_pathset.commit()

            installed.append(InstallationResult(req_name))

    return installed
