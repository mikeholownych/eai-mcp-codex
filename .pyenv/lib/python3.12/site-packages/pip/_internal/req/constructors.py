"""Backing implementation for InstallRequirement's various constructors

The idea here is that these formed a major chunk of InstallRequirement's size
so, moving them and support code dedicated to them outside of that class
helps creates for better understandability for the rest of the code.

These are meant to be used elsewhere within pip to create instances of
InstallRequirement.
"""

import copy
import logging
import os
import re
from typing import Collection, Dict, List, Optional, Set, Tuple, Union

from pip._vendor.packaging.markers import Marker
from pip._vendor.packaging.requirements import InvalidRequirement, Requirement
from pip._vendor.packaging.specifiers import Specifier

from pip._internal.exceptions import InstallationError
from pip._internal.models.index import PyPI, TestPyPI
from pip._internal.models.link import Link
from pip._internal.models.wheel import Wheel
from pip._internal.req.req_file import ParsedRequirement
from pip._internal.req.req_install import InstallRequirement
from pip._internal.utils.filetypes import is_archive_file
from pip._internal.utils.misc import is_installable_dir
from pip._internal.utils.packaging import get_requirement
from pip._internal.utils.urls import path_to_url
from pip._internal.vcs import is_url, vcs

__all__ = [
    "install_req_from_editable",
    "install_req_from_line",
    "parse_editable",
]

logger = logging.getLogger(__name__)
operators = Specifier._operators.keys()


def _strip_extras(path: str) -> Tuple[str, Optional[str]]:
    """
    Strip trailing extras from a path-like string.
    
    Given a string like "package[extra1,extra2]" returns ("package", "[extra1,extra2]").
    If no extras are present returns (original_path, None).
    
    Parameters:
        path (str): The input path or requirement-like string that may end with bracketed extras.
    
    Returns:
        Tuple[str, Optional[str]]: A tuple of (path_without_extras, extras) where `extras` is the bracketed
        extras substring (including the surrounding brackets) or None if no extras were found.
    """
    m = re.match(r"^(.+)(\[[^\]]+\])$", path)
    extras = None
    if m:
        path_no_extras = m.group(1)
        extras = m.group(2)
    else:
        path_no_extras = path

    return path_no_extras, extras


def convert_extras(extras: Optional[str]) -> Set[str]:
    """
    Convert an extras string (as used in requirement syntax) into a set of extras.
    
    The input should be the extras portion of a requirement, including the surrounding
    square brackets (for example: "[socks,security]"). Returns an empty set if
    None or an empty string is provided. Resulting extras are normalized to lower
    case.
     
    Parameters:
        extras (Optional[str]): The extras string including brackets, or None.
    
    Returns:
        Set[str]: A set of normalized extra names.
    """
    if not extras:
        return set()
    return get_requirement("placeholder" + extras.lower()).extras


def _set_requirement_extras(req: Requirement, new_extras: Set[str]) -> Requirement:
    """
    Return a new packaging.Requirement with its extras replaced by `new_extras`.
    
    Given a Requirement `req`, this creates and returns an equivalent Requirement
    whose extras are the sorted set `new_extras`. If `new_extras` is empty, any
    extras are removed. The function assumes `req` is a valid requirement string
    and will assert if internal parsing fails.
    """
    match: Optional[re.Match[str]] = re.fullmatch(
        # see https://peps.python.org/pep-0508/#complete-grammar
        r"([\w\t .-]+)(\[[^\]]*\])?(.*)",
        str(req),
        flags=re.ASCII,
    )
    # ireq.req is a valid requirement so the regex should always match
    assert (
        match is not None
    ), f"regex match on requirement {req} failed, this should never happen"
    pre: Optional[str] = match.group(1)
    post: Optional[str] = match.group(3)
    assert (
        pre is not None and post is not None
    ), f"regex group selection for requirement {req} failed, this should never happen"
    extras: str = "[%s]" % ",".join(sorted(new_extras)) if new_extras else ""
    return Requirement(f"{pre}{extras}{post}")


def parse_editable(editable_req: str) -> Tuple[Optional[str], str, Set[str]]:
    """
    Parse an "editable" requirement string into (name, url, extras).
    
    Accepts VCS editable specifications (e.g. "svn+http://...#egg=Foo"),
    file URLs, and local filesystem paths, and returns:
    - name: the package name if present (from the egg fragment), otherwise None for file URLs without an egg,
    - url: a normalized URL or file URL suitable for creating a Link,
    - extras: a set of extras requested (e.g. {"dev", "socks"}).
    
    Notes:
    - If the input is a local path with extras (like "./mypkg[extra]"), the extras are parsed and returned.
    - For file URLs, the function may return the package name based on the URL's egg fragment; if extras were provided on a path, they are converted to a set.
    - For VCS editables, the input may omit the "vcs+" prefix (e.g. "git://..."); the function will normalize it to the VCS scheme.
    
    Raises:
    - InstallationError if the input is not a valid editable requirement (neither a local path/file URL nor a supported VCS URL), or if a VCS URL is missing an egg fragment and a package name cannot be determined.
    """

    url = editable_req

    # If a file path is specified with extras, strip off the extras.
    url_no_extras, extras = _strip_extras(url)

    if os.path.isdir(url_no_extras):
        # Treating it as code that has already been checked out
        url_no_extras = path_to_url(url_no_extras)

    if url_no_extras.lower().startswith("file:"):
        package_name = Link(url_no_extras).egg_fragment
        if extras:
            return (
                package_name,
                url_no_extras,
                get_requirement("placeholder" + extras.lower()).extras,
            )
        else:
            return package_name, url_no_extras, set()

    for version_control in vcs:
        if url.lower().startswith(f"{version_control}:"):
            url = f"{version_control}+{url}"
            break

    link = Link(url)

    if not link.is_vcs:
        backends = ", ".join(vcs.all_schemes)
        raise InstallationError(
            f"{editable_req} is not a valid editable requirement. "
            f"It should either be a path to a local project or a VCS URL "
            f"(beginning with {backends})."
        )

    package_name = link.egg_fragment
    if not package_name:
        raise InstallationError(
            "Could not detect requirement name for '{}', please specify one "
            "with #egg=your_package_name".format(editable_req)
        )
    return package_name, url, set()


def check_first_requirement_in_file(filename: str) -> None:
    """Check if file is parsable as a requirements file.

    This is heavily based on ``pkg_resources.parse_requirements``, but
    simplified to just check the first meaningful line.

    :raises InvalidRequirement: If the first meaningful line cannot be parsed
        as an requirement.
    """
    with open(filename, encoding="utf-8", errors="ignore") as f:
        # Create a steppable iterator, so we can handle \-continuations.
        lines = (
            line
            for line in (line.strip() for line in f)
            if line and not line.startswith("#")  # Skip blank lines/comments.
        )

        for line in lines:
            # Drop comments -- a hash without a space may be in a URL.
            if " #" in line:
                line = line[: line.find(" #")]
            # If there is a line continuation, drop it, and append the next line.
            if line.endswith("\\"):
                line = line[:-2].strip() + next(lines, "")
            Requirement(line)
            return


def deduce_helpful_msg(req: str) -> str:
    """
    Return a user-facing message explaining why a requirements file argument failed.
    
    If the path does not exist, the message indicates that. If the path exists and
    appears to be a requirements file (based on parsing its first non-empty,
    non-comment line), the message suggests using the '-r' flag to install the
    packages listed in that file. Otherwise returns a generic note that the path
    exists but could not be recognized as a requirements file.
    
    Parameters:
        req (str): Path to the purported requirements file.
    
    Returns:
        str: A short, helpful message suitable for inclusion in an error or hint.
    """
    if not os.path.exists(req):
        return f" File '{req}' does not exist."
    msg = " The path does exist. "
    # Try to parse and check if it is a requirements file.
    try:
        check_first_requirement_in_file(req)
    except InvalidRequirement:
        logger.debug("Cannot parse '%s' as requirements file", req)
    else:
        msg += (
            f"The argument you provided "
            f"({req}) appears to be a"
            f" requirements file. If that is the"
            f" case, use the '-r' flag to install"
            f" the packages specified within it."
        )
    return msg


class RequirementParts:
    def __init__(
        self,
        requirement: Optional[Requirement],
        link: Optional[Link],
        markers: Optional[Marker],
        extras: Set[str],
    ):
        """
        Initialize a RequirementParts container.
        
        Parameters:
            requirement: Parsed packaging Requirement object, or None if unavailable.
            link: Link to the package source (VCS, file, or URL), or None.
            markers: Environment markers for the requirement, or None.
            extras: A set of extras requested for the requirement.
        """
        self.requirement = requirement
        self.link = link
        self.markers = markers
        self.extras = extras


def parse_req_from_editable(editable_req: str) -> RequirementParts:
    """
    Create RequirementParts from an editable requirement spec.
    
    Parses an editable requirement string (VCS, file URL, or local path) and returns a RequirementParts containing:
    - requirement: a packaging.Requirement built from the parsed project name, or None if the editable spec has no name.
    - link: a Link for the resolved URL.
    - markers: always None for editable specs.
    - extras: the set of extras parsed from the editable spec (possibly empty).
    
    Parameters:
        editable_req (str): An editable requirement string (e.g. a VCS URL, file path/URL, or local directory spec).
    
    Returns:
        RequirementParts: Container with the parsed Requirement (or None), Link, markers (None), and extras set.
    
    Raises:
        InstallationError: If a project name is present in the editable spec but is not a valid requirement string.
    """
    name, url, extras_override = parse_editable(editable_req)

    if name is not None:
        try:
            req: Optional[Requirement] = Requirement(name)
        except InvalidRequirement:
            raise InstallationError(f"Invalid requirement: '{name}'")
    else:
        req = None

    link = Link(url)

    return RequirementParts(req, link, None, extras_override)


# ---- The actual constructors follow ----


def install_req_from_editable(
    editable_req: str,
    comes_from: Optional[Union[InstallRequirement, str]] = None,
    *,
    use_pep517: Optional[bool] = None,
    isolated: bool = False,
    global_options: Optional[List[str]] = None,
    hash_options: Optional[Dict[str, List[str]]] = None,
    constraint: bool = False,
    user_supplied: bool = False,
    permit_editable_wheels: bool = False,
    config_settings: Optional[Dict[str, Union[str, List[str]]]] = None,
) -> InstallRequirement:
    """
    Create an InstallRequirement for an editable requirement string.
    
    Parses an editable requirement (path, VCS URL, or file URL â€” optionally with extras like "pkg[extra]") and returns a configured InstallRequirement marked as editable. The resulting InstallRequirement will include the parsed Requirement (if a package name is present), a Link for the source, and any extras.
    
    Parameters:
        editable_req (str): The editable requirement specification (local path, VCS URL, or file URL). Extras may be appended in square brackets.
        comes_from (Optional[Union[InstallRequirement, str]]): Origin information used for error messages and provenance (e.g., filename or parent requirement).
        use_pep517 (Optional[bool]): Whether to build using PEP 517. Passed through to the InstallRequirement.
        isolated (bool): Whether the build/install should run in isolated mode.
        global_options (Optional[List[str]]): Global installer options to record on the InstallRequirement.
        hash_options (Optional[Dict[str, List[str]]]): Recorded hashes for the requirement, if any.
        constraint (bool): Whether the requirement is a constraint (True) or a normal requirement (False).
        user_supplied (bool): True if this requirement was explicitly supplied by the user.
        permit_editable_wheels (bool): If True, allow editable wheels as editable sources.
        config_settings (Optional[Dict[str, Union[str, List[str]]]]): Build-time config settings to pass through.
    
    Returns:
        InstallRequirement: An InstallRequirement configured for the parsed editable source, with editable=True and populated link, requirement, and extras.
    """
    parts = parse_req_from_editable(editable_req)

    return InstallRequirement(
        parts.requirement,
        comes_from=comes_from,
        user_supplied=user_supplied,
        editable=True,
        permit_editable_wheels=permit_editable_wheels,
        link=parts.link,
        constraint=constraint,
        use_pep517=use_pep517,
        isolated=isolated,
        global_options=global_options,
        hash_options=hash_options,
        config_settings=config_settings,
        extras=parts.extras,
    )


def _looks_like_path(name: str) -> bool:
    """
    Return True if the given name plausibly refers to a filesystem path.
    
    This performs a superficial, appearance-only check (does not test filesystem).
    It returns True when the string contains a path separator (os.path.sep or
    os.path.altsep) or begins with a dot (e.g., "./" or "../"), otherwise False.
    """
    if os.path.sep in name:
        return True
    if os.path.altsep is not None and os.path.altsep in name:
        return True
    if name.startswith("."):
        return True
    return False


def _get_url_from_path(path: str, name: str) -> Optional[str]:
    """
    Return a file:// URL for the given filesystem path when the path points to
    an installable directory or an existing archive file; otherwise return None.
    
    Detailed behavior:
    - If `name` looks like a filesystem path and `path` is a directory:
      - If the directory is installable (contains a build backend or setup.py), return its file URL.
      - Otherwise raise InstallationError.
    - If `path` is not an archive file (e.g., not a wheel or supported archive), return None.
    - If `path` is an archive file and exists on disk, return its file URL.
    - If `path` appears to be an archive but does not exist:
      - If `name` contains an "@" and the part before "@" does not look like a filesystem path,
        treat it as a PEP 440 URL requirement (do not return a URL here; return None so it can be handled elsewhere).
      - Otherwise return a file URL corresponding to `path` (the caller will get a URL for a non-existent file).
    
    Parameters:
        path: Filesystem path (as provided or resolved) to examine.
        name: Original requirement token from the requirements line; used to detect whether
            the input was intended as a path or a PEP 440 URL-like string.
    
    Returns:
        A file:// URL string when the path maps to an installable directory or an existing archive,
        or None when the input should not be treated as a local archive/path URL.
    
    Raises:
        InstallationError: if `name` looks like a path, `path` is a directory, but the directory
        is not installable (no setup.py or pyproject.toml).
    """
    if _looks_like_path(name) and os.path.isdir(path):
        if is_installable_dir(path):
            return path_to_url(path)
        # TODO: The is_installable_dir test here might not be necessary
        #       now that it is done in load_pyproject_toml too.
        raise InstallationError(
            f"Directory {name!r} is not installable. Neither 'setup.py' "
            "nor 'pyproject.toml' found."
        )
    if not is_archive_file(path):
        return None
    if os.path.isfile(path):
        return path_to_url(path)
    urlreq_parts = name.split("@", 1)
    if len(urlreq_parts) >= 2 and not _looks_like_path(urlreq_parts[0]):
        # If the path contains '@' and the part before it does not look
        # like a path, try to treat it as a PEP 440 URL req instead.
        return None
    raise InstallationError(
        f"Requirement {name!r} looks like a filename, but the file does not exist"
    )
    return path_to_url(path)

def parse_req_from_line(name: str, line_source: Optional[str]) -> RequirementParts:
    """
    Parse a requirement line (URL, path, or requirement specifier) into its components.
    
    This returns a RequirementParts tuple with:
    - requirement: a parsed `Requirement` when the input yields a valid requirement string
      (for wheels this becomes `name==version`; for generic URLs the egg fragment is used
      when present), otherwise None.
    - link: a `Link` when the input is a URL or resolves to a local file/dir/archive URL, otherwise None.
    - markers: an environment marker parsed from a trailing `;` separator, or None.
    - extras: a set of extras parsed from a trailing `[extras]` on a path or name.
    
    Parameters:
        name: The requirement line to parse. May be a URL, filesystem path, wheel/archive filename, or
            a plain requirement specifier. May include environment markers separated by `;` or `; ` and
            extras in square brackets.
        line_source: Optional source description used to annotate error messages (e.g., filename/line).
    
    Returns:
        RequirementParts: container with the parsed Requirement (or None), Link (or None),
        Marker (or None), and a set of extras.
    
    Raises:
        InstallationError: if the requirement string is invalid or contains disallowed constructs
            (for example, extras after a version specifier). Note that parsing a wheel filename may
            raise InvalidWheelFilename from Wheel().
    """
    if is_url(name):
        marker_sep = "; "
    else:
        marker_sep = ";"
    if marker_sep in name:
        name, markers_as_string = name.split(marker_sep, 1)
        markers_as_string = markers_as_string.strip()
        if not markers_as_string:
            markers = None
        else:
            markers = Marker(markers_as_string)
    else:
        markers = None
    name = name.strip()
    req_as_string = None
    path = os.path.normpath(os.path.abspath(name))
    link = None
    extras_as_string = None

    if is_url(name):
        link = Link(name)
    else:
        p, extras_as_string = _strip_extras(path)
        url = _get_url_from_path(p, name)
        if url is not None:
            link = Link(url)

    # it's a local file, dir, or url
    if link:
        # Handle relative file URLs
        if link.scheme == "file" and re.search(r"\.\./", link.url):
            link = Link(path_to_url(os.path.normpath(os.path.abspath(link.path))))
        # wheel file
        if link.is_wheel:
            wheel = Wheel(link.filename)  # can raise InvalidWheelFilename
            req_as_string = f"{wheel.name}=={wheel.version}"
        else:
            # set the req to the egg fragment.  when it's not there, this
            # will become an 'unnamed' requirement
            req_as_string = link.egg_fragment

    # a requirement specifier
    else:
        req_as_string = name

    extras = convert_extras(extras_as_string)

    def with_source(text: str) -> str:
        """
        Return `text` optionally annotated with its source.
        
        If the surrounding scope provides a truthy `line_source`, the function appends
        " (from {line_source})" to `text`; otherwise it returns `text` unchanged.
        
        Parameters:
            text (str): Base message to annotate.
        
        Returns:
            str: The original `text`, with " (from {line_source})" appended when a
            `line_source` value is available in the enclosing scope.
        """
        if not line_source:
            return text
        return f"{text} (from {line_source})"

    def _parse_req_string(req_as_string: str) -> Requirement:
        """
        Parse a requirement string into a packaging Requirement.
        
        Attempts to parse req_as_string into a Requirement via get_requirement. On parse
        failure this raises InstallationError with a helpful message (it may include
        a hint if the string looks like a filesystem path or uses `=` instead of `==`).
        Also enforces that extras are not placed after version specifiers (e.g.
        `name>=1.0[extra]`), raising InstallationError if such a case is detected.
        
        Parameters:
            req_as_string (str): The raw requirement string to parse.
        
        Returns:
            Requirement: The parsed packaging Requirement.
        
        Raises:
            InstallationError: If the string is not a valid requirement or contains
                extras after a version specifier.
        """
        try:
            req = get_requirement(req_as_string)
        except InvalidRequirement:
            if os.path.sep in req_as_string:
                add_msg = "It looks like a path."
                add_msg += deduce_helpful_msg(req_as_string)
            elif "=" in req_as_string and not any(
                op in req_as_string for op in operators
            ):
                add_msg = "= is not a valid operator. Did you mean == ?"
            else:
                add_msg = ""
            msg = with_source(f"Invalid requirement: {req_as_string!r}")
            if add_msg:
                msg += f"\nHint: {add_msg}"
            raise InstallationError(msg)
        else:
            # Deprecate extras after specifiers: "name>=1.0[extras]"
            # This currently works by accident because _strip_extras() parses
            # any extras in the end of the string and those are saved in
            # RequirementParts
            for spec in req.specifier:
                spec_str = str(spec)
                if spec_str.endswith("]"):
                    msg = f"Extras after version '{spec_str}'."
                    raise InstallationError(msg)
        return req

    if req_as_string is not None:
        req: Optional[Requirement] = _parse_req_string(req_as_string)
    else:
        req = None

    return RequirementParts(req, link, markers, extras)


def install_req_from_line(
    name: str,
    comes_from: Optional[Union[str, InstallRequirement]] = None,
    *,
    use_pep517: Optional[bool] = None,
    isolated: bool = False,
    global_options: Optional[List[str]] = None,
    hash_options: Optional[Dict[str, List[str]]] = None,
    constraint: bool = False,
    line_source: Optional[str] = None,
    user_supplied: bool = False,
    config_settings: Optional[Dict[str, Union[str, List[str]]]] = None,
) -> InstallRequirement:
    """
    Create an InstallRequirement from a requirement line which may be a requirement specifier,
    a path to a directory or archive, a filename (wheel/archive), or a URL.
    
    Parameters:
        comes_from (Optional[Union[str, InstallRequirement]]):
            Optional origin of the requirement (e.g., filename or parent InstallRequirement)
            used to record where this requirement was specified.
        line_source (Optional[str]):
            Optional human-readable description of the source line (for error messages/logs).
    
    Returns:
        InstallRequirement: A new InstallRequirement constructed from the parsed line.
    """
    parts = parse_req_from_line(name, line_source)

    return InstallRequirement(
        parts.requirement,
        comes_from,
        link=parts.link,
        markers=parts.markers,
        use_pep517=use_pep517,
        isolated=isolated,
        global_options=global_options,
        hash_options=hash_options,
        config_settings=config_settings,
        constraint=constraint,
        extras=parts.extras,
        user_supplied=user_supplied,
    )


def install_req_from_req_string(
    req_string: str,
    comes_from: Optional[InstallRequirement] = None,
    isolated: bool = False,
    use_pep517: Optional[bool] = None,
    user_supplied: bool = False,
) -> InstallRequirement:
    """
    Create an InstallRequirement from a raw requirement string.
    
    Parses req_string into a packaging Requirement and returns a new InstallRequirement
    wrapping that requirement and the provided context flags. If the string is not a
    valid requirement an InstallationError is raised. Additionally, if the parsed
    requirement refers to an external URL while comes_from is an InstallRequirement
    sourced from PyPI/TestPyPI, an InstallationError is raised to prevent PyPI-hosted
    packages from depending on non-PyPI resources.
    
    Args:
        req_string: A requirement string (e.g. "package==1.2.3" or a PEP 440 URL).
        comes_from: Optional InstallRequirement representing the requesting package
            (used to enforce PyPI dependency restrictions).
        isolated: Whether the created InstallRequirement should be treated as
            isolated from user/site configuration.
        use_pep517: Whether to use PEP 517 build isolation when building the package.
        user_supplied: Whether the requirement was supplied directly by the user.
    
    Returns:
        InstallRequirement: The constructed InstallRequirement for the parsed requirement.
    
    Raises:
        InstallationError: If the requirement string is invalid, or if a package
            installed from PyPI/TestPyPI depends on a non-PyPI URL.
    """
    try:
        req = get_requirement(req_string)
    except InvalidRequirement:
        raise InstallationError(f"Invalid requirement: '{req_string}'")

    domains_not_allowed = [
        PyPI.file_storage_domain,
        TestPyPI.file_storage_domain,
    ]
    if (
        req.url
        and comes_from
        and comes_from.link
        and comes_from.link.netloc in domains_not_allowed
    ):
        # Explicitly disallow pypi packages that depend on external urls
        raise InstallationError(
            "Packages installed from PyPI cannot depend on packages "
            "which are not also hosted on PyPI.\n"
            f"{comes_from.name} depends on {req} "
        )

    return InstallRequirement(
        req,
        comes_from,
        isolated=isolated,
        use_pep517=use_pep517,
        user_supplied=user_supplied,
    )


def install_req_from_parsed_requirement(
    parsed_req: ParsedRequirement,
    isolated: bool = False,
    use_pep517: Optional[bool] = None,
    user_supplied: bool = False,
    config_settings: Optional[Dict[str, Union[str, List[str]]]] = None,
) -> InstallRequirement:
    """
    Create an InstallRequirement from a ParsedRequirement.
    
    If the parsed requirement is editable, delegates to install_req_from_editable; otherwise delegates to install_req_from_line, propagating relevant flags and options.
    
    Parameters:
        parsed_req (ParsedRequirement): The parsed requirement record to convert. May represent an editable or normal requirement and may contain options, hashes, source info, and a constraint flag.
        isolated (bool): Whether to build the InstallRequirement in isolated mode (no user configuration).
        use_pep517 (Optional[bool]): Whether to use PEP 517 when building the package; None leaves the decision to upstream defaults.
        user_supplied (bool): Whether the requirement was explicitly supplied by the user (affects reporting/validation).
        config_settings (Optional[Dict[str, Union[str, List[str]]]]): Optional build-time configuration settings forwarded to the created InstallRequirement.
    
    Returns:
        InstallRequirement: The constructed InstallRequirement corresponding to parsed_req.
    """
    if parsed_req.is_editable:
        req = install_req_from_editable(
            parsed_req.requirement,
            comes_from=parsed_req.comes_from,
            use_pep517=use_pep517,
            constraint=parsed_req.constraint,
            isolated=isolated,
            user_supplied=user_supplied,
            config_settings=config_settings,
        )

    else:
        req = install_req_from_line(
            parsed_req.requirement,
            comes_from=parsed_req.comes_from,
            use_pep517=use_pep517,
            isolated=isolated,
            global_options=(
                parsed_req.options.get("global_options", [])
                if parsed_req.options
                else []
            ),
            hash_options=(
                parsed_req.options.get("hashes", {}) if parsed_req.options else {}
            ),
            constraint=parsed_req.constraint,
            line_source=parsed_req.line_source,
            user_supplied=user_supplied,
            config_settings=config_settings,
        )
    return req


def install_req_from_link_and_ireq(
    link: Link, ireq: InstallRequirement
) -> InstallRequirement:
    """
    Create a new InstallRequirement by copying all attributes from an existing one but using a different Link.
    
    The returned InstallRequirement preserves the original requirement, provenance, editability flag,
    markers, build/settings flags, and user-supplied status from `ireq`, while setting its `link`
    to the provided `link`.
    
    Parameters:
        link: Link to associate with the new InstallRequirement.
        ireq: InstallRequirement to copy attributes from.
    
    Returns:
        A new InstallRequirement with `link` replaced and other fields copied from `ireq`.
    """
    return InstallRequirement(
        req=ireq.req,
        comes_from=ireq.comes_from,
        editable=ireq.editable,
        link=link,
        markers=ireq.markers,
        use_pep517=ireq.use_pep517,
        isolated=ireq.isolated,
        global_options=ireq.global_options,
        hash_options=ireq.hash_options,
        config_settings=ireq.config_settings,
        user_supplied=ireq.user_supplied,
    )


def install_req_drop_extras(ireq: InstallRequirement) -> InstallRequirement:
    """
    Create a new InstallRequirement based on ireq but with all extras removed.
    
    The returned InstallRequirement:
    - has its `req` updated to a Requirement with no extras (if ireq.req is not None);
    - sets `comes_from` to the original ireq;
    - preserves fields like `editable`, `link`, `markers`, `use_pep517`, `isolated`,
      `global_options`, `hash_options`, `constraint`, `config_settings`,
      `user_supplied`, and `permit_editable_wheels`;
    - has `extras` set to an empty list.
    
    Returns:
        InstallRequirement: a shallow-copy InstallRequirement with extras dropped.
    """
    return InstallRequirement(
        req=(
            _set_requirement_extras(ireq.req, set()) if ireq.req is not None else None
        ),
        comes_from=ireq,
        editable=ireq.editable,
        link=ireq.link,
        markers=ireq.markers,
        use_pep517=ireq.use_pep517,
        isolated=ireq.isolated,
        global_options=ireq.global_options,
        hash_options=ireq.hash_options,
        constraint=ireq.constraint,
        extras=[],
        config_settings=ireq.config_settings,
        user_supplied=ireq.user_supplied,
        permit_editable_wheels=ireq.permit_editable_wheels,
    )


def install_req_extend_extras(
    ireq: InstallRequirement,
    extras: Collection[str],
) -> InstallRequirement:
    """
    Return a shallow copy of an InstallRequirement with additional extras applied.
    
    The returned InstallRequirement is a shallow copy of `ireq` whose `extras` set
    is extended with the provided `extras`. If `ireq.req` is present, it is
    replaced with a new Requirement object that has its extras updated to the
    resulting set. The original `ireq` object is not modified.
    
    Parameters:
        ireq (InstallRequirement): The installation requirement to copy.
        extras (Collection[str]): Extras to add to the requirement (merged into a set).
    
    Returns:
        InstallRequirement: A new InstallRequirement with the merged extras and, if
        applicable, an updated Requirement reflecting those extras.
    """
    result = copy.copy(ireq)
    result.extras = {*ireq.extras, *extras}
    result.req = (
        _set_requirement_extras(ireq.req, result.extras)
        if ireq.req is not None
        else None
    )
    return result
