"""Exceptions used throughout package.

This module MUST NOT try to import from anything within `pip._internal` to
operate. This is expected to be importable from any/all files within the
subpackage and, thus, should not depend on them.
"""

import configparser
import contextlib
import locale
import logging
import pathlib
import re
import sys
from itertools import chain, groupby, repeat
from typing import TYPE_CHECKING, Dict, Iterator, List, Optional, Union

from pip._vendor.requests.models import Request, Response
from pip._vendor.rich.console import Console, ConsoleOptions, RenderResult
from pip._vendor.rich.markup import escape
from pip._vendor.rich.text import Text

if TYPE_CHECKING:
    from hashlib import _Hash
    from typing import Literal

    from pip._internal.metadata import BaseDistribution
    from pip._internal.req.req_install import InstallRequirement

logger = logging.getLogger(__name__)


#
# Scaffolding
#
def _is_kebab_case(s: str) -> bool:
    """
    Return True if the input string is kebab-case (lowercase words separated by single hyphens).
    
    A valid kebab-case string consists of one or more ASCII lowercase letters (a–z) optionally separated
    by single hyphens; it does not allow leading, trailing, or consecutive hyphens and is non-empty.
    
    Parameters:
        s: The string to test.
    
    Returns:
        bool: True if `s` matches kebab-case, otherwise False.
    """
    return re.match(r"^[a-z]+(-[a-z]+)*$", s) is not None


def _prefix_with_indent(
    s: Union[Text, str],
    console: Console,
    *,
    prefix: str,
    indent: str,
) -> Text:
    """
    Prefix each line of `s` with `prefix`, adding `indent` before every subsequent line, and return the result as a Rich `Text` object.
    
    If `s` is already a `Text` it is used directly; otherwise it is rendered via `console`. Newlines in `s` are preserved (including blank lines). The returned `Text` begins with `prefix` followed by the first line of `s`; later lines are prefixed by `prefix` then `indent`.
    Parameters:
        s (Union[Text, str]): Text or string to format.
        prefix (str): String to prepend to the start of each output line.
        indent (str): String inserted after `prefix` before every line except the first.
    
    Returns:
        Text: A Rich `Text` object with `prefix`/`indent` applied per-line.
    """
    if isinstance(s, Text):
        text = s
    else:
        text = console.render_str(s)

    return console.render_str(prefix, overflow="ignore") + console.render_str(
        f"\n{indent}", overflow="ignore"
    ).join(text.split(allow_blank=True))


class PipError(Exception):
    """The base pip error."""


class DiagnosticPipError(PipError):
    """An error, that presents diagnostic information to the user.

    This contains a bunch of logic, to enable pretty presentation of our error
    messages. Each error gets a unique reference. Each error can also include
    additional context, a hint and/or a note -- which are presented with the
    main error message in a consistent style.

    This is adapted from the error output styling in `sphinx-theme-builder`.
    """

    reference: str

    def __init__(
        self,
        *,
        kind: 'Literal["error", "warning"]' = "error",
        reference: Optional[str] = None,
        message: Union[str, Text],
        context: Optional[Union[str, Text]],
        hint_stmt: Optional[Union[str, Text]],
        note_stmt: Optional[Union[str, Text]] = None,
        link: Optional[str] = None,
    ) -> None:
        # Ensure a proper reference is provided.
        """
        Initialize a DiagnosticPipError with structured diagnostic fields.
        
        Creates a diagnostic error instance with a severity `kind` ("error" or "warning"), a kebab-case `reference` identifier (falls back to the class attribute if not provided), a main `message`, optional `context`, optional `hint_stmt` and `note_stmt`, and an optional `link`. Validates that the resolved reference is kebab-case.
        
        Attributes set on the instance:
        - kind: str
        - reference: str
        - message: Union[str, Text]
        - context: Optional[Union[str, Text]]
        - hint_stmt: Optional[Union[str, Text]]
        - note_stmt: Optional[Union[str, Text]]
        - link: Optional[str]
        
        The base Exception is initialized with a short representation including the class name and reference.
        """
        if reference is None:
            assert hasattr(self, "reference"), "error reference not provided!"
            reference = self.reference
        assert _is_kebab_case(reference), "error reference must be kebab-case!"

        self.kind = kind
        self.reference = reference

        self.message = message
        self.context = context

        self.note_stmt = note_stmt
        self.hint_stmt = hint_stmt

        self.link = link

        super().__init__(f"<{self.__class__.__name__}: {self.reference}>")

    def __repr__(self) -> str:
        """
        Return a compact, machine-readable representation of the diagnostic error.
        
        The returned string includes the exception class name and the key diagnostic fields:
        reference, message, context, note_stmt, and hint_stmt — useful for debugging
        and logging where a single-line summary is desired.
        
        Returns:
            str: A one-line representation formatted as
            "<ClassName(reference=..., message=..., context=..., note_stmt=..., hint_stmt=...)>".
        """
        return (
            f"<{self.__class__.__name__}("
            f"reference={self.reference!r}, "
            f"message={self.message!r}, "
            f"context={self.context!r}, "
            f"note_stmt={self.note_stmt!r}, "
            f"hint_stmt={self.hint_stmt!r}"
            ")>"
        )

    def __rich_console__(
        self,
        console: Console,
        options: ConsoleOptions,
    ) -> RenderResult:
        """
        Render the diagnostic as a sequence of Rich-compatible console renderables.
        
        Yields a header line containing the kind ("error" or "warning") and the reference, then the main message. If `options.ascii_only` is False, the message and optional context are produced with indented, prefixed lines and colorized glyphs (red for errors, yellow for warnings); otherwise the message and context are emitted as plain lines. Optional `note_stmt` and `hint_stmt` are rendered with "note" and "hint" prefixes, and an optional link is appended at the end.
        
        Returns:
            RenderResult: an iterator of strings/Text objects suitable for Rich console rendering.
        """
        colour = "red" if self.kind == "error" else "yellow"

        yield f"[{colour} bold]{self.kind}[/]: [bold]{self.reference}[/]"
        yield ""

        if not options.ascii_only:
            # Present the main message, with relevant context indented.
            if self.context is not None:
                yield _prefix_with_indent(
                    self.message,
                    console,
                    prefix=f"[{colour}]×[/] ",
                    indent=f"[{colour}]│[/] ",
                )
                yield _prefix_with_indent(
                    self.context,
                    console,
                    prefix=f"[{colour}]╰─>[/] ",
                    indent=f"[{colour}]   [/] ",
                )
            else:
                yield _prefix_with_indent(
                    self.message,
                    console,
                    prefix="[red]×[/] ",
                    indent="  ",
                )
        else:
            yield self.message
            if self.context is not None:
                yield ""
                yield self.context

        if self.note_stmt is not None or self.hint_stmt is not None:
            yield ""

        if self.note_stmt is not None:
            yield _prefix_with_indent(
                self.note_stmt,
                console,
                prefix="[magenta bold]note[/]: ",
                indent="      ",
            )
        if self.hint_stmt is not None:
            yield _prefix_with_indent(
                self.hint_stmt,
                console,
                prefix="[cyan bold]hint[/]: ",
                indent="      ",
            )

        if self.link is not None:
            yield ""
            yield f"Link: {self.link}"


#
# Actual Errors
#
class ConfigurationError(PipError):
    """General exception in configuration"""


class InstallationError(PipError):
    """General exception during installation"""


class UninstallationError(PipError):
    """General exception during uninstallation"""


class MissingPyProjectBuildRequires(DiagnosticPipError):
    """Raised when pyproject.toml has `build-system`, but no `build-system.requires`."""

    reference = "missing-pyproject-build-system-requires"

    def __init__(self, *, package: str) -> None:
        """
        Initialize a DiagnosticPipError for a package whose pyproject.toml is missing the
        mandatory build-system `requires` key.
        
        Parameters:
            package (str): The package name shown in the error message and context.
        """
        super().__init__(
            message=f"Can not process {escape(package)}",
            context=Text(
                "This package has an invalid pyproject.toml file.\n"
                "The [build-system] table is missing the mandatory `requires` key."
            ),
            note_stmt="This is an issue with the package mentioned above, not pip.",
            hint_stmt=Text("See PEP 518 for the detailed specification."),
        )


class InvalidPyProjectBuildRequires(DiagnosticPipError):
    """Raised when pyproject.toml an invalid `build-system.requires`."""

    reference = "invalid-pyproject-build-system-requires"

    def __init__(self, *, package: str, reason: str) -> None:
        """
        Initialize an InvalidPyProjectBuildRequires diagnostic for a package whose pyproject.toml has an invalid build-system.requires.
        
        Creates a DiagnosticPipError describing that the given package cannot be processed because its `build-system.requires` key is invalid. The provided reason is included as the diagnostic context; the diagnostic also includes a note that the problem is with the package (not pip) and a hint directing users to PEP 518.
        
        Parameters:
            package (str): The package name (displayed in the error message).
            reason (str): A short explanation of why the `build-system.requires` value is invalid (included in the diagnostic context).
        """
        super().__init__(
            message=f"Can not process {escape(package)}",
            context=Text(
                "This package has an invalid `build-system.requires` key in "
                f"pyproject.toml.\n{reason}"
            ),
            note_stmt="This is an issue with the package mentioned above, not pip.",
            hint_stmt=Text("See PEP 518 for the detailed specification."),
        )


class NoneMetadataError(PipError):
    """Raised when accessing a Distribution's "METADATA" or "PKG-INFO".

    This signifies an inconsistency, when the Distribution claims to have
    the metadata file (if not, raise ``FileNotFoundError`` instead), but is
    not actually able to produce its content. This may be due to permission
    errors.
    """

    def __init__(
        self,
        dist: "BaseDistribution",
        metadata_name: str,
    ) -> None:
        """
        Initialize the exception indicating a distribution is missing the requested metadata.
        
        Parameters:
            dist: The distribution object whose metadata was queried.
            metadata_name: The metadata file name being requested (e.g., "METADATA" or "PKG-INFO").
        """
        self.dist = dist
        self.metadata_name = metadata_name

    def __str__(self) -> str:
        # Use `dist` in the error message because its stringification
        # includes more information, like the version and location.
        """
        Return a human-readable message stating that the specified metadata is missing for the distribution.
        
        The returned string includes the metadata field name and the distribution's string representation
        (which typically includes name, version, and location).
        """
        return f"None {self.metadata_name} metadata found for distribution: {self.dist}"


class UserInstallationInvalid(InstallationError):
    """A --user install is requested on an environment without user site."""

    def __str__(self) -> str:
        """
        Return a short, human-readable message for this error.
        
        The string indicates that the user base installation directory is not configured.
        """
        return "User base directory is not specified"


class InvalidSchemeCombination(InstallationError):
    def __str__(self) -> str:
        """
        Return a human-readable message describing incompatible scheme options.
        
        The string lists all arguments except the last joined by commas, then appends the last
        argument with "and" to form: "Cannot set <a, b, ...> and <z> together".
        
        Returns:
            str: The formatted conflict message.
        """
        before = ", ".join(str(a) for a in self.args[:-1])
        return f"Cannot set {before} and {self.args[-1]} together"


class DistributionNotFound(InstallationError):
    """Raised when a distribution cannot be found to satisfy a requirement"""


class RequirementsFileParseError(InstallationError):
    """Raised when a general error occurs parsing a requirements file line."""


class BestVersionAlreadyInstalled(PipError):
    """Raised when the most up-to-date version of a package is already
    installed."""


class BadCommand(PipError):
    """Raised when virtualenv or a command is not found"""


class CommandError(PipError):
    """Raised when there is an error in command-line arguments"""


class PreviousBuildDirError(PipError):
    """Raised when there's a previous conflicting build directory"""


class NetworkConnectionError(PipError):
    """HTTP connection error"""

    def __init__(
        self,
        error_msg: str,
        response: Optional[Response] = None,
        request: Optional[Request] = None,
    ) -> None:
        """
        Initialize the NetworkConnectionError with message and optional HTTP request/response context.
        
        If a Response is provided but no Request, and the Response has a `request` attribute, that request is used.
        Parameters:
            error_msg (str): Human-readable error message stored on the exception.
            response (Optional[Response]): Optional HTTP response associated with the error.
            request (Optional[Request]): Optional HTTP request associated with the error; if omitted and
                `response` has a `request` attribute, that request will be used.
        """
        self.response = response
        self.request = request
        self.error_msg = error_msg
        if (
            self.response is not None
            and not self.request
            and hasattr(response, "request")
        ):
            self.request = self.response.request
        super().__init__(error_msg, response, request)

    def __str__(self) -> str:
        """
        Return the stored error message for this exception.
        
        Returns:
            str: The exception's error message (the value of self.error_msg).
        """
        return str(self.error_msg)


class InvalidWheelFilename(InstallationError):
    """Invalid wheel filename."""


class UnsupportedWheel(InstallationError):
    """Unsupported wheel."""


class InvalidWheel(InstallationError):
    """Invalid (e.g. corrupt) wheel."""

    def __init__(self, location: str, name: str):
        """
        Initialize an InvalidWheel error with the wheel's storage location and filename.
        
        Parameters:
            location (str): Filesystem path or URI where the invalid wheel was found.
            name (str): The wheel filename (basename) that was determined to be invalid.
        """
        self.location = location
        self.name = name

    def __str__(self) -> str:
        """
        Return a human-readable description of the invalid wheel.
        
        Produces a string stating the wheel filename and its location, e.g.
        "Wheel 'name' located at /path/to/file is invalid."
        """
        return f"Wheel '{self.name}' located at {self.location} is invalid."


class MetadataInconsistent(InstallationError):
    """Built metadata contains inconsistent information.

    This is raised when the metadata contains values (e.g. name and version)
    that do not match the information previously obtained from sdist filename,
    user-supplied ``#egg=`` value, or an install requirement name.
    """

    def __init__(
        self, ireq: "InstallRequirement", field: str, f_val: str, m_val: str
    ) -> None:
        """
        Initialize a MetadataInconsistent error describing a mismatch between the requested requirement and the installed distribution metadata.
        
        Parameters:
            ireq (InstallRequirement): The requirement object that triggered the inconsistency (identifies the requested package/version).
            field (str): The metadata field that is inconsistent (e.g., "Name" or "Version").
            f_val (str): The value expected by the requirement (the requested/required value).
            m_val (str): The value found in the distribution metadata.
        """
        self.ireq = ireq
        self.field = field
        self.f_val = f_val
        self.m_val = m_val

    def __str__(self) -> str:
        """
        Return a human-readable description of a metadata inconsistency.
        
        The string identifies the InstallRequirement, the metadata field, the expected value,
        and the value found in the package metadata.
        
        Returns:
            str: Formatted message describing the inconsistency.
        """
        return (
            f"Requested {self.ireq} has inconsistent {self.field}: "
            f"expected {self.f_val!r}, but metadata has {self.m_val!r}"
        )


class InstallationSubprocessError(DiagnosticPipError, InstallationError):
    """A subprocess call failed."""

    reference = "subprocess-exited-with-error"

    def __init__(
        self,
        *,
        command_description: str,
        exit_code: int,
        output_lines: Optional[List[str]],
    ) -> None:
        """
        Initialize an InstallationSubprocessError describing a failed subprocess run.
        
        Parameters:
            command_description (str): Short human-readable description of the command that was run (used in the displayed message).
            exit_code (int): The subprocess exit code.
            output_lines (Optional[List[str]]): If provided, the captured stdout/stderr lines to display as the error's context; if None, a generic "See above for output." prompt is used.
        
        Notes:
            The constructor builds a user-facing diagnostic message and context for rich rendering and stores
            `command_description` and `exit_code` on the instance.
        """
        if output_lines is None:
            output_prompt = Text("See above for output.")
        else:
            output_prompt = (
                Text.from_markup(f"[red][{len(output_lines)} lines of output][/]\n")
                + Text("".join(output_lines))
                + Text.from_markup(R"[red]\[end of output][/]")
            )

        super().__init__(
            message=(
                f"[green]{escape(command_description)}[/] did not run successfully.\n"
                f"exit code: {exit_code}"
            ),
            context=output_prompt,
            hint_stmt=None,
            note_stmt=(
                "This error originates from a subprocess, and is likely not a "
                "problem with pip."
            ),
        )

        self.command_description = command_description
        self.exit_code = exit_code

    def __str__(self) -> str:
        """
        Return a concise description of the subprocess failure.
        
        The returned string is formatted as "<command_description> exited with <exit_code>",
        where `command_description` is the command that was run and `exit_code` is its exit status.
        
        Returns:
            str: The formatted error message.
        """
        return f"{self.command_description} exited with {self.exit_code}"


class MetadataGenerationFailed(InstallationSubprocessError, InstallationError):
    reference = "metadata-generation-failed"

    def __init__(
        self,
        *,
        package_details: str,
    ) -> None:
        """
        Initialize the exception for a failed metadata-generation subprocess.
        
        Parameters:
            package_details (str): Human-readable details about the package or the subprocess output (e.g., package name, path, or captured error text). This text is used as the diagnostic context presented to the user.
        """
        super(InstallationSubprocessError, self).__init__(
            message="Encountered error while generating package metadata.",
            context=escape(package_details),
            hint_stmt="See above for details.",
            note_stmt="This is an issue with the package mentioned above, not pip.",
        )

    def __str__(self) -> str:
        """
        Return a short, human-readable representation of the error.
        
        Returns:
            str: The fixed message "metadata generation failed".
        """
        return "metadata generation failed"


class HashErrors(InstallationError):
    """Multiple HashError instances rolled into one for reporting"""

    def __init__(self) -> None:
        """
        Initialize an empty collection of HashError instances.
        
        Creates the attribute `errors`, a list that will hold HashError objects appended later.
        """
        self.errors: List["HashError"] = []

    def append(self, error: "HashError") -> None:
        """
        Add a HashError to this collection.
        
        Parameters:
            error (HashError): The hash error to append to the aggregator.
        """
        self.errors.append(error)

    def __str__(self) -> str:
        """
        Return a formatted multi-line string describing all contained hash errors.
        
        Each HashError is grouped by its concrete class (in order determined by each error's
        `order` attribute), with the class `head` as a section header followed by each
        error's `body()` lines. If no errors are present, returns an empty string.
        
        Returns:
            str: The composed, newline-separated diagnostic message for the aggregated errors,
                 or an empty string when there are no errors.
        """
        lines = []
        self.errors.sort(key=lambda e: e.order)
        for cls, errors_of_cls in groupby(self.errors, lambda e: e.__class__):
            lines.append(cls.head)
            lines.extend(e.body() for e in errors_of_cls)
        if lines:
            return "\n".join(lines)
        return ""

    def __bool__(self) -> bool:
        """
        Return True if this HashErrors container has any recorded errors.
        
        This implements truthiness for the collection by returning True when the
        internal `errors` list is non-empty and False otherwise.
        
        Returns:
            bool: True if there is at least one error, False if empty.
        """
        return bool(self.errors)


class HashError(InstallationError):
    """
    A failure to verify a package against known-good hashes

    :cvar order: An int sorting hash exception classes by difficulty of
        recovery (lower being harder), so the user doesn't bother fretting
        about unpinned packages when he has deeper issues, like VCS
        dependencies, to deal with. Also keeps error reports in a
        deterministic order.
    :cvar head: A section heading for display above potentially many
        exceptions of this kind
    :ivar req: The InstallRequirement that triggered this error. This is
        pasted on after the exception is instantiated, because it's not
        typically available earlier.

    """

    req: Optional["InstallRequirement"] = None
    head = ""
    order: int = -1

    def body(self) -> str:
        """
        Return a short, human-readable body text describing the requirement that triggered the error.
        
        This default implementation uses the instance's `req` (if set) to produce a single indented line suitable for display under the error heading.
        """
        return f"    {self._requirement_name()}"

    def __str__(self) -> str:
        """
        Return the textual representation of this hash error.
        
        Combines the class-level `head` (a heading describing the error category) with the instance-specific `body()` output, separated by a single newline.
        
        Returns:
            str: The formatted error text: "<head>\\n<body()>".
        """
        return f"{self.head}\n{self.body()}"

    def _requirement_name(self) -> str:
        """
        Return a human-readable name for the requirement that caused this error.
        
        If the instance has a bound `req`, its string representation is returned; otherwise
        returns "unknown package".
        """
        return str(self.req) if self.req else "unknown package"


class VcsHashUnsupported(HashError):
    """A hash was provided for a version-control-system-based requirement, but
    we don't have a method for hashing those."""

    order = 0
    head = (
        "Can't verify hashes for these requirements because we don't "
        "have a way to hash version control repositories:"
    )


class DirectoryUrlHashUnsupported(HashError):
    """A hash was provided for a version-control-system-based requirement, but
    we don't have a method for hashing those."""

    order = 1
    head = (
        "Can't verify hashes for these file:// requirements because they "
        "point to directories:"
    )


class HashMissing(HashError):
    """A hash was needed for a requirement but is absent."""

    order = 2
    head = (
        "Hashes are required in --require-hashes mode, but they are "
        "missing from some requirements. Here is a list of those "
        "requirements along with the hashes their downloaded archives "
        "actually had. Add lines like these to your requirements files to "
        "prevent tampering. (If you did not enable --require-hashes "
        "manually, note that it turns on automatically when any package "
        "has a hash.)"
    )

    def __init__(self, gotten_hash: str) -> None:
        """
        Initialize a HashMissing error recording the hash observed for a downloaded file.
        
        Parameters:
            gotten_hash (str): The actual hash value computed from the downloaded archive (the hash that was obtained/observed).
        """
        self.gotten_hash = gotten_hash

    def body(self) -> str:
        # Dodge circular import.
        """
        Return a requirements-style line showing the package and the missing hash.
        
        The returned string is formatted so it can be pasted into a requirements file:
        it uses the requirement's original URL when the requirement is direct (URL-based)
        so the output is copy/paste-friendly; otherwise it uses the requirement object or
        "unknown package" if unavailable. The hash algorithm name is taken from the
        module's FAVORITE_HASH and combined with the stored `gotten_hash`.
        
        Returns:
            str: A single indented line like
                 "    <package-or-url> --hash=<favorite-hash>:<gotten_hash>"
        """
        from pip._internal.utils.hashes import FAVORITE_HASH

        package = None
        if self.req:
            # In the case of URL-based requirements, display the original URL
            # seen in the requirements file rather than the package name,
            # so the output can be directly copied into the requirements file.
            package = (
                self.req.original_link
                if self.req.is_direct
                # In case someone feeds something downright stupid
                # to InstallRequirement's constructor.
                else getattr(self.req, "req", None)
            )
        return "    {} --hash={}:{}".format(
            package or "unknown package", FAVORITE_HASH, self.gotten_hash
        )


class HashUnpinned(HashError):
    """A requirement had a hash specified but was not pinned to a specific
    version."""

    order = 3
    head = (
        "In --require-hashes mode, all requirements must have their "
        "versions pinned with ==. These do not:"
    )


class HashMismatch(HashError):
    """
    Distribution file hash values don't match.

    :ivar package_name: The name of the package that triggered the hash
        mismatch. Feel free to write to this after the exception is raise to
        improve its error message.

    """

    order = 4
    head = (
        "THESE PACKAGES DO NOT MATCH THE HASHES FROM THE REQUIREMENTS "
        "FILE. If you have updated the package versions, please update "
        "the hashes. Otherwise, examine the package contents carefully; "
        "someone may have tampered with them."
    )

    def __init__(self, allowed: Dict[str, List[str]], gots: Dict[str, "_Hash"]) -> None:
        """
        Initialize a HashMismatch with the expected and observed hashes.
        
        Parameters:
            allowed (Dict[str, List[str]]): Mapping from hash algorithm names (e.g., "sha256")
                to the list of allowed hex digest strings for the requirement.
            gots (Dict[str, "_Hash"]): Mapping from hash algorithm names to the hashes
                actually computed/obtained for the downloaded files.
        
        The values are stored on the instance as `self.allowed` and `self.gots`.
        """
        self.allowed = allowed
        self.gots = gots

    def body(self) -> str:
        """
        Return the formatted body text for this HashError.
        
        The string contains an indented requirement identifier followed by a newline and
        the detailed hash-comparison block produced by _hash_comparison().
        
        Returns:
            A multi-line string describing the triggering requirement and the hash comparison.
        """
        return f"    {self._requirement_name()}:\n{self._hash_comparison()}"

    def _hash_comparison(self) -> str:
        """
        Return a formatted, multi-line textual comparison of expected and actual hashes.
        
        For each hash algorithm in self.allowed, the result contains one or more
        "Expected <algorithm> <hash>" lines (multiple expected hashes are joined
        with an indented "or" marker) followed by a "Got <hex>" line showing the
        actual hex digest from self.gots for that algorithm.
        
        Returns:
            A string with the assembled comparison block; suitable for inclusion
            in human-readable error messages.
        """

        def hash_then_or(hash_name: str) -> "chain[str]":
            # For now, all the decent hashes have 6-char names, so we can get
            # away with hard-coding space literals.
            """
            Return an iterator that yields the given hash name once followed by an infinite sequence of the string "    or".
            
            Parameters:
                hash_name (str): A hash algorithm label (e.g., "sha256"). The first value yielded is this name.
            
            Returns:
                Iterator[str]: An iterator producing the sequence [hash_name, "    or", "    or", ...], useful for aligning multi-line hash comparison output.
            """
            return chain([hash_name], repeat("    or"))

        lines: List[str] = []
        for hash_name, expecteds in self.allowed.items():
            prefix = hash_then_or(hash_name)
            lines.extend((f"        Expected {next(prefix)} {e}") for e in expecteds)
            lines.append(
                f"             Got        {self.gots[hash_name].hexdigest()}\n"
            )
        return "\n".join(lines)


class UnsupportedPythonVersion(InstallationError):
    """Unsupported python version according to Requires-Python package
    metadata."""


class ConfigurationFileCouldNotBeLoaded(ConfigurationError):
    """When there are errors while loading a configuration file"""

    def __init__(
        self,
        reason: str = "could not be loaded",
        fname: Optional[str] = None,
        error: Optional[configparser.Error] = None,
    ) -> None:
        """
        Initialize the ConfigurationFileCouldNotBeLoaded error.
        
        Parameters:
            reason (str): Brief description of why the configuration file could not be loaded; defaults to "could not be loaded".
            fname (Optional[str]): Path or name of the configuration file involved, if known.
            error (Optional[configparser.Error]): The underlying parsing/IO error, if any; stored on the instance and passed to the base exception.
        """
        super().__init__(error)
        self.reason = reason
        self.fname = fname
        self.error = error

    def __str__(self) -> str:
        """
        Return a human-readable message describing why a configuration file could not be loaded.
        
        If a filename (fname) is set, returns:
            "Configuration file {reason} in {fname}."
        
        Otherwise, expects an error object and returns:
            "Configuration file {reason}.\n{error}\n"
        
        This string is used for end-user display and includes either the file name or the underlying parsing/IO error.
        """
        if self.fname is not None:
            message_part = f" in {self.fname}."
        else:
            assert self.error is not None
            message_part = f".\n{self.error}\n"
        return f"Configuration file {self.reason}{message_part}"


_DEFAULT_EXTERNALLY_MANAGED_ERROR = f"""\
The Python environment under {sys.prefix} is managed externally, and may not be
manipulated by the user. Please use specific tooling from the distributor of
the Python installation to interact with this environment instead.
"""


class ExternallyManagedEnvironment(DiagnosticPipError):
    """The current environment is externally managed.

    This is raised when the current environment is externally managed, as
    defined by `PEP 668`_. The ``EXTERNALLY-MANAGED`` configuration is checked
    and displayed when the error is bubbled up to the user.

    :param error: The error message read from ``EXTERNALLY-MANAGED``.
    """

    reference = "externally-managed-environment"

    def __init__(self, error: Optional[str]) -> None:
        """
        Initialize an ExternallyManagedEnvironment diagnostic error.
        
        If `error` is provided, it is used as the human-facing context text shown to the user;
        otherwise a built-in default externally-managed message is used. The exception's
        primary message is fixed to "This environment is externally managed" and a note and
        hint (about contacting the distribution provider and PEP 668) are attached.
        Parameters:
            error (Optional[str]): Optional explicit error text to display as context. If
                None, a module-default explanatory message is used.
        """
        if error is None:
            context = Text(_DEFAULT_EXTERNALLY_MANAGED_ERROR)
        else:
            context = Text(error)
        super().__init__(
            message="This environment is externally managed",
            context=context,
            note_stmt=(
                "If you believe this is a mistake, please contact your "
                "Python installation or OS distribution provider. "
                "You can override this, at the risk of breaking your Python "
                "installation or OS, by passing --break-system-packages."
            ),
            hint_stmt=Text("See PEP 668 for the detailed specification."),
        )

    @staticmethod
    def _iter_externally_managed_error_keys() -> Iterator[str]:
        # LC_MESSAGES is in POSIX, but not the C standard. The most common
        # platform that does not implement this category is Windows, where
        # using other categories for console message localization is equally
        # unreliable, so we fall back to the locale-less vendor message. This
        # can always be re-evaluated when a vendor proposes a new alternative.
        """
        Yield candidate config keys for localized "externally-managed" error messages.
        
        The generator produces locale-prefixed keys to look up vendor-provided error text, in order of preference:
        1. "Error-<lang>" where <lang> is the full locale returned by locale.getlocale(LC_MESSAGES) (when available).
        2. "Error-<base>" where <base> is the language portion before a '-' or '_' in the locale (if the locale contains a separator).
        3. "Error" as a locale-less fallback.
        
        If the LC_MESSAGES locale category is unavailable (common on Windows), this falls back directly to yielding "Error".
        """
        try:
            category = locale.LC_MESSAGES
        except AttributeError:
            lang: Optional[str] = None
        else:
            lang, _ = locale.getlocale(category)
        if lang is not None:
            yield f"Error-{lang}"
            for sep in ("-", "_"):
                before, found, _ = lang.partition(sep)
                if not found:
                    continue
                yield f"Error-{before}"
        yield "Error"

    @classmethod
    def from_config(
        cls,
        config: Union[pathlib.Path, str],
    ) -> "ExternallyManagedEnvironment":
        """
        Create an ExternallyManagedEnvironment from a config file.
        
        Reads the given INI-style config (no interpolation, UTF-8) and looks for an
        "externally-managed" section. It iterates the keys produced by
        _cls._iter_externally_managed_error_keys() and, on the first key present,
        returns an instance initialized with that section value. Missing keys are
        silently skipped; if the section is absent a KeyError is ignored. On I/O,
        decode, or parsing errors the function logs a warning and falls back to
        returning an instance constructed with None (causes use of the default
        externally-managed message).
        """
        parser = configparser.ConfigParser(interpolation=None)
        try:
            parser.read(config, encoding="utf-8")
            section = parser["externally-managed"]
            for key in cls._iter_externally_managed_error_keys():
                with contextlib.suppress(KeyError):
                    return cls(section[key])
        except KeyError:
            pass
        except (OSError, UnicodeDecodeError, configparser.ParsingError):
            from pip._internal.utils._log import VERBOSE

            exc_info = logger.isEnabledFor(VERBOSE)
            logger.warning("Failed to read %s", config, exc_info=exc_info)
        return cls(None)
