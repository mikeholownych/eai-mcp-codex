"""Configuration management setup

Some terminology:
- name
  As written in config files.
- value
  Value associated with a name
- key
  Name combined with it's section (section.name)
- variant
  A single word describing where the configuration key-value pair came from
"""

import configparser
import locale
import os
import sys
from typing import Any, Dict, Iterable, List, NewType, Optional, Tuple

from pip._internal.exceptions import (
    ConfigurationError,
    ConfigurationFileCouldNotBeLoaded,
)
from pip._internal.utils import appdirs
from pip._internal.utils.compat import WINDOWS
from pip._internal.utils.logging import getLogger
from pip._internal.utils.misc import ensure_dir, enum

RawConfigParser = configparser.RawConfigParser  # Shorthand
Kind = NewType("Kind", str)

CONFIG_BASENAME = "pip.ini" if WINDOWS else "pip.conf"
ENV_NAMES_IGNORED = "version", "help"

# The kinds of configurations there are.
kinds = enum(
    USER="user",  # User Specific
    GLOBAL="global",  # System Wide
    SITE="site",  # [Virtual] Environment Specific
    ENV="env",  # from PIP_CONFIG_FILE
    ENV_VAR="env-var",  # from Environment Variables
)
OVERRIDE_ORDER = kinds.GLOBAL, kinds.USER, kinds.SITE, kinds.ENV, kinds.ENV_VAR
VALID_LOAD_ONLY = kinds.USER, kinds.GLOBAL, kinds.SITE

logger = getLogger(__name__)


# NOTE: Maybe use the optionx attribute to normalize keynames.
def _normalize_name(name: str) -> str:
    """
    Normalize a configuration key or option name to a consistent, lowercased, dash-separated form.
    
    This converts underscores to hyphens and lowercases the input. If the name begins with a double dash (a long option),
    the leading `--` is stripped so option-style names become plain keys (e.g., `--no-cache` -> `no-cache`).
    """
    name = name.lower().replace("_", "-")
    if name.startswith("--"):
        name = name[2:]  # only prefer long opts
    return name


def _disassemble_key(name: str) -> List[str]:
    """
    Split a configuration key into its section and name parts.
    
    Accepts a key in the form "section.name" and returns a two-item list [section, name].
    
    Raises:
        ConfigurationError: If `name` does not contain a dot ('.'); the error message suggests using
        the `global.` prefix as a likely fix.
    """
    if "." not in name:
        error_message = (
            "Key does not contain dot separated section and key. "
            f"Perhaps you wanted to use 'global.{name}' instead?"
        )
        raise ConfigurationError(error_message)
    return name.split(".", 1)


def get_configuration_files() -> Dict[Kind, List[str]]:
    """
    Return the list of configuration file paths grouped by configuration source kind.
    
    The mapping keys are Kind values (kinds.GLOBAL, kinds.SITE, kinds.USER). Values are
    lists of filesystem paths in the order they should be considered for that source:
    - GLOBAL: all site-wide config files returned by appdirs.site_config_dirs("pip").
    - SITE: the single site-level config file located under sys.prefix.
    - USER: the legacy per-user config path (~/{pip|.pip}/CONFIG_BASENAME) first, then
      the current per-user config file in appdirs.user_config_dir("pip") second.
    
    Returns:
        Dict[Kind, List[str]]: Mapping from configuration source kind to a list of
        candidate config file paths.
    """
    global_config_files = [
        os.path.join(path, CONFIG_BASENAME) for path in appdirs.site_config_dirs("pip")
    ]

    site_config_file = os.path.join(sys.prefix, CONFIG_BASENAME)
    legacy_config_file = os.path.join(
        os.path.expanduser("~"),
        "pip" if WINDOWS else ".pip",
        CONFIG_BASENAME,
    )
    new_config_file = os.path.join(appdirs.user_config_dir("pip"), CONFIG_BASENAME)
    return {
        kinds.GLOBAL: global_config_files,
        kinds.SITE: [site_config_file],
        kinds.USER: [legacy_config_file, new_config_file],
    }


class Configuration:
    """Handles management of configuration.

    Provides an interface to accessing and managing configuration files.

    This class converts provides an API that takes "section.key-name" style
    keys and stores the value associated with it as "key-name" under the
    section "section".

    This allows for a clean interface wherein the both the section and the
    key-name are preserved in an easy to manage form in the configuration files
    and the data stored is also nice.
    """

    def __init__(self, isolated: bool, load_only: Optional[Kind] = None) -> None:
        """
        Initialize a Configuration instance.
        
        Parameters:
            isolated (bool): If True, ignore environment-derived configuration (only file sources are loaded).
            load_only (Optional[Kind]): If set, restricts mutations (set/unset) and editing to this configuration variant
                (one of VALID_LOAD_ONLY). When not None, must be a valid variant or a ConfigurationError is raised.
        
        Raises:
            ConfigurationError: If `load_only` is provided but not one of VALID_LOAD_ONLY.
        
        Notes:
            Initializes internal state used to track loaded parsers, per-variant configuration mappings, and
            parsers marked for modification:
              - self._parsers: mapping from variant to list of (filename, RawConfigParser) tuples
              - self._config: mapping from variant to dict of normalized key -> value
              - self._modified_parsers: list of (filename, RawConfigParser) scheduled for saving
        """
        super().__init__()

        if load_only is not None and load_only not in VALID_LOAD_ONLY:
            raise ConfigurationError(
                "Got invalid value for load_only - should be one of {}".format(
                    ", ".join(map(repr, VALID_LOAD_ONLY))
                )
            )
        self.isolated = isolated
        self.load_only = load_only

        # Because we keep track of where we got the data from
        self._parsers: Dict[Kind, List[Tuple[str, RawConfigParser]]] = {
            variant: [] for variant in OVERRIDE_ORDER
        }
        self._config: Dict[Kind, Dict[str, Any]] = {
            variant: {} for variant in OVERRIDE_ORDER
        }
        self._modified_parsers: List[Tuple[str, RawConfigParser]] = []

    def load(self) -> None:
        """
        Load configuration sources into memory.
        
        Reads configuration files (honoring the instance's `load_only` setting) and, unless the
        Configuration was created with `isolated=True`, also loads environment-derived settings.
        Populates the instance's internal parser list and per-source key/value mappings used by
        get_value, items, set_value, unset_value, and save.
        """
        self._load_config_files()
        if not self.isolated:
            self._load_environment_vars()

    def get_file_to_edit(self) -> Optional[str]:
        """
        Return the filename of the highest-priority configuration file that will be edited.
        
        Requires that the Configuration was constructed with a non-None `load_only` value (an assertion is raised if not). Returns the filename of the parser chosen for modification, or None if no suitable parser/file is available.
        """
        assert self.load_only is not None, "Need to be specified a file to be editing"

        try:
            return self._get_parser_to_modify()[0]
        except IndexError:
            return None

    def items(self) -> Iterable[Tuple[str, Any]]:
        """Returns key-value pairs like dict.items() representing the loaded
        configuration
        """
        return self._dictionary.items()

    def get_value(self, key: str) -> Any:
        """
        Return the value for a configuration key.
        
        The key is normalized before lookup (dash/underscore and case normalization,
        and optional leading `--` removed). Keys must be in `section.name` form;
        if the provided key is malformed or missing, a ConfigurationError is raised.
        
        Parameters:
            key (str): The configuration key to retrieve (e.g. "global.index-url" or "--global.index-url").
        
        Returns:
            Any: The value associated with `key`.
        
        Raises:
            ConfigurationError: If `key` is not a valid `section.name` form or is not present in the merged configuration.
        """
        orig_key = key
        key = _normalize_name(key)
        try:
            return self._dictionary[key]
        except KeyError:
            # disassembling triggers a more useful error message than simply
            # "No such key" in the case that the key isn't in the form command.option
            _disassemble_key(key)
            raise ConfigurationError(f"No such key - {orig_key}")

    def set_value(self, key: str, value: Any) -> None:
        """
        Set a configuration value for the active editable variant.
        
        This updates both the in-memory configuration and the underlying INI parser chosen
        for modification (creating the section if it does not exist), and marks that
        parser/file as modified so it will be written by save().
        
        Parameters:
            key: A configuration key in `section.name` form (will be normalized).
            value: The value to store for the key.
        
        Raises:
            ConfigurationError: If no editable variant has been selected (i.e., load_only
                is not set) or if no parser is available for the selected variant.
        """
        key = _normalize_name(key)
        self._ensure_have_load_only()

        assert self.load_only
        fname, parser = self._get_parser_to_modify()

        if parser is not None:
            section, name = _disassemble_key(key)

            # Modify the parser and the configuration
            if not parser.has_section(section):
                parser.add_section(section)
            parser.set(section, name, value)

        self._config[self.load_only][key] = value
        self._mark_as_modified(fname, parser)

    def unset_value(self, key: str) -> None:
        """
        Remove a configuration key from the currently editable variant.
        
        The provided key is normalized (section.name form is expected or derivable).
        This operation requires the Configuration to have a `load_only` target set;
        if not, a ConfigurationError is raised by _ensure_have_load_only.
        
        If the key is not present in the selected variant, a ConfigurationError is raised.
        The key is removed from the underlying parser chosen for modification; if the
        section becomes empty after removal, the section is removed as well. The parser
        is marked as modified but changes are not written to disk until save() is called.
        
        Parameters:
            key (str): The configuration key to remove (e.g., "global.index-url" or "index-url"
                when a section is implicit). The value will be normalized internally.
        
        Raises:
            ConfigurationError: If no editable variant is configured, the key does not exist
                in the current variant, or an internal removal error occurs.
        """
        orig_key = key
        key = _normalize_name(key)
        self._ensure_have_load_only()

        assert self.load_only
        if key not in self._config[self.load_only]:
            raise ConfigurationError(f"No such key - {orig_key}")

        fname, parser = self._get_parser_to_modify()

        if parser is not None:
            section, name = _disassemble_key(key)
            if not (
                parser.has_section(section) and parser.remove_option(section, name)
            ):
                # The option was not removed.
                raise ConfigurationError(
                    "Fatal Internal error [id=1]. Please report as a bug."
                )

            # The section may be empty after the option was removed.
            if not parser.items(section):
                parser.remove_section(section)
            self._mark_as_modified(fname, parser)

        del self._config[self.load_only][key]

    def save(self) -> None:
        """
        Save modified configuration parsers back to their files.
        
        Writes only parsers previously marked as modified. Ensures the target directory exists before writing and overwrites the target files with the INI content produced by each parser. Requires a writable target variant (calls _ensure_have_load_only and will raise ConfigurationError if a target variant is not configured). Raises ConfigurationError if an I/O error occurs while writing a file.
        """
        self._ensure_have_load_only()

        for fname, parser in self._modified_parsers:
            logger.info("Writing to %s", fname)

            # Ensure directory exists.
            ensure_dir(os.path.dirname(fname))

            # Ensure directory's permission(need to be writeable)
            try:
                with open(fname, "w") as f:
                    parser.write(f)
            except OSError as error:
                raise ConfigurationError(
                    f"An error occurred while writing to the configuration file "
                    f"{fname}: {error}"
                )

    #
    # Private routines
    #

    def _ensure_have_load_only(self) -> None:
        """
        Ensure a target configuration variant is selected for modification.
        
        Raises:
            ConfigurationError: If `self.load_only` is None (no specific variant chosen).
        """
        if self.load_only is None:
            raise ConfigurationError("Needed a specific file to be modifying.")
        logger.debug("Will be working with %s variant only", self.load_only)

    @property
    def _dictionary(self) -> Dict[str, Any]:
        """
        Return a merged mapping of loaded configuration keys to values.
        
        Builds the result by updating an initially empty dict with each variant's
        per-source dictionary in OVERRIDE_ORDER; later variants override earlier ones.
        The per-variant dictionaries must be populated by load() before calling this
        property. The returned dict is a snapshot (not a live view) of the current
        in-memory configuration.
        
        Returns:
            Dict[str, Any]: Merged configuration mapping in the form "section.name" -> value.
        """
        # NOTE: Dictionaries are not populated if not loaded. So, conditionals
        #       are not needed here.
        retval = {}

        for variant in OVERRIDE_ORDER:
            retval.update(self._config[variant])

        return retval

    def _load_config_files(self) -> None:
        """
        Load configuration from available configuration files and register their parsers.
        
        This method obtains the per-variant file lists from iter_config_files(), then reads
        each file with _load_file() and records the resulting (filename, parser) pairs in
        self._parsers for that variant.
        
        Behavior details:
        - If the environment-specified config file is set to os.devnull, loading is skipped.
        - If self.load_only is set, only files for that variant are loaded; other variants'
          files are ignored.
        - Side effects: populates self._parsers[variant] by appending (filename, parser).
        """
        config_files = dict(self.iter_config_files())
        if config_files[kinds.ENV][0:1] == [os.devnull]:
            logger.debug(
                "Skipping loading configuration files due to "
                "environment's PIP_CONFIG_FILE being os.devnull"
            )
            return

        for variant, files in config_files.items():
            for fname in files:
                # If there's specific variant set in `load_only`, load only
                # that variant, not the others.
                if self.load_only is not None and variant != self.load_only:
                    logger.debug("Skipping file '%s' (variant: %s)", fname, variant)
                    continue

                parser = self._load_file(variant, fname)

                # Keeping track of the parsers used
                self._parsers[variant].append((fname, parser))

    def _load_file(self, variant: Kind, fname: str) -> RawConfigParser:
        """
        Load the INI file at fname into a RawConfigParser and merge its settings into this Configuration's in-memory store for the given variant.
        
        Parameters:
            variant (Kind): Configuration source variant to attribute the loaded values to (e.g., USER, GLOBAL).
            fname (str): Path to the configuration file to load.
        
        Returns:
            RawConfigParser: The parser containing the file's parsed sections and options.
        
        Side effects:
            Updates self._config[variant] with keys from the file, normalized to `section.option` form.
        """
        logger.verbose("For variant '%s', will try loading '%s'", variant, fname)
        parser = self._construct_parser(fname)

        for section in parser.sections():
            items = parser.items(section)
            self._config[variant].update(self._normalized_keys(section, items))

        return parser

    def _construct_parser(self, fname: str) -> RawConfigParser:
        """
        Create and return a RawConfigParser for the given filename.
        
        If the file exists, attempts to read it with the system preferred encoding and
        populate the parser. If the file does not exist, returns an empty parser
        instance ready to be populated (useful when preparing to write a new config
        file).
        
        Parameters:
            fname (str): Path to the configuration file to load.
        
        Returns:
            RawConfigParser: A parser with the file's contents loaded if the file
            existed, otherwise an empty parser.
        
        Raises:
            ConfigurationFileCouldNotBeLoaded: If the file exists but cannot be read
            due to a Unicode decoding error (reports the locale encoding) or if the
            configparser raises a parsing-related error.
        """
        parser = configparser.RawConfigParser()
        # If there is no such file, don't bother reading it but create the
        # parser anyway, to hold the data.
        # Doing this is useful when modifying and saving files, where we don't
        # need to construct a parser.
        if os.path.exists(fname):
            locale_encoding = locale.getpreferredencoding(False)
            try:
                parser.read(fname, encoding=locale_encoding)
            except UnicodeDecodeError:
                # See https://github.com/pypa/pip/issues/4963
                raise ConfigurationFileCouldNotBeLoaded(
                    reason=f"contains invalid {locale_encoding} characters",
                    fname=fname,
                )
            except configparser.Error as error:
                # See https://github.com/pypa/pip/issues/4893
                raise ConfigurationFileCouldNotBeLoaded(error=error)
        return parser

    def _load_environment_vars(self) -> None:
        """
        Load configuration values derived from environment variables into the ENV_VAR variant.
        
        This reads environment variable pairs from get_environ_vars(), normalizes them into
        `section.name` keys via _normalized_keys using the section label ":env:", and updates
        self._config[kinds.ENV_VAR] with the resulting mapping.
        """
        self._config[kinds.ENV_VAR].update(
            self._normalized_keys(":env:", self.get_environ_vars())
        )

    def _normalized_keys(
        self, section: str, items: Iterable[Tuple[str, Any]]
    ) -> Dict[str, Any]:
        """
        Create a mapping of configuration keys in the form "section.name" with normalized names.
        
        Parameters:
            section (str): The configuration section name to prefix each key (e.g., "global", "install").
            items (Iterable[Tuple[str, Any]]): Iterable of (name, value) pairs from a source (file section items or environment-derived pairs).
            
        Returns:
            Dict[str, Any]: A dict mapping "section.<normalized-name>" to the corresponding value. Names are normalized via _normalize_name so keys are consistent across sources.
        """
        normalized = {}
        for name, val in items:
            key = section + "." + _normalize_name(name)
            normalized[key] = val
        return normalized

    def get_environ_vars(self) -> Iterable[Tuple[str, str]]:
        """
        Yield (name, value) pairs for environment variables that start with the `PIP_` prefix.
        
        The returned names have the leading `PIP_` removed and are lowercased. Variables listed in ENV_NAMES_IGNORED are skipped.
        """
        for key, val in os.environ.items():
            if key.startswith("PIP_"):
                name = key[4:].lower()
                if name not in ENV_NAMES_IGNORED:
                    yield name, val

    # XXX: This is patched in the tests.
    def iter_config_files(self) -> Iterable[Tuple[Kind, List[str]]]:
        """
        Yield (variant, files) pairs for configuration sources in the order they should be presented to the user.
        
        Each yielded tuple contains:
        - variant (Kind): one of kinds.GLOBAL, kinds.USER, kinds.SITE, kinds.ENV.
        - files (List[str]): filesystem paths for that variant (may be an empty list).
        
        Behavior notes:
        - The sequence is intended for display and iteration; merge/override precedence is governed separately by OVERRIDE_ORDER.
        - USER config is omitted when the Configuration was created as isolated or when the environment variable PIP_CONFIG_FILE points to an existing file.
        - If PIP_CONFIG_FILE is set, the ENV variant yields a single-element list with that path; otherwise ENV yields an empty list.
        """
        # SMELL: Move the conditions out of this function

        env_config_file = os.environ.get("PIP_CONFIG_FILE", None)
        config_files = get_configuration_files()

        yield kinds.GLOBAL, config_files[kinds.GLOBAL]

        # per-user config is not loaded when env_config_file exists
        should_load_user_config = not self.isolated and not (
            env_config_file and os.path.exists(env_config_file)
        )
        if should_load_user_config:
            # The legacy config file is overridden by the new config file
            yield kinds.USER, config_files[kinds.USER]

        # virtualenv config
        yield kinds.SITE, config_files[kinds.SITE]

        if env_config_file is not None:
            yield kinds.ENV, [env_config_file]
        else:
            yield kinds.ENV, []

    def get_values_in_config(self, variant: Kind) -> Dict[str, Any]:
        """
        Return the in-memory mapping of normalized configuration keys to values for a specific source variant.
        
        Parameters:
        	variant (Kind): The configuration source (e.g., kinds.USER, kinds.GLOBAL, kinds.ENV_VAR).
        
        Returns:
        	dict: A mapping from normalized keys ("section.option") to their values for the given variant. The returned dictionary is the internal per-variant store (i.e., a live reference).
        """
        return self._config[variant]

    def _get_parser_to_modify(self) -> Tuple[str, RawConfigParser]:
        # Determine which parser to modify
        """
        Return the (filename, parser) pair that should be modified for the current `load_only` variant.
        
        The method requires that `self.load_only` is set and selects the highest-priority parser
        (the last entry) from `self._parsers[self.load_only]`.
        
        Returns:
            Tuple[str, RawConfigParser]: The filename and corresponding RawConfigParser to edit.
        
        Raises:
            ConfigurationError: If `self._parsers[self.load_only]` is empty.
        """
        assert self.load_only
        parsers = self._parsers[self.load_only]
        if not parsers:
            # This should not happen if everything works correctly.
            raise ConfigurationError(
                "Fatal Internal error [id=2]. Please report as a bug."
            )

        # Use the highest priority parser.
        return parsers[-1]

    # XXX: This is patched in the tests.
    def _mark_as_modified(self, fname: str, parser: RawConfigParser) -> None:
        """
        Register a (filename, parser) pair as modified so it will be written by save().
        
        Appends the given (fname, parser) tuple to the internal _modified_parsers list if it is
        not already present, preventing duplicate entries.
        """
        file_parser_tuple = (fname, parser)
        if file_parser_tuple not in self._modified_parsers:
            self._modified_parsers.append(file_parser_tuple)

    def __repr__(self) -> str:
        """
        Return a short representation of the Configuration including its merged settings.
        
        The string is intended for debugging and contains the class name and the current
        merged configuration dictionary (as returned by the internal `_dictionary`).
        """
        return f"{self.__class__.__name__}({self._dictionary!r})"
