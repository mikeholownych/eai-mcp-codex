"""Support for installing and building the "wheel" binary package format.
"""

import collections
import compileall
import contextlib
import csv
import importlib
import logging
import os.path
import re
import shutil
import sys
import warnings
from base64 import urlsafe_b64encode
from email.message import Message
from itertools import chain, filterfalse, starmap
from typing import (
    IO,
    TYPE_CHECKING,
    Any,
    BinaryIO,
    Callable,
    Dict,
    Generator,
    Iterable,
    Iterator,
    List,
    NewType,
    Optional,
    Sequence,
    Set,
    Tuple,
    Union,
    cast,
)
from zipfile import ZipFile, ZipInfo

from pip._vendor.distlib.scripts import ScriptMaker
from pip._vendor.distlib.util import get_export_entry
from pip._vendor.packaging.utils import canonicalize_name

from pip._internal.exceptions import InstallationError
from pip._internal.locations import get_major_minor_version
from pip._internal.metadata import (
    BaseDistribution,
    FilesystemWheel,
    get_wheel_distribution,
)
from pip._internal.models.direct_url import DIRECT_URL_METADATA_NAME, DirectUrl
from pip._internal.models.scheme import SCHEME_KEYS, Scheme
from pip._internal.utils.filesystem import adjacent_tmp_file, replace
from pip._internal.utils.misc import captured_stdout, ensure_dir, hash_file, partition
from pip._internal.utils.unpacking import (
    current_umask,
    is_within_directory,
    set_extracted_file_to_default_mode_plus_executable,
    zip_item_is_executable,
)
from pip._internal.utils.wheel import parse_wheel

if TYPE_CHECKING:
    from typing import Protocol

    class File(Protocol):
        src_record_path: "RecordPath"
        dest_path: str
        changed: bool

        def save(self) -> None:
            """
            Save the wrapped file to its destination, then fix its shebang if necessary.
            
            This delegates to the underlying File.save(), and after the file is written attempts to
            replace a placeholder shebang (e.g. "#!python") with the current Python executable using
            fix_script. If the shebang was changed, the wrapper's `changed` flag is set to True.
            
            Side effects:
            - Writes the file to its destination.
            - May modify the file contents to update the shebang.
            """
            pass


logger = logging.getLogger(__name__)

RecordPath = NewType("RecordPath", str)
InstalledCSVRow = Tuple[RecordPath, str, Union[int, str]]


def rehash(path: str, blocksize: int = 1 << 20) -> Tuple[str, str]:
    """
    Return the SHA-256 digest and size for a file.
    
    Calculates the SHA-256 digest of the file at `path`, encodes it using URL-safe
    base64 without padding and prefixes it with `sha256=` (the form used in wheel
    RECORD entries). The file size is returned as a decimal string.
    
    Parameters:
        path: Filesystem path to the file to hash.
        blocksize: Read buffer size in bytes used while hashing (default 1<<20).
    
    Returns:
        A tuple (digest, length) where `digest` is the string `sha256=<base64-url>` (no
        padding) and `length` is the file size as a string.
    """
    h, length = hash_file(path, blocksize)
    digest = "sha256=" + urlsafe_b64encode(h.digest()).decode("latin1").rstrip("=")
    return (digest, str(length))


def csv_io_kwargs(mode: str) -> Dict[str, Any]:
    """
    Return keyword arguments suitable for opening CSV files with Python's built-in open().
    
    Ensures newline is set to an empty string (required for csv module to handle newlines
    consistently) and uses UTF-8 encoding. The provided `mode` is returned unchanged and
    should be a text mode compatible with the csv module (for example, 'r', 'w', 'a',
    or their combinations with 't').
    
    Parameters:
        mode: The file open mode string to use (e.g., 'r', 'w', 'a').
    
    Returns:
        A dict of keyword arguments to pass to open(), containing 'mode', 'newline', and 'encoding'.
    """
    return {"mode": mode, "newline": "", "encoding": "utf-8"}


def fix_script(path: str) -> bool:
    """
    Replace a shebang of the form "#!python" at the start of a file with the current Python executable path.
    
    If the file's first line begins with the bytes literal b"#!python", the shebang is replaced with "#!<sys.executable>\n" (using the file system encoding for the executable path) and the remainder of the file is preserved. Returns True when a replacement was made; returns False if the first line does not start with "#!python".
    
    Raises:
        AssertionError: if the given path does not refer to an existing file.
    """
    # XXX RECORD hashes will need to be updated
    assert os.path.isfile(path)

    with open(path, "rb") as script:
        firstline = script.readline()
        if not firstline.startswith(b"#!python"):
            return False
        exename = sys.executable.encode(sys.getfilesystemencoding())
        firstline = b"#!" + exename + os.linesep.encode("ascii")
        rest = script.read()
    with open(path, "wb") as script:
        script.write(firstline)
        script.write(rest)
    return True


def wheel_root_is_purelib(metadata: Message) -> bool:
    """
    Return True if the wheel metadata marks the wheel root as pure-Python (purelib).
    
    Checks the `Root-Is-Purelib` metadata field (case-insensitive) and returns True when its value is `"true"`. The `metadata` argument is an email.message.Message-like mapping of wheel metadata headers.
    """
    return metadata.get("Root-Is-Purelib", "").lower() == "true"


def get_entrypoints(dist: BaseDistribution) -> Tuple[Dict[str, str], Dict[str, str]]:
    """
    Collect console and GUI entry points from a distribution.
    
    Parameters:
        dist (BaseDistribution): Distribution providing entry points via `iter_entry_points()`.
    
    Returns:
        Tuple[Dict[str, str], Dict[str, str]]: A pair (console_scripts, gui_scripts) where each dict maps
        entry point name to its entry-point value (the callable specification string).
    """
    console_scripts = {}
    gui_scripts = {}
    for entry_point in dist.iter_entry_points():
        if entry_point.group == "console_scripts":
            console_scripts[entry_point.name] = entry_point.value
        elif entry_point.group == "gui_scripts":
            gui_scripts[entry_point.name] = entry_point.value
    return console_scripts, gui_scripts


def message_about_scripts_not_on_PATH(scripts: Sequence[str]) -> Optional[str]:
    """
    Return a multi-line warning if any installed script paths are not on PATH.
    
    Parameters:
        scripts (Sequence[str]): Iterable of installed script file paths (full paths).
    
    Returns:
        Optional[str]: A formatted multi-line warning listing the scripts and their
        installation directories that are not on the current PATH, or None if all
        scripts are in PATH (or otherwise exempt, e.g., located next to the Python
        interpreter). The message may include an additional note if PATH contains
        entries that start with '~'.
    """
    if not scripts:
        return None

    # Group scripts by the path they were installed in
    grouped_by_dir: Dict[str, Set[str]] = collections.defaultdict(set)
    for destfile in scripts:
        parent_dir = os.path.dirname(destfile)
        script_name = os.path.basename(destfile)
        grouped_by_dir[parent_dir].add(script_name)

    # We don't want to warn for directories that are on PATH.
    not_warn_dirs = [
        os.path.normcase(os.path.normpath(i)).rstrip(os.sep)
        for i in os.environ.get("PATH", "").split(os.pathsep)
    ]
    # If an executable sits with sys.executable, we don't warn for it.
    #     This covers the case of venv invocations without activating the venv.
    not_warn_dirs.append(
        os.path.normcase(os.path.normpath(os.path.dirname(sys.executable)))
    )
    warn_for: Dict[str, Set[str]] = {
        parent_dir: scripts
        for parent_dir, scripts in grouped_by_dir.items()
        if os.path.normcase(os.path.normpath(parent_dir)) not in not_warn_dirs
    }
    if not warn_for:
        return None

    # Format a message
    msg_lines = []
    for parent_dir, dir_scripts in warn_for.items():
        sorted_scripts: List[str] = sorted(dir_scripts)
        if len(sorted_scripts) == 1:
            start_text = f"script {sorted_scripts[0]} is"
        else:
            start_text = "scripts {} are".format(
                ", ".join(sorted_scripts[:-1]) + " and " + sorted_scripts[-1]
            )

        msg_lines.append(
            f"The {start_text} installed in '{parent_dir}' which is not on PATH."
        )

    last_line_fmt = (
        "Consider adding {} to PATH or, if you prefer "
        "to suppress this warning, use --no-warn-script-location."
    )
    if len(msg_lines) == 1:
        msg_lines.append(last_line_fmt.format("this directory"))
    else:
        msg_lines.append(last_line_fmt.format("these directories"))

    # Add a note if any directory starts with ~
    warn_for_tilde = any(
        i[0] == "~" for i in os.environ.get("PATH", "").split(os.pathsep) if i
    )
    if warn_for_tilde:
        tilde_warning_msg = (
            "NOTE: The current PATH contains path(s) starting with `~`, "
            "which may not be expanded by all applications."
        )
        msg_lines.append(tilde_warning_msg)

    # Returns the formatted multiline message
    return "\n".join(msg_lines)


def _normalized_outrows(
    outrows: Iterable[InstalledCSVRow],
) -> List[Tuple[str, str, str]]:
    """
    Normalize a sequence of RECORD rows into a deterministic list of string triples.
    
    Converts each RECORD row's elements to strings and returns a sorted list of
    3-tuples (path, hash, size). The input rows may have the size as an int,
    a string, or an empty string; this function coerces the size to a string to
    ensure consistent, comparable rows (useful for deterministic output in tests).
    """
    # Normally, there should only be one row per path, in which case the
    # second and third elements don't come into play when sorting.
    # However, in cases in the wild where a path might happen to occur twice,
    # we don't want the sort operation to trigger an error (but still want
    # determinism).  Since the third element can be an int or string, we
    # coerce each element to a string to avoid a TypeError in this case.
    # For additional background, see--
    # https://github.com/pypa/pip/issues/5868
    return sorted(
        (record_path, hash_, str(size)) for record_path, hash_, size in outrows
    )


def _record_to_fs_path(record_path: RecordPath, lib_dir: str) -> str:
    """
    Convert a RECORD-style installation path to a filesystem path under the given library directory.
    
    The `record_path` is a RECORD entry (a forward-slash-separated path relative to the package's lib directory).
    This returns the corresponding filesystem path by joining it with `lib_dir` using os.path.join, suitable
    for accessing the installed file on the current platform.
    """
    return os.path.join(lib_dir, record_path)


def _fs_to_record_path(path: str, lib_dir: str) -> RecordPath:
    # On Windows, do not handle relative paths if they belong to different
    # logical disks
    """
    Convert a filesystem path to a RECORD-format path (forward-slash separated).
    
    If the filesystem path and lib_dir are on the same Windows drive, the path
    is made relative to lib_dir; otherwise the original path is preserved.
    Path separators are normalized to forward slashes before returning.
    
    Parameters:
        path: Filesystem path to convert.
        lib_dir: The library root used as the reference for making `path`
            relative when possible.
    
    Returns:
        A RecordPath suitable for inclusion in a wheel RECORD (forward-slash
        separated, and relative to lib_dir when on the same drive).
    """
    if os.path.splitdrive(path)[0].lower() == os.path.splitdrive(lib_dir)[0].lower():
        path = os.path.relpath(path, lib_dir)

    path = path.replace(os.path.sep, "/")
    return cast("RecordPath", path)


def get_csv_rows_for_installed(
    old_csv_rows: List[List[str]],
    installed: Dict[RecordPath, RecordPath],
    changed: Set[RecordPath],
    generated: List[str],
    lib_dir: str,
) -> List[InstalledCSVRow]:
    """
    Build the final RECORD rows for an installation by updating entries from the wheel's RECORD
    and appending entries for generated or newly installed files.
    
    Detailed behavior:
    - Iterates the wheel's original RECORD rows (old_csv_rows). For each row:
      - Uses the first column as the archive RECORD path and looks up a mapped installation
        RECORD path in `installed`; if present, that mapping is used and removed from `installed`.
      - If the resulting RECORD path is listed in `changed`, recomputes its `sha256` digest and
        length from the filesystem; otherwise reuses the digest/length columns from the original row
        (if present).
      - Logs a warning if a RECORD row has more than three columns.
    - For each path in `generated`, computes its RECORD path relative to `lib_dir` and its digest/length,
      and appends it to the result.
    - Any remaining values in `installed` (mappings that were not present in `old_csv_rows`) are
      appended as entries with empty digest and length.
    - Note: this function mutates the `installed` mapping by popping entries that are consumed.
    
    Parameters:
        old_csv_rows: The parsed rows from the wheel's RECORD file (each row is a list of string
            columns, typically [record_path, digest, length]).
        installed: Mapping from archive RECORD path (RecordPath) to the installation RECORD path
            (RecordPath). This mapping is consumed (entries are popped) as rows are processed.
        changed: Set of installation RECORD paths that were modified during install and therefore
            must be rehashed from disk.
        generated: Filesystem paths (strings) to files created during installation whose digests
            should be computed and included in RECORD.
        lib_dir: The library installation directory used to convert between filesystem paths and
            RECORD paths.
    
    Returns:
        A list of InstalledCSVRow tuples (RecordPath, digest, length) representing the final
        RECORD content to be written for the installed distribution. Digests and lengths are
        strings (empty when not available).
    """
    installed_rows: List[InstalledCSVRow] = []
    for row in old_csv_rows:
        if len(row) > 3:
            logger.warning("RECORD line has more than three elements: %s", row)
        old_record_path = cast("RecordPath", row[0])
        new_record_path = installed.pop(old_record_path, old_record_path)
        if new_record_path in changed:
            digest, length = rehash(_record_to_fs_path(new_record_path, lib_dir))
        else:
            digest = row[1] if len(row) > 1 else ""
            length = row[2] if len(row) > 2 else ""
        installed_rows.append((new_record_path, digest, length))
    for f in generated:
        path = _fs_to_record_path(f, lib_dir)
        digest, length = rehash(f)
        installed_rows.append((path, digest, length))
    return installed_rows + [
        (installed_record_path, "", "") for installed_record_path in installed.values()
    ]


def get_console_script_specs(console: Dict[str, str]) -> List[str]:
    """
    Build console-script specification strings from a mapping of entry-point names to callables.
    
    Takes a mapping (entry name -> importable callable string) and returns a list of console-script specifiers of the form "name = package.module:callable". The function copies the input mapping and may modify that copy to handle special-case logic for pip and setuptools' easy_install entry points:
    
    - For "pip": generates appropriate unversioned and versioned wrappers depending on the ENSUREPIP_OPTIONS environment variable:
      - If ENSUREPIP_OPTIONS is unset: produces the unversioned "pip".
      - If ENSUREPIP_OPTIONS != "altinstall": produces "pipX" (major-version) as well.
      - Always produces "pipX.Y" (major.minor) for the current interpreter.
      - Removes any other pip-version entry points present in the original mapping.
    
    - For "easy_install": similarly generates "easy_install" (if ENSUREPIP_OPTIONS unset) and "easy_install-X.Y", and removes other versioned easy_install entries.
    
    All remaining console entry points from the wheel are converted to "name = callable" spec strings and appended to the result list.
    
    Returns:
        List[str]: Console script spec strings to be generated.
    """
    # Don't mutate caller's version
    console = console.copy()

    scripts_to_generate = []

    # Special case pip and setuptools to generate versioned wrappers
    #
    # The issue is that some projects (specifically, pip and setuptools) use
    # code in setup.py to create "versioned" entry points - pip2.7 on Python
    # 2.7, pip3.3 on Python 3.3, etc. But these entry points are baked into
    # the wheel metadata at build time, and so if the wheel is installed with
    # a *different* version of Python the entry points will be wrong. The
    # correct fix for this is to enhance the metadata to be able to describe
    # such versioned entry points, but that won't happen till Metadata 2.0 is
    # available.
    # In the meantime, projects using versioned entry points will either have
    # incorrect versioned entry points, or they will not be able to distribute
    # "universal" wheels (i.e., they will need a wheel per Python version).
    #
    # Because setuptools and pip are bundled with _ensurepip and virtualenv,
    # we need to use universal wheels. So, as a stopgap until Metadata 2.0, we
    # override the versioned entry points in the wheel and generate the
    # correct ones. This code is purely a short-term measure until Metadata 2.0
    # is available.
    #
    # To add the level of hack in this section of code, in order to support
    # ensurepip this code will look for an ``ENSUREPIP_OPTIONS`` environment
    # variable which will control which version scripts get installed.
    #
    # ENSUREPIP_OPTIONS=altinstall
    #   - Only pipX.Y and easy_install-X.Y will be generated and installed
    # ENSUREPIP_OPTIONS=install
    #   - pipX.Y, pipX, easy_install-X.Y will be generated and installed. Note
    #     that this option is technically if ENSUREPIP_OPTIONS is set and is
    #     not altinstall
    # DEFAULT
    #   - The default behavior is to install pip, pipX, pipX.Y, easy_install
    #     and easy_install-X.Y.
    pip_script = console.pop("pip", None)
    if pip_script:
        if "ENSUREPIP_OPTIONS" not in os.environ:
            scripts_to_generate.append("pip = " + pip_script)

        if os.environ.get("ENSUREPIP_OPTIONS", "") != "altinstall":
            scripts_to_generate.append(f"pip{sys.version_info[0]} = {pip_script}")

        scripts_to_generate.append(f"pip{get_major_minor_version()} = {pip_script}")
        # Delete any other versioned pip entry points
        pip_ep = [k for k in console if re.match(r"pip(\d+(\.\d+)?)?$", k)]
        for k in pip_ep:
            del console[k]
    easy_install_script = console.pop("easy_install", None)
    if easy_install_script:
        if "ENSUREPIP_OPTIONS" not in os.environ:
            scripts_to_generate.append("easy_install = " + easy_install_script)

        scripts_to_generate.append(
            f"easy_install-{get_major_minor_version()} = {easy_install_script}"
        )
        # Delete any other versioned easy_install entry points
        easy_install_ep = [
            k for k in console if re.match(r"easy_install(-\d+\.\d+)?$", k)
        ]
        for k in easy_install_ep:
            del console[k]

    # Generate the console entry points specified in the wheel
    scripts_to_generate.extend(starmap("{} = {}".format, console.items()))

    return scripts_to_generate


class ZipBackedFile:
    def __init__(
        self, src_record_path: RecordPath, dest_path: str, zip_file: ZipFile
    ) -> None:
        """
        Initialize a ZipBackedFile representing a file inside a wheel archive to be installed.
        
        Parameters:
            src_record_path (RecordPath): Path used in the wheel's RECORD for this file (a RECORD-style archive path).
            dest_path (str): Destination filesystem path where the file will be extracted.
        
        Notes:
            - `zip_file` is the ZipFile object containing the source file.
            - The instance attribute `changed` is initialized False and should be set to True if the file contents are modified during save().
        """
        self.src_record_path = src_record_path
        self.dest_path = dest_path
        self._zip_file = zip_file
        self.changed = False

    def _getinfo(self) -> ZipInfo:
        """
        Return the ZipInfo for this file's stored path inside the wheel archive.
        
        Returns:
            zipfile.ZipInfo: Metadata object for the archive member referred to by
                self.src_record_path.
        
        Raises:
            KeyError: If the archive does not contain an entry for self.src_record_path.
        """
        return self._zip_file.getinfo(self.src_record_path)

    def save(self) -> None:
        # directory creation is lazy and after file filtering
        # to ensure we don't install empty dirs; empty dirs can't be
        # uninstalled.
        """
        Write this file's member (from the source wheel ZIP) to its destination path on disk.
        
        Creates the destination directory if needed, removes any existing destination file before writing (to avoid issues with memory-mapped shared objects), extracts the ZIP entry to the destination, and if the ZIP entry is marked executable, updates the extracted file's mode to include the executable bit.
        
        Side effects:
        - May create parent directories.
        - May unlink an existing file at the destination.
        - Writes the destination file and may change its file mode.
        
        Returns:
            None
        """
        parent_dir = os.path.dirname(self.dest_path)
        ensure_dir(parent_dir)

        # When we open the output file below, any existing file is truncated
        # before we start writing the new contents. This is fine in most
        # cases, but can cause a segfault if pip has loaded a shared
        # object (e.g. from pyopenssl through its vendored urllib3)
        # Since the shared object is mmap'd an attempt to call a
        # symbol in it will then cause a segfault. Unlinking the file
        # allows writing of new contents while allowing the process to
        # continue to use the old copy.
        if os.path.exists(self.dest_path):
            os.unlink(self.dest_path)

        zipinfo = self._getinfo()

        with self._zip_file.open(zipinfo) as f:
            with open(self.dest_path, "wb") as dest:
                shutil.copyfileobj(f, dest)

        if zip_item_is_executable(zipinfo):
            set_extracted_file_to_default_mode_plus_executable(self.dest_path)


class ScriptFile:
    def __init__(self, file: "File") -> None:
        """
        Initialize the ScriptFile wrapper around a File-like object.
        
        Parameters:
            file: The underlying File object to wrap. Its `src_record_path` and `dest_path`
                are copied to this wrapper. The wrapper starts with `changed` set to False.
        """
        self._file = file
        self.src_record_path = self._file.src_record_path
        self.dest_path = self._file.dest_path
        self.changed = False

    def save(self) -> None:
        """
        Save the underlying file and update this ScriptFile's changed flag if the script shebang was rewritten.
        
        This delegates to the wrapped File.save(), then runs fix_script() on the file's destination path.
        If the shebang was modified (e.g., replacing a "#!python" placeholder), sets self.changed to True; otherwise False.
        """
        self._file.save()
        self.changed = fix_script(self.dest_path)


class MissingCallableSuffix(InstallationError):
    def __init__(self, entry_point: str) -> None:
        """
        Initialize the MissingCallableSuffix exception for an entry-point missing a callable suffix.
        
        Parameters:
            entry_point (str): The entry-point string that lacks the required ``module:callable`` suffix.
        """
        super().__init__(
            f"Invalid script entry point: {entry_point} - A callable "
            "suffix is required. Cf https://packaging.python.org/"
            "specifications/entry-points/#use-for-scripts for more "
            "information."
        )


def _raise_for_invalid_entrypoint(specification: str) -> None:
    """
    Validate an entry-point specification contains an explicit callable suffix.
    
    Parse the given entry-point `specification` using `get_export_entry`. If the
    specification parses to an export entry but that entry lacks a callable suffix
    (e.g. no `.name` or similar suffix expected by the packaging format), raise
    MissingCallableSuffix describing the problematic entry.
    
    Args:
        specification (str): An entry-point specification string to validate.
    
    Raises:
        MissingCallableSuffix: If the parsed export entry exists but its `suffix`
            attribute is None.
    """
    entry = get_export_entry(specification)
    if entry is not None and entry.suffix is None:
        raise MissingCallableSuffix(str(entry))


class PipScriptMaker(ScriptMaker):
    def make(
        self, specification: str, options: Optional[Dict[str, Any]] = None
    ) -> List[str]:
        """
        Validate an entry-point specification then delegate script generation to the base ScriptMaker.
        
        The method first ensures the `specification` includes a callable suffix and raises MissingCallableSuffix (an InstallationError subclass) if it does not. After validation, it calls the superclass implementation to create the script(s).
        
        Parameters:
            specification (str): Entry-point specification (e.g. "module:callable") to generate wrappers for.
            options (Optional[Dict[str, Any]]): Optional maker-specific options forwarded to the superclass.
        
        Returns:
            List[str]: Paths of the generated script files.
        
        Raises:
            MissingCallableSuffix: If the entry-point specification lacks the required callable suffix.
        """
        _raise_for_invalid_entrypoint(specification)
        return super().make(specification, options)


def _install_wheel(
    name: str,
    wheel_zip: ZipFile,
    wheel_path: str,
    scheme: Scheme,
    pycompile: bool = True,
    warn_script_location: bool = True,
    direct_url: Optional[DirectUrl] = None,
    requested: bool = False,
) -> None:
    """
    Install a wheel archive into the given installation scheme.
    
    This extracts files from the provided open ZipFile, maps wheel RECORD paths
    to installation RECORD paths, writes installed files into the appropriate
    scheme directories (purelib vs platlib based on wheel metadata), generates
    script entry points, optionally byte-compiles installed Python sources to
    .pyc files, and writes package metadata files (INSTALLER, RECORD, optional
    direct URL and REQUESTED marker).
    
    Parameters:
        name: Project name as declared to locate distribution metadata.
        wheel_zip: An opened zipfile.ZipFile for the wheel to install.
        wheel_path: Filesystem path to the wheel file (used for error messages).
        scheme: Installation scheme describing destination directories.
        pycompile: If True, byte-compile installed .py files to .pyc and record them.
        warn_script_location: If True, warn when generated scripts are installed to
            locations not present on PATH.
        direct_url: Optional PEP 610 DirectUrl to write into the package metadata.
        requested: If True, write a REQUESTED marker file into the package metadata.
    
    Raises:
        InstallationError: On path-traversal attempts, unexpected or invalid
            .data scheme contents, unknown scheme keys, or other installation
            validation failures.
    
    Side effects:
        - Extracts files from the wheel and writes them into the filesystem.
        - May modify script shebangs and overwrite existing scripts.
        - Writes INSTALLER, RECORD, optionally DIRECT_URL metadata and REQUESTED.
        - Generates and may overwrite script wrappers according to wheel entry points.
    """
    info_dir, metadata = parse_wheel(wheel_zip, name)

    if wheel_root_is_purelib(metadata):
        lib_dir = scheme.purelib
    else:
        lib_dir = scheme.platlib

    # Record details of the files moved
    #   installed = files copied from the wheel to the destination
    #   changed = files changed while installing (scripts #! line typically)
    #   generated = files newly generated during the install (script wrappers)
    installed: Dict[RecordPath, RecordPath] = {}
    changed: Set[RecordPath] = set()
    generated: List[str] = []

    def record_installed(
        srcfile: RecordPath, destfile: str, modified: bool = False
    ) -> None:
        """
        Record a file installed from the wheel by mapping its source RECORD path to the installation RECORD path.
        
        This stores the RECORD-style destination path for srcfile in the local `installed` mapping and, if `modified`
        is True, marks the destination RECORD path as changed (added to the `changed` set) so its digest/size will be
        recomputed.
        
        Parameters:
            srcfile: The path as listed in the wheel's RECORD (RecordPath).
            destfile: The filesystem path where the file was written; it will be converted to a RECORD-style path
                relative to the installation `lib_dir`.
            modified: If True, indicates the destination content differs from the original (requires rehashing).
        """
        newpath = _fs_to_record_path(destfile, lib_dir)
        installed[srcfile] = newpath
        if modified:
            changed.add(newpath)

    def is_dir_path(path: RecordPath) -> bool:
        """
        Return True if a RECORD-style path represents a directory.
        
        In wheel RECORD entries, directory paths are denoted by a trailing '/'.
        This function returns True when the given RecordPath ends with '/'.
        """
        return path.endswith("/")

    def assert_no_path_traversal(dest_dir_path: str, target_path: str) -> None:
        """
        Ensure a target filesystem path is inside a destination directory.
        
        Checks that target_path is contained within dest_dir_path and raises an InstallationError
        if the target would install outside the destination directory (path traversal).
        
        Parameters:
            dest_dir_path (str): The intended destination directory on the filesystem.
            target_path (str): The filesystem path of the file to be installed.
        
        Raises:
            InstallationError: If target_path is not within dest_dir_path.
        """
        if not is_within_directory(dest_dir_path, target_path):
            message = (
                "The wheel {!r} has a file {!r} trying to install"
                " outside the target directory {!r}"
            )
            raise InstallationError(
                message.format(wheel_path, target_path, dest_dir_path)
            )

    def root_scheme_file_maker(
        zip_file: ZipFile, dest: str
    ) -> Callable[[RecordPath], "File"]:
        """
        Return a factory that maps a RECORD path to a ZipBackedFile installed under the given destination directory.
        
        The returned callable takes a RECORD-style path (RecordPath), normalizes it, joins it with `dest` to form the filesystem destination, and asserts the resulting path does not escape `dest` (prevents path traversal). It then returns a ZipBackedFile that will extract the corresponding file from `zip_file` to that destination.
        
        Parameters:
            zip_file: The source ZipFile containing wheel members.
            dest: Filesystem directory under which RECORD paths should be installed.
        
        Returns:
            A callable RecordPath -> File (specifically a ZipBackedFile) that prepares files for installation.
        """
        def make_root_scheme_file(record_path: RecordPath) -> "File":
            normed_path = os.path.normpath(record_path)
            dest_path = os.path.join(dest, normed_path)
            assert_no_path_traversal(dest, dest_path)
            return ZipBackedFile(record_path, dest_path, zip_file)

        return make_root_scheme_file

    def data_scheme_file_maker(
        zip_file: ZipFile, scheme: Scheme
    ) -> Callable[[RecordPath], "File"]:
        """
        Return a factory that maps a RECORD-style `.data` path to a ZipBackedFile for installation.
        
        The returned callable expects a RECORD path from a wheel's .data directory in the form
        "<scheme_key>/<relative/path>" (using the local OS path separator). It resolves the
        scheme_key against the provided installation scheme, constructs the destination path
        inside that scheme, checks for path-traversal, and returns a ZipBackedFile that will
        extract the ZIP member to that destination.
        
        Raises:
            InstallationError: if the record path is not of the form "<scheme_key>/<path>"
                or if the scheme_key is not one of the valid scheme keys.
        """
        scheme_paths = {key: getattr(scheme, key) for key in SCHEME_KEYS}

        def make_data_scheme_file(record_path: RecordPath) -> "File":
            """
            Create a File object for a wheel `.data`-scheme entry.
            
            Parses a RECORD-style path under the wheel's `.data` directory of the form
            "<scheme key>/<relative path>", maps the scheme key to the target install
            directory, and returns a ZipBackedFile that will extract the file to that
            destination.
            
            Parameters:
                record_path (RecordPath): RECORD path for the file inside the wheel's
                    `.data` tree (expected to contain "<scheme key>/<path>").
            
            Returns:
                File: a ZipBackedFile configured to extract the given record path to the
                computed destination path.
            
            Raises:
                InstallationError: if `record_path` does not have the expected two-part
                    structure under `.data`, or if the scheme key is unknown.
                InstallationError: if path traversal outside the target scheme directory
                    is detected (via assert_no_path_traversal).
            """
            normed_path = os.path.normpath(record_path)
            try:
                _, scheme_key, dest_subpath = normed_path.split(os.path.sep, 2)
            except ValueError:
                message = (
                    "Unexpected file in {}: {!r}. .data directory contents"
                    " should be named like: '<scheme key>/<path>'."
                ).format(wheel_path, record_path)
                raise InstallationError(message)

            try:
                scheme_path = scheme_paths[scheme_key]
            except KeyError:
                valid_scheme_keys = ", ".join(sorted(scheme_paths))
                message = (
                    "Unknown scheme key used in {}: {} (for file {!r}). .data"
                    " directory contents should be in subdirectories named"
                    " with a valid scheme key ({})"
                ).format(wheel_path, scheme_key, record_path, valid_scheme_keys)
                raise InstallationError(message)

            dest_path = os.path.join(scheme_path, dest_subpath)
            assert_no_path_traversal(scheme_path, dest_path)
            return ZipBackedFile(record_path, dest_path, zip_file)

        return make_data_scheme_file

    def is_data_scheme_path(path: RecordPath) -> bool:
        """
        Return True if the given RECORD-style path is located in a top-level `.data` scheme directory.
        
        This expects `path` to be a RECORD path using forward slashes (e.g., "package.data/data_file" or
        "package-1.0.dist-info/RECORD"). The check inspects the first path component and returns True when
        that component ends with ".data".
        
        Parameters:
            path (RecordPath): A RECORD-style path (forward-slash-separated).
        
        Returns:
            bool: True if the path's top-level component ends with ".data", otherwise False.
        """
        return path.split("/", 1)[0].endswith(".data")

    paths = cast(List[RecordPath], wheel_zip.namelist())
    file_paths = filterfalse(is_dir_path, paths)
    root_scheme_paths, data_scheme_paths = partition(is_data_scheme_path, file_paths)

    make_root_scheme_file = root_scheme_file_maker(wheel_zip, lib_dir)
    files: Iterator[File] = map(make_root_scheme_file, root_scheme_paths)

    def is_script_scheme_path(path: RecordPath) -> bool:
        """
        Return True if a RECORD-style path refers to a .data/scripts entry in a wheel.
        
        This checks whether the given RECORD path uses forward slashes and has the form
        "<something>.data/scripts/..." (i.e., the first path component ends with
        ".data" and the second component is "scripts").
        
        Parameters:
            path (RecordPath): A wheel RECORD-style path (using '/' separators).
        
        Returns:
            bool: True if the path points into a `.data/scripts` directory, otherwise False.
        """
        parts = path.split("/", 2)
        return len(parts) > 2 and parts[0].endswith(".data") and parts[1] == "scripts"

    other_scheme_paths, script_scheme_paths = partition(
        is_script_scheme_path, data_scheme_paths
    )

    make_data_scheme_file = data_scheme_file_maker(wheel_zip, scheme)
    other_scheme_files = map(make_data_scheme_file, other_scheme_paths)
    files = chain(files, other_scheme_files)

    # Get the defined entry points
    distribution = get_wheel_distribution(
        FilesystemWheel(wheel_path),
        canonicalize_name(name),
    )
    console, gui = get_entrypoints(distribution)

    def is_entrypoint_wrapper(file: "File") -> bool:
        # EP, EP.exe and EP-script.py are scripts generated for
        # entry point EP by setuptools
        """
        Return True if the given File represents a setuptools-generated entry-point wrapper.
        
        Checks the file's destination basename (case-insensitive) with common setuptools wrapper suffixes
        ('.exe', '-script.py', '.pya') stripped and determines whether the resulting name matches any
        known console or GUI entry point names (from the module-level `console` and `gui` mappings).
        
        Parameters:
            file: A File-like object with a `dest_path` attribute (the intended installation path).
        
        Returns:
            bool: True if the file is a setuptools entry-point wrapper, False otherwise.
        """
        path = file.dest_path
        name = os.path.basename(path)
        if name.lower().endswith(".exe"):
            matchname = name[:-4]
        elif name.lower().endswith("-script.py"):
            matchname = name[:-10]
        elif name.lower().endswith("-script.pyw"):
            matchname = name[:-12]
        else:
            matchname = name
        # Ignore setuptools-generated scripts
        return matchname in console or matchname in gui

    script_scheme_files: Iterator[File] = map(
        make_data_scheme_file, script_scheme_paths
    )
    script_scheme_files = filterfalse(is_entrypoint_wrapper, script_scheme_files)
    script_scheme_files = map(ScriptFile, script_scheme_files)
    files = chain(files, script_scheme_files)

    for file in files:
        file.save()
        record_installed(file.src_record_path, file.dest_path, file.changed)

    def pyc_source_file_paths() -> Generator[str, None, None]:
        # We de-duplicate installation paths, since there can be overlap (e.g.
        # file in .data maps to same location as file in wheel root).
        # Sorting installation paths makes it easier to reproduce and debug
        # issues related to permissions on existing files.
        """
        Yield absolute filesystem paths to installed Python source files (.py) that should be byte-compiled.
        
        This generator iterates the set of recorded installation paths (deduplicated and sorted for deterministic ordering), joins each RECORD-style path to the installation library directory, filters out non-existent files and non-`.py` files, and yields the full filesystem path for each remaining source file.
        """
        for installed_path in sorted(set(installed.values())):
            full_installed_path = os.path.join(lib_dir, installed_path)
            if not os.path.isfile(full_installed_path):
                continue
            if not full_installed_path.endswith(".py"):
                continue
            yield full_installed_path

    def pyc_output_path(path: str) -> str:
        """
        Return the filesystem path where the compiled bytecode (.pyc) for a given Python source file would be written.
        
        Parameters:
            path (str): Path to the Python source file (usually ending in `.py`).
        
        Returns:
            str: The path to the corresponding `.pyc` file as determined by importlib.util.cache_from_source.
        """
        return importlib.util.cache_from_source(path)

    # Compile all of the pyc files for the installed files
    if pycompile:
        with captured_stdout() as stdout:
            with warnings.catch_warnings():
                warnings.filterwarnings("ignore")
                for path in pyc_source_file_paths():
                    success = compileall.compile_file(path, force=True, quiet=True)
                    if success:
                        pyc_path = pyc_output_path(path)
                        assert os.path.exists(pyc_path)
                        pyc_record_path = cast(
                            "RecordPath", pyc_path.replace(os.path.sep, "/")
                        )
                        record_installed(pyc_record_path, pyc_path)
        logger.debug(stdout.getvalue())

    maker = PipScriptMaker(None, scheme.scripts)

    # Ensure old scripts are overwritten.
    # See https://github.com/pypa/pip/issues/1800
    maker.clobber = True

    # Ensure we don't generate any variants for scripts because this is almost
    # never what somebody wants.
    # See https://bitbucket.org/pypa/distlib/issue/35/
    maker.variants = {""}

    # This is required because otherwise distlib creates scripts that are not
    # executable.
    # See https://bitbucket.org/pypa/distlib/issue/32/
    maker.set_mode = True

    # Generate the console and GUI entry points specified in the wheel
    scripts_to_generate = get_console_script_specs(console)

    gui_scripts_to_generate = list(starmap("{} = {}".format, gui.items()))

    generated_console_scripts = maker.make_multiple(scripts_to_generate)
    generated.extend(generated_console_scripts)

    generated.extend(maker.make_multiple(gui_scripts_to_generate, {"gui": True}))

    if warn_script_location:
        msg = message_about_scripts_not_on_PATH(generated_console_scripts)
        if msg is not None:
            logger.warning(msg)

    generated_file_mode = 0o666 & ~current_umask()

    @contextlib.contextmanager
    def _generate_file(path: str, **kwargs: Any) -> Generator[BinaryIO, None, None]:
        """
        Context manager that yields a temporary binary file adjacent to `path` for atomic file creation.
        
        Yields a writable binary file object. On exit the temporary file's permissions are set to the module's generated-file mode and the temporary file is atomically moved to `path` (replacing any existing file). Any keyword arguments are forwarded to adjacent_tmp_file (e.g., mode, suffix, dir).
        """
        with adjacent_tmp_file(path, **kwargs) as f:
            yield f
        os.chmod(f.name, generated_file_mode)
        replace(f.name, path)

    dest_info_dir = os.path.join(lib_dir, info_dir)

    # Record pip as the installer
    installer_path = os.path.join(dest_info_dir, "INSTALLER")
    with _generate_file(installer_path) as installer_file:
        installer_file.write(b"pip\n")
    generated.append(installer_path)

    # Record the PEP 610 direct URL reference
    if direct_url is not None:
        direct_url_path = os.path.join(dest_info_dir, DIRECT_URL_METADATA_NAME)
        with _generate_file(direct_url_path) as direct_url_file:
            direct_url_file.write(direct_url.to_json().encode("utf-8"))
        generated.append(direct_url_path)

    # Record the REQUESTED file
    if requested:
        requested_path = os.path.join(dest_info_dir, "REQUESTED")
        with open(requested_path, "wb"):
            pass
        generated.append(requested_path)

    record_text = distribution.read_text("RECORD")
    record_rows = list(csv.reader(record_text.splitlines()))

    rows = get_csv_rows_for_installed(
        record_rows,
        installed=installed,
        changed=changed,
        generated=generated,
        lib_dir=lib_dir,
    )

    # Record details of all files installed
    record_path = os.path.join(dest_info_dir, "RECORD")

    with _generate_file(record_path, **csv_io_kwargs("w")) as record_file:
        # Explicitly cast to typing.IO[str] as a workaround for the mypy error:
        # "writer" has incompatible type "BinaryIO"; expected "_Writer"
        writer = csv.writer(cast("IO[str]", record_file))
        writer.writerows(_normalized_outrows(rows))


@contextlib.contextmanager
def req_error_context(req_description: str) -> Generator[None, None, None]:
    """
    Context manager that augments InstallationError messages with a request description.
    
    When used as a context manager, any InstallationError raised inside the block will be
    re-raised with its message prefixed by "For req: {req_description}. ", preserving the
    original exception as the __cause__.
    
    Parameters:
        req_description (str): A short description of the request (e.g., requirement string)
            to include in the augmented error message.
    """
    try:
        yield
    except InstallationError as e:
        message = f"For req: {req_description}. {e.args[0]}"
        raise InstallationError(message) from e


def install_wheel(
    name: str,
    wheel_path: str,
    scheme: Scheme,
    req_description: str,
    pycompile: bool = True,
    warn_script_location: bool = True,
    direct_url: Optional[DirectUrl] = None,
    requested: bool = False,
) -> None:
    """
    Install a wheel file into the given installation scheme.
    
    Opens the wheel file at `wheel_path` and delegates the actual installation to the internal
    installer. The operation extracts files from the wheel, writes metadata (including RECORD,
    INSTALLER, optional direct URL and REQUESTED marker), generates or updates script entry-points,
    and (optionally) byte-compiles installed Python sources.
    
    Parameters:
        name (str): Distribution name (used for metadata and logging).
        wheel_path (str): Filesystem path to the .whl archive to install.
        scheme (Scheme): Installation scheme describing destination directories (purelib/platlib,
            scripts, data, etc.).
        req_description (str): Short description of the request; on installation errors this text
            is appended to the error message to provide context.
        pycompile (bool): If True, attempt to compile installed .py files to .pyc.
        warn_script_location (bool): If True, emit a warning if generated scripts are installed
            to locations not on the user's PATH.
        direct_url (Optional[DirectUrl]): Optional PEP 610 direct URL to record in metadata.
        requested (bool): If True, write the REQUESTED marker file into installed metadata.
    
    Raises:
        InstallationError: For installation failures; the exception message will include
        `req_description` for additional context.
    """
    with ZipFile(wheel_path, allowZip64=True) as z:
        with req_error_context(req_description):
            _install_wheel(
                name=name,
                wheel_zip=z,
                wheel_path=wheel_path,
                scheme=scheme,
                pycompile=pycompile,
                warn_script_location=warn_script_location,
                direct_url=direct_url,
                requested=requested,
            )
